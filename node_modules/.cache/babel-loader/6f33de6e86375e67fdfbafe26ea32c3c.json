{"ast":null,"code":"\"use strict\"; // Using a unique object to compare by reference.\n\nvar traverseDocOnExitStackMarker = {};\n\nfunction traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {\n  var docsStack = [doc];\n\n  while (docsStack.length !== 0) {\n    var _doc = docsStack.pop();\n\n    if (_doc === traverseDocOnExitStackMarker) {\n      onExit(docsStack.pop());\n      continue;\n    }\n\n    var shouldRecurse = true;\n\n    if (onEnter) {\n      if (onEnter(_doc) === false) {\n        shouldRecurse = false;\n      }\n    }\n\n    if (onExit) {\n      docsStack.push(_doc);\n      docsStack.push(traverseDocOnExitStackMarker);\n    }\n\n    if (shouldRecurse) {\n      // When there are multiple parts to process,\n      // the parts need to be pushed onto the stack in reverse order,\n      // so that they are processed in the original order\n      // when the stack is popped.\n      if (_doc.type === \"concat\" || _doc.type === \"fill\") {\n        for (var ic = _doc.parts.length, i = ic - 1; i >= 0; --i) {\n          docsStack.push(_doc.parts[i]);\n        }\n      } else if (_doc.type === \"if-break\") {\n        if (_doc.flatContents) {\n          docsStack.push(_doc.flatContents);\n        }\n\n        if (_doc.breakContents) {\n          docsStack.push(_doc.breakContents);\n        }\n      } else if (_doc.type === \"group\" && _doc.expandedStates) {\n        if (shouldTraverseConditionalGroups) {\n          for (var _ic = _doc.expandedStates.length, _i = _ic - 1; _i >= 0; --_i) {\n            docsStack.push(_doc.expandedStates[_i]);\n          }\n        } else {\n          docsStack.push(_doc.contents);\n        }\n      } else if (_doc.contents) {\n        docsStack.push(_doc.contents);\n      }\n    }\n  }\n}\n\nfunction mapDoc(doc, cb) {\n  if (doc.type === \"concat\" || doc.type === \"fill\") {\n    var parts = doc.parts.map(function (part) {\n      return mapDoc(part, cb);\n    });\n    return cb(Object.assign({}, doc, {\n      parts: parts\n    }));\n  } else if (doc.type === \"if-break\") {\n    var breakContents = doc.breakContents && mapDoc(doc.breakContents, cb);\n    var flatContents = doc.flatContents && mapDoc(doc.flatContents, cb);\n    return cb(Object.assign({}, doc, {\n      breakContents: breakContents,\n      flatContents: flatContents\n    }));\n  } else if (doc.contents) {\n    var contents = mapDoc(doc.contents, cb);\n    return cb(Object.assign({}, doc, {\n      contents: contents\n    }));\n  }\n\n  return cb(doc);\n}\n\nfunction findInDoc(doc, fn, defaultValue) {\n  var result = defaultValue;\n  var hasStopped = false;\n\n  function findInDocOnEnterFn(doc) {\n    var maybeResult = fn(doc);\n\n    if (maybeResult !== undefined) {\n      hasStopped = true;\n      result = maybeResult;\n    }\n\n    if (hasStopped) {\n      return false;\n    }\n  }\n\n  traverseDoc(doc, findInDocOnEnterFn);\n  return result;\n}\n\nfunction isEmpty(n) {\n  return typeof n === \"string\" && n.length === 0;\n}\n\nfunction isLineNextFn(doc) {\n  if (typeof doc === \"string\") {\n    return false;\n  }\n\n  if (doc.type === \"line\") {\n    return true;\n  }\n}\n\nfunction isLineNext(doc) {\n  return findInDoc(doc, isLineNextFn, false);\n}\n\nfunction willBreakFn(doc) {\n  if (doc.type === \"group\" && doc[\"break\"]) {\n    return true;\n  }\n\n  if (doc.type === \"line\" && doc.hard) {\n    return true;\n  }\n\n  if (doc.type === \"break-parent\") {\n    return true;\n  }\n}\n\nfunction willBreak(doc) {\n  return findInDoc(doc, willBreakFn, false);\n}\n\nfunction breakParentGroup(groupStack) {\n  if (groupStack.length > 0) {\n    var parentGroup = groupStack[groupStack.length - 1]; // Breaks are not propagated through conditional groups because\n    // the user is expected to manually handle what breaks.\n\n    if (!parentGroup.expandedStates) {\n      parentGroup[\"break\"] = true;\n    }\n  }\n\n  return null;\n}\n\nfunction propagateBreaks(doc) {\n  var alreadyVisitedSet = new Set();\n  var groupStack = [];\n\n  function propagateBreaksOnEnterFn(doc) {\n    if (doc.type === \"break-parent\") {\n      breakParentGroup(groupStack);\n    }\n\n    if (doc.type === \"group\") {\n      groupStack.push(doc);\n\n      if (alreadyVisitedSet.has(doc)) {\n        return false;\n      }\n\n      alreadyVisitedSet.add(doc);\n    }\n  }\n\n  function propagateBreaksOnExitFn(doc) {\n    if (doc.type === \"group\") {\n      var group = groupStack.pop();\n\n      if (group[\"break\"]) {\n        breakParentGroup(groupStack);\n      }\n    }\n  }\n\n  traverseDoc(doc, propagateBreaksOnEnterFn, propagateBreaksOnExitFn,\n  /* shouldTraverseConditionalGroups */\n  true);\n}\n\nfunction removeLinesFn(doc) {\n  // Force this doc into flat mode by statically converting all\n  // lines into spaces (or soft lines into nothing). Hard lines\n  // should still output because there's too great of a chance\n  // of breaking existing assumptions otherwise.\n  if (doc.type === \"line\" && !doc.hard) {\n    return doc.soft ? \"\" : \" \";\n  } else if (doc.type === \"if-break\") {\n    return doc.flatContents || \"\";\n  }\n\n  return doc;\n}\n\nfunction removeLines(doc) {\n  return mapDoc(doc, removeLinesFn);\n}\n\nfunction stripTrailingHardline(doc) {\n  // HACK remove ending hardline, original PR: #1984\n  if (doc.type === \"concat\" && doc.parts.length !== 0) {\n    var lastPart = doc.parts[doc.parts.length - 1];\n\n    if (lastPart.type === \"concat\") {\n      if (lastPart.parts.length === 2 && lastPart.parts[0].hard && lastPart.parts[1].type === \"break-parent\") {\n        return {\n          type: \"concat\",\n          parts: doc.parts.slice(0, -1)\n        };\n      }\n\n      return {\n        type: \"concat\",\n        parts: doc.parts.slice(0, -1).concat(stripTrailingHardline(lastPart))\n      };\n    }\n  }\n\n  return doc;\n}\n\nmodule.exports = {\n  isEmpty: isEmpty,\n  willBreak: willBreak,\n  isLineNext: isLineNext,\n  traverseDoc: traverseDoc,\n  findInDoc: findInDoc,\n  mapDoc: mapDoc,\n  propagateBreaks: propagateBreaks,\n  removeLines: removeLines,\n  stripTrailingHardline: stripTrailingHardline\n};","map":{"version":3,"sources":["/Users/pranamyavadlamani/Desktop/Research/PortFolio/portfolio-site/node_modules/@miksu/prettier/lib/doc/doc-utils.js"],"names":["traverseDocOnExitStackMarker","traverseDoc","doc","onEnter","onExit","shouldTraverseConditionalGroups","docsStack","length","_doc","pop","shouldRecurse","push","type","ic","parts","i","flatContents","breakContents","expandedStates","_ic","_i","contents","mapDoc","cb","map","part","Object","assign","findInDoc","fn","defaultValue","result","hasStopped","findInDocOnEnterFn","maybeResult","undefined","isEmpty","n","isLineNextFn","isLineNext","willBreakFn","hard","willBreak","breakParentGroup","groupStack","parentGroup","propagateBreaks","alreadyVisitedSet","Set","propagateBreaksOnEnterFn","has","add","propagateBreaksOnExitFn","group","removeLinesFn","soft","removeLines","stripTrailingHardline","lastPart","slice","concat","module","exports"],"mappings":"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","sourcesContent":["\"use strict\"; // Using a unique object to compare by reference.\n\nvar traverseDocOnExitStackMarker = {};\n\nfunction traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {\n  var docsStack = [doc];\n\n  while (docsStack.length !== 0) {\n    var _doc = docsStack.pop();\n\n    if (_doc === traverseDocOnExitStackMarker) {\n      onExit(docsStack.pop());\n      continue;\n    }\n\n    var shouldRecurse = true;\n\n    if (onEnter) {\n      if (onEnter(_doc) === false) {\n        shouldRecurse = false;\n      }\n    }\n\n    if (onExit) {\n      docsStack.push(_doc);\n      docsStack.push(traverseDocOnExitStackMarker);\n    }\n\n    if (shouldRecurse) {\n      // When there are multiple parts to process,\n      // the parts need to be pushed onto the stack in reverse order,\n      // so that they are processed in the original order\n      // when the stack is popped.\n      if (_doc.type === \"concat\" || _doc.type === \"fill\") {\n        for (var ic = _doc.parts.length, i = ic - 1; i >= 0; --i) {\n          docsStack.push(_doc.parts[i]);\n        }\n      } else if (_doc.type === \"if-break\") {\n        if (_doc.flatContents) {\n          docsStack.push(_doc.flatContents);\n        }\n\n        if (_doc.breakContents) {\n          docsStack.push(_doc.breakContents);\n        }\n      } else if (_doc.type === \"group\" && _doc.expandedStates) {\n        if (shouldTraverseConditionalGroups) {\n          for (var _ic = _doc.expandedStates.length, _i = _ic - 1; _i >= 0; --_i) {\n            docsStack.push(_doc.expandedStates[_i]);\n          }\n        } else {\n          docsStack.push(_doc.contents);\n        }\n      } else if (_doc.contents) {\n        docsStack.push(_doc.contents);\n      }\n    }\n  }\n}\n\nfunction mapDoc(doc, cb) {\n  if (doc.type === \"concat\" || doc.type === \"fill\") {\n    var parts = doc.parts.map(function (part) {\n      return mapDoc(part, cb);\n    });\n    return cb(Object.assign({}, doc, {\n      parts: parts\n    }));\n  } else if (doc.type === \"if-break\") {\n    var breakContents = doc.breakContents && mapDoc(doc.breakContents, cb);\n    var flatContents = doc.flatContents && mapDoc(doc.flatContents, cb);\n    return cb(Object.assign({}, doc, {\n      breakContents: breakContents,\n      flatContents: flatContents\n    }));\n  } else if (doc.contents) {\n    var contents = mapDoc(doc.contents, cb);\n    return cb(Object.assign({}, doc, {\n      contents: contents\n    }));\n  }\n\n  return cb(doc);\n}\n\nfunction findInDoc(doc, fn, defaultValue) {\n  var result = defaultValue;\n  var hasStopped = false;\n\n  function findInDocOnEnterFn(doc) {\n    var maybeResult = fn(doc);\n\n    if (maybeResult !== undefined) {\n      hasStopped = true;\n      result = maybeResult;\n    }\n\n    if (hasStopped) {\n      return false;\n    }\n  }\n\n  traverseDoc(doc, findInDocOnEnterFn);\n  return result;\n}\n\nfunction isEmpty(n) {\n  return typeof n === \"string\" && n.length === 0;\n}\n\nfunction isLineNextFn(doc) {\n  if (typeof doc === \"string\") {\n    return false;\n  }\n\n  if (doc.type === \"line\") {\n    return true;\n  }\n}\n\nfunction isLineNext(doc) {\n  return findInDoc(doc, isLineNextFn, false);\n}\n\nfunction willBreakFn(doc) {\n  if (doc.type === \"group\" && doc[\"break\"]) {\n    return true;\n  }\n\n  if (doc.type === \"line\" && doc.hard) {\n    return true;\n  }\n\n  if (doc.type === \"break-parent\") {\n    return true;\n  }\n}\n\nfunction willBreak(doc) {\n  return findInDoc(doc, willBreakFn, false);\n}\n\nfunction breakParentGroup(groupStack) {\n  if (groupStack.length > 0) {\n    var parentGroup = groupStack[groupStack.length - 1]; // Breaks are not propagated through conditional groups because\n    // the user is expected to manually handle what breaks.\n\n    if (!parentGroup.expandedStates) {\n      parentGroup[\"break\"] = true;\n    }\n  }\n\n  return null;\n}\n\nfunction propagateBreaks(doc) {\n  var alreadyVisitedSet = new Set();\n  var groupStack = [];\n\n  function propagateBreaksOnEnterFn(doc) {\n    if (doc.type === \"break-parent\") {\n      breakParentGroup(groupStack);\n    }\n\n    if (doc.type === \"group\") {\n      groupStack.push(doc);\n\n      if (alreadyVisitedSet.has(doc)) {\n        return false;\n      }\n\n      alreadyVisitedSet.add(doc);\n    }\n  }\n\n  function propagateBreaksOnExitFn(doc) {\n    if (doc.type === \"group\") {\n      var group = groupStack.pop();\n\n      if (group[\"break\"]) {\n        breakParentGroup(groupStack);\n      }\n    }\n  }\n\n  traverseDoc(doc, propagateBreaksOnEnterFn, propagateBreaksOnExitFn,\n  /* shouldTraverseConditionalGroups */\n  true);\n}\n\nfunction removeLinesFn(doc) {\n  // Force this doc into flat mode by statically converting all\n  // lines into spaces (or soft lines into nothing). Hard lines\n  // should still output because there's too great of a chance\n  // of breaking existing assumptions otherwise.\n  if (doc.type === \"line\" && !doc.hard) {\n    return doc.soft ? \"\" : \" \";\n  } else if (doc.type === \"if-break\") {\n    return doc.flatContents || \"\";\n  }\n\n  return doc;\n}\n\nfunction removeLines(doc) {\n  return mapDoc(doc, removeLinesFn);\n}\n\nfunction stripTrailingHardline(doc) {\n  // HACK remove ending hardline, original PR: #1984\n  if (doc.type === \"concat\" && doc.parts.length !== 0) {\n    var lastPart = doc.parts[doc.parts.length - 1];\n\n    if (lastPart.type === \"concat\") {\n      if (lastPart.parts.length === 2 && lastPart.parts[0].hard && lastPart.parts[1].type === \"break-parent\") {\n        return {\n          type: \"concat\",\n          parts: doc.parts.slice(0, -1)\n        };\n      }\n\n      return {\n        type: \"concat\",\n        parts: doc.parts.slice(0, -1).concat(stripTrailingHardline(lastPart))\n      };\n    }\n  }\n\n  return doc;\n}\n\nmodule.exports = {\n  isEmpty: isEmpty,\n  willBreak: willBreak,\n  isLineNext: isLineNext,\n  traverseDoc: traverseDoc,\n  findInDoc: findInDoc,\n  mapDoc: mapDoc,\n  propagateBreaks: propagateBreaks,\n  removeLines: removeLines,\n  stripTrailingHardline: stripTrailingHardline\n};"]},"metadata":{},"sourceType":"script"}