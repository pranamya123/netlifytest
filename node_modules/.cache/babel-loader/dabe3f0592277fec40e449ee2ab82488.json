{"ast":null,"code":"\"use strict\"; // This file is currently named parser-babylon.js to maintain backwards compatibility.\n// However, it should be named parser-babel.js in the next major release.\n\nvar createError = require(\"../common/parser-create-error\");\n\nvar hasPragma = require(\"./pragma\").hasPragma;\n\nvar locFns = require(\"./loc\");\n\nvar postprocess = require(\"./postprocess\");\n\nvar babelParser = require(\"@babel/parser\");\n\nfunction babelOptions(extraOptions, extraPlugins) {\n  return Object.assign({\n    sourceType: \"module\",\n    allowAwaitOutsideFunction: true,\n    allowImportExportEverywhere: true,\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    plugins: [\"jsx\", \"doExpressions\", \"objectRestSpread\", \"classProperties\", \"exportDefaultFrom\", \"exportNamespaceFrom\", \"asyncGenerators\", \"functionBind\", \"functionSent\", \"dynamicImport\", \"numericSeparator\", \"importMeta\", \"optionalCatchBinding\", \"optionalChaining\", \"classPrivateProperties\", [\"pipelineOperator\", {\n      proposal: \"minimal\"\n    }], \"nullishCoalescingOperator\", \"bigInt\", \"throwExpressions\", \"logicalAssignment\", \"classPrivateMethods\"].concat(extraPlugins)\n  }, extraOptions);\n}\n\nfunction createParse(parseMethod, extraPlugins) {\n  return function (text, parsers, opts) {\n    // Inline the require to avoid loading all the JS if we don't use it\n    var combinations = [babelOptions({\n      strictMode: true\n    }, [\"decorators-legacy\"].concat(extraPlugins)), babelOptions({\n      strictMode: false\n    }, [\"decorators-legacy\"].concat(extraPlugins)), babelOptions({\n      strictMode: true\n    }, [[\"decorators\", {\n      decoratorsBeforeExport: false\n    }]].concat(extraPlugins)), babelOptions({\n      strictMode: false\n    }, [[\"decorators\", {\n      decoratorsBeforeExport: false\n    }]].concat(extraPlugins))];\n    var ast;\n\n    try {\n      ast = tryCombinations(babelParser[parseMethod].bind(null, text), combinations);\n    } catch (error) {\n      throw createError( // babel error prints (l:c) with cols that are zero indexed\n      // so we need our custom error\n      error.message.replace(/ \\(.*\\)/, \"\"), {\n        start: {\n          line: error.loc.line,\n          column: error.loc.column + 1\n        }\n      });\n    }\n\n    delete ast.tokens;\n    return postprocess(ast, Object.assign({}, opts, {\n      originalText: text\n    }));\n  };\n}\n\nvar parse = createParse(\"parse\", [\"flow\"]);\nvar parseFlow = createParse(\"parse\", [[\"flow\", {\n  all: true\n}]]);\nvar parseExpression = createParse(\"parseExpression\");\n\nfunction tryCombinations(fn, combinations) {\n  var error;\n\n  for (var i = 0; i < combinations.length; i++) {\n    try {\n      return fn(combinations[i]);\n    } catch (_error) {\n      if (!error) {\n        error = _error;\n      }\n    }\n  }\n\n  throw error;\n}\n\nfunction parseJson(text, parsers, opts) {\n  var ast = parseExpression(text, parsers, opts);\n  ast.comments.forEach(assertJsonNode);\n  assertJsonNode(ast);\n  return ast;\n}\n\nfunction assertJsonNode(node, parent) {\n  switch (node.type) {\n    case \"ArrayExpression\":\n      return node.elements.forEach(assertJsonChildNode);\n\n    case \"ObjectExpression\":\n      return node.properties.forEach(assertJsonChildNode);\n\n    case \"ObjectProperty\":\n      // istanbul ignore if\n      if (node.computed) {\n        throw createJsonError(\"computed\");\n      } // istanbul ignore if\n\n\n      if (node.shorthand) {\n        throw createJsonError(\"shorthand\");\n      }\n\n      return [node.key, node.value].forEach(assertJsonChildNode);\n\n    case \"UnaryExpression\":\n      switch (node.operator) {\n        case \"+\":\n        case \"-\":\n          return assertJsonChildNode(node.argument);\n        // istanbul ignore next\n\n        default:\n          throw createJsonError(\"operator\");\n      }\n\n    case \"Identifier\":\n      if (parent && parent.type === \"ObjectProperty\" && parent.key === node) {\n        return;\n      }\n\n      throw createJsonError();\n\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"NumericLiteral\":\n    case \"StringLiteral\":\n      return;\n    // istanbul ignore next\n\n    default:\n      throw createJsonError();\n  }\n\n  function assertJsonChildNode(child) {\n    return assertJsonNode(child, node);\n  } // istanbul ignore next\n\n\n  function createJsonError(attribute) {\n    var name = !attribute ? node.type : \"\".concat(node.type, \" with \").concat(attribute, \"=\").concat(JSON.stringify(node[attribute]));\n    return createError(\"\".concat(name, \" is not allowed in JSON.\"), {\n      start: {\n        line: node.loc.start.line,\n        column: node.loc.start.column + 1\n      }\n    });\n  }\n}\n\nvar babel = Object.assign({\n  parse: parse,\n  astFormat: \"estree\",\n  hasPragma: hasPragma\n}, locFns);\nvar babelFlow = Object.assign({}, babel, {\n  parse: parseFlow\n});\nvar babelExpression = Object.assign({}, babel, {\n  parse: parseExpression\n}); // Export as a plugin so we can reuse the same bundle for UMD loading\n\nmodule.exports = {\n  parsers: {\n    babel: babel,\n    \"babel-flow\": babelFlow,\n    // aliased to keep backwards compatibility\n    babylon: babel,\n    json: Object.assign({}, babelExpression, {\n      hasPragma: function hasPragma() {\n        return true;\n      }\n    }),\n    json5: babelExpression,\n    \"json-stringify\": Object.assign({\n      parse: parseJson,\n      astFormat: \"estree-json\"\n    }, locFns),\n\n    /** @internal */\n    __js_expression: babelExpression,\n\n    /** for vue filter */\n    __vue_expression: babelExpression,\n\n    /** for vue event binding to handle semicolon */\n    __vue_event_binding: babel\n  }\n};","map":{"version":3,"sources":["/Users/pranamyavadlamani/Desktop/Research/PortFolio/portfolio-site/node_modules/@miksu/prettier/lib/language-js/parser-babylon.js"],"names":["createError","require","hasPragma","locFns","postprocess","babelParser","babelOptions","extraOptions","extraPlugins","Object","assign","sourceType","allowAwaitOutsideFunction","allowImportExportEverywhere","allowReturnOutsideFunction","allowSuperOutsideMethod","plugins","proposal","concat","createParse","parseMethod","text","parsers","opts","combinations","strictMode","decoratorsBeforeExport","ast","tryCombinations","bind","error","message","replace","start","line","loc","column","tokens","originalText","parse","parseFlow","all","parseExpression","fn","i","length","_error","parseJson","comments","forEach","assertJsonNode","node","parent","type","elements","assertJsonChildNode","properties","computed","createJsonError","shorthand","key","value","operator","argument","child","attribute","name","JSON","stringify","babel","astFormat","babelFlow","babelExpression","module","exports","babylon","json","json5","__js_expression","__vue_expression","__vue_event_binding"],"mappings":"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","sourcesContent":["\"use strict\"; // This file is currently named parser-babylon.js to maintain backwards compatibility.\n// However, it should be named parser-babel.js in the next major release.\n\nvar createError = require(\"../common/parser-create-error\");\n\nvar hasPragma = require(\"./pragma\").hasPragma;\n\nvar locFns = require(\"./loc\");\n\nvar postprocess = require(\"./postprocess\");\n\nvar babelParser = require(\"@babel/parser\");\n\nfunction babelOptions(extraOptions, extraPlugins) {\n  return Object.assign({\n    sourceType: \"module\",\n    allowAwaitOutsideFunction: true,\n    allowImportExportEverywhere: true,\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    plugins: [\"jsx\", \"doExpressions\", \"objectRestSpread\", \"classProperties\", \"exportDefaultFrom\", \"exportNamespaceFrom\", \"asyncGenerators\", \"functionBind\", \"functionSent\", \"dynamicImport\", \"numericSeparator\", \"importMeta\", \"optionalCatchBinding\", \"optionalChaining\", \"classPrivateProperties\", [\"pipelineOperator\", {\n      proposal: \"minimal\"\n    }], \"nullishCoalescingOperator\", \"bigInt\", \"throwExpressions\", \"logicalAssignment\", \"classPrivateMethods\"].concat(extraPlugins)\n  }, extraOptions);\n}\n\nfunction createParse(parseMethod, extraPlugins) {\n  return function (text, parsers, opts) {\n    // Inline the require to avoid loading all the JS if we don't use it\n    var combinations = [babelOptions({\n      strictMode: true\n    }, [\"decorators-legacy\"].concat(extraPlugins)), babelOptions({\n      strictMode: false\n    }, [\"decorators-legacy\"].concat(extraPlugins)), babelOptions({\n      strictMode: true\n    }, [[\"decorators\", {\n      decoratorsBeforeExport: false\n    }]].concat(extraPlugins)), babelOptions({\n      strictMode: false\n    }, [[\"decorators\", {\n      decoratorsBeforeExport: false\n    }]].concat(extraPlugins))];\n    var ast;\n\n    try {\n      ast = tryCombinations(babelParser[parseMethod].bind(null, text), combinations);\n    } catch (error) {\n      throw createError( // babel error prints (l:c) with cols that are zero indexed\n      // so we need our custom error\n      error.message.replace(/ \\(.*\\)/, \"\"), {\n        start: {\n          line: error.loc.line,\n          column: error.loc.column + 1\n        }\n      });\n    }\n\n    delete ast.tokens;\n    return postprocess(ast, Object.assign({}, opts, {\n      originalText: text\n    }));\n  };\n}\n\nvar parse = createParse(\"parse\", [\"flow\"]);\nvar parseFlow = createParse(\"parse\", [[\"flow\", {\n  all: true\n}]]);\nvar parseExpression = createParse(\"parseExpression\");\n\nfunction tryCombinations(fn, combinations) {\n  var error;\n\n  for (var i = 0; i < combinations.length; i++) {\n    try {\n      return fn(combinations[i]);\n    } catch (_error) {\n      if (!error) {\n        error = _error;\n      }\n    }\n  }\n\n  throw error;\n}\n\nfunction parseJson(text, parsers, opts) {\n  var ast = parseExpression(text, parsers, opts);\n  ast.comments.forEach(assertJsonNode);\n  assertJsonNode(ast);\n  return ast;\n}\n\nfunction assertJsonNode(node, parent) {\n  switch (node.type) {\n    case \"ArrayExpression\":\n      return node.elements.forEach(assertJsonChildNode);\n\n    case \"ObjectExpression\":\n      return node.properties.forEach(assertJsonChildNode);\n\n    case \"ObjectProperty\":\n      // istanbul ignore if\n      if (node.computed) {\n        throw createJsonError(\"computed\");\n      } // istanbul ignore if\n\n\n      if (node.shorthand) {\n        throw createJsonError(\"shorthand\");\n      }\n\n      return [node.key, node.value].forEach(assertJsonChildNode);\n\n    case \"UnaryExpression\":\n      switch (node.operator) {\n        case \"+\":\n        case \"-\":\n          return assertJsonChildNode(node.argument);\n        // istanbul ignore next\n\n        default:\n          throw createJsonError(\"operator\");\n      }\n\n    case \"Identifier\":\n      if (parent && parent.type === \"ObjectProperty\" && parent.key === node) {\n        return;\n      }\n\n      throw createJsonError();\n\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"NumericLiteral\":\n    case \"StringLiteral\":\n      return;\n    // istanbul ignore next\n\n    default:\n      throw createJsonError();\n  }\n\n  function assertJsonChildNode(child) {\n    return assertJsonNode(child, node);\n  } // istanbul ignore next\n\n\n  function createJsonError(attribute) {\n    var name = !attribute ? node.type : \"\".concat(node.type, \" with \").concat(attribute, \"=\").concat(JSON.stringify(node[attribute]));\n    return createError(\"\".concat(name, \" is not allowed in JSON.\"), {\n      start: {\n        line: node.loc.start.line,\n        column: node.loc.start.column + 1\n      }\n    });\n  }\n}\n\nvar babel = Object.assign({\n  parse: parse,\n  astFormat: \"estree\",\n  hasPragma: hasPragma\n}, locFns);\nvar babelFlow = Object.assign({}, babel, {\n  parse: parseFlow\n});\nvar babelExpression = Object.assign({}, babel, {\n  parse: parseExpression\n}); // Export as a plugin so we can reuse the same bundle for UMD loading\n\nmodule.exports = {\n  parsers: {\n    babel: babel,\n    \"babel-flow\": babelFlow,\n    // aliased to keep backwards compatibility\n    babylon: babel,\n    json: Object.assign({}, babelExpression, {\n      hasPragma: function hasPragma() {\n        return true;\n      }\n    }),\n    json5: babelExpression,\n    \"json-stringify\": Object.assign({\n      parse: parseJson,\n      astFormat: \"estree-json\"\n    }, locFns),\n\n    /** @internal */\n    __js_expression: babelExpression,\n\n    /** for vue filter */\n    __vue_expression: babelExpression,\n\n    /** for vue event binding to handle semicolon */\n    __vue_event_binding: babel\n  }\n};"]},"metadata":{},"sourceType":"script"}