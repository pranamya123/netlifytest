{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxJsx = _interopRequireDefault(require(\"@babel/plugin-syntax-jsx\"));\n\nvar _helperBuilderReactJsx = _interopRequireDefault(require(\"@babel/helper-builder-react-jsx\"));\n\nvar _core = require(\"@babel/core\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst DEFAULT = {\n  pragma: \"React.createElement\",\n  pragmaFrag: \"React.Fragment\"\n};\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  const THROW_IF_NAMESPACE = options.throwIfNamespace === undefined ? true : !!options.throwIfNamespace;\n  const PRAGMA_DEFAULT = options.pragma || DEFAULT.pragma;\n  const PRAGMA_FRAG_DEFAULT = options.pragmaFrag || DEFAULT.pragmaFrag;\n  const PURE_ANNOTATION = options.pure;\n  const JSX_ANNOTATION_REGEX = /\\*?\\s*@jsx\\s+([^\\s]+)/;\n  const JSX_FRAG_ANNOTATION_REGEX = /\\*?\\s*@jsxFrag\\s+([^\\s]+)/;\n\n  const createIdentifierParser = id => () => {\n    return id.split(\".\").map(name => _core.types.identifier(name)).reduce((object, property) => _core.types.memberExpression(object, property));\n  };\n\n  const visitor = (0, _helperBuilderReactJsx.default)({\n    pre(state) {\n      const tagName = state.tagName;\n      const args = state.args;\n\n      if (_core.types.react.isCompatTag(tagName)) {\n        args.push(_core.types.stringLiteral(tagName));\n      } else {\n        args.push(state.tagExpr);\n      }\n    },\n\n    post(state, pass) {\n      state.callee = pass.get(\"jsxIdentifier\")();\n      state.pure = PURE_ANNOTATION != null ? PURE_ANNOTATION : pass.get(\"pragma\") === DEFAULT.pragma;\n    },\n\n    throwIfNamespace: THROW_IF_NAMESPACE\n  });\n  visitor.Program = {\n    enter(path, state) {\n      const {\n        file\n      } = state;\n      let pragma = PRAGMA_DEFAULT;\n      let pragmaFrag = PRAGMA_FRAG_DEFAULT;\n      let pragmaSet = !!options.pragma;\n      let pragmaFragSet = !!options.pragma;\n\n      if (file.ast.comments) {\n        for (const comment of file.ast.comments) {\n          const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n\n          if (jsxMatches) {\n            pragma = jsxMatches[1];\n            pragmaSet = true;\n          }\n\n          const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);\n\n          if (jsxFragMatches) {\n            pragmaFrag = jsxFragMatches[1];\n            pragmaFragSet = true;\n          }\n        }\n      }\n\n      state.set(\"jsxIdentifier\", createIdentifierParser(pragma));\n      state.set(\"jsxFragIdentifier\", createIdentifierParser(pragmaFrag));\n      state.set(\"usedFragment\", false);\n      state.set(\"pragma\", pragma);\n      state.set(\"pragmaSet\", pragmaSet);\n      state.set(\"pragmaFragSet\", pragmaFragSet);\n    },\n\n    exit(path, state) {\n      if (state.get(\"pragmaSet\") && state.get(\"usedFragment\") && !state.get(\"pragmaFragSet\")) {\n        throw new Error(\"transform-react-jsx: pragma has been set but \" + \"pragmaFrag has not been set\");\n      }\n    }\n\n  };\n\n  visitor.JSXAttribute = function (path) {\n    if (_core.types.isJSXElement(path.node.value)) {\n      path.node.value = _core.types.jsxExpressionContainer(path.node.value);\n    }\n  };\n\n  return {\n    name: \"transform-react-jsx\",\n    inherits: _pluginSyntaxJsx.default,\n    visitor\n  };\n});\n\nexports.default = _default;","map":{"version":3,"sources":["/Users/pranamyavadlamani/Desktop/Research/PortFolio/portfolio-site/node_modules/@babel/plugin-transform-react-jsx/lib/transform-classic.js"],"names":["Object","defineProperty","exports","value","default","_helperPluginUtils","require","_pluginSyntaxJsx","_interopRequireDefault","_helperBuilderReactJsx","_core","obj","__esModule","DEFAULT","pragma","pragmaFrag","_default","declare","api","options","THROW_IF_NAMESPACE","throwIfNamespace","undefined","PRAGMA_DEFAULT","PRAGMA_FRAG_DEFAULT","PURE_ANNOTATION","pure","JSX_ANNOTATION_REGEX","JSX_FRAG_ANNOTATION_REGEX","createIdentifierParser","id","split","map","name","types","identifier","reduce","object","property","memberExpression","visitor","pre","state","tagName","args","react","isCompatTag","push","stringLiteral","tagExpr","post","pass","callee","get","Program","enter","path","file","pragmaSet","pragmaFragSet","ast","comments","comment","jsxMatches","exec","jsxFragMatches","set","exit","Error","JSXAttribute","isJSXElement","node","jsxExpressionContainer","inherits"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxJsx = _interopRequireDefault(require(\"@babel/plugin-syntax-jsx\"));\n\nvar _helperBuilderReactJsx = _interopRequireDefault(require(\"@babel/helper-builder-react-jsx\"));\n\nvar _core = require(\"@babel/core\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst DEFAULT = {\n  pragma: \"React.createElement\",\n  pragmaFrag: \"React.Fragment\"\n};\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  const THROW_IF_NAMESPACE = options.throwIfNamespace === undefined ? true : !!options.throwIfNamespace;\n  const PRAGMA_DEFAULT = options.pragma || DEFAULT.pragma;\n  const PRAGMA_FRAG_DEFAULT = options.pragmaFrag || DEFAULT.pragmaFrag;\n  const PURE_ANNOTATION = options.pure;\n  const JSX_ANNOTATION_REGEX = /\\*?\\s*@jsx\\s+([^\\s]+)/;\n  const JSX_FRAG_ANNOTATION_REGEX = /\\*?\\s*@jsxFrag\\s+([^\\s]+)/;\n\n  const createIdentifierParser = id => () => {\n    return id.split(\".\").map(name => _core.types.identifier(name)).reduce((object, property) => _core.types.memberExpression(object, property));\n  };\n\n  const visitor = (0, _helperBuilderReactJsx.default)({\n    pre(state) {\n      const tagName = state.tagName;\n      const args = state.args;\n\n      if (_core.types.react.isCompatTag(tagName)) {\n        args.push(_core.types.stringLiteral(tagName));\n      } else {\n        args.push(state.tagExpr);\n      }\n    },\n\n    post(state, pass) {\n      state.callee = pass.get(\"jsxIdentifier\")();\n      state.pure = PURE_ANNOTATION != null ? PURE_ANNOTATION : pass.get(\"pragma\") === DEFAULT.pragma;\n    },\n\n    throwIfNamespace: THROW_IF_NAMESPACE\n  });\n  visitor.Program = {\n    enter(path, state) {\n      const {\n        file\n      } = state;\n      let pragma = PRAGMA_DEFAULT;\n      let pragmaFrag = PRAGMA_FRAG_DEFAULT;\n      let pragmaSet = !!options.pragma;\n      let pragmaFragSet = !!options.pragma;\n\n      if (file.ast.comments) {\n        for (const comment of file.ast.comments) {\n          const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n\n          if (jsxMatches) {\n            pragma = jsxMatches[1];\n            pragmaSet = true;\n          }\n\n          const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);\n\n          if (jsxFragMatches) {\n            pragmaFrag = jsxFragMatches[1];\n            pragmaFragSet = true;\n          }\n        }\n      }\n\n      state.set(\"jsxIdentifier\", createIdentifierParser(pragma));\n      state.set(\"jsxFragIdentifier\", createIdentifierParser(pragmaFrag));\n      state.set(\"usedFragment\", false);\n      state.set(\"pragma\", pragma);\n      state.set(\"pragmaSet\", pragmaSet);\n      state.set(\"pragmaFragSet\", pragmaFragSet);\n    },\n\n    exit(path, state) {\n      if (state.get(\"pragmaSet\") && state.get(\"usedFragment\") && !state.get(\"pragmaFragSet\")) {\n        throw new Error(\"transform-react-jsx: pragma has been set but \" + \"pragmaFrag has not been set\");\n      }\n    }\n\n  };\n\n  visitor.JSXAttribute = function (path) {\n    if (_core.types.isJSXElement(path.node.value)) {\n      path.node.value = _core.types.jsxExpressionContainer(path.node.value);\n    }\n  };\n\n  return {\n    name: \"transform-react-jsx\",\n    inherits: _pluginSyntaxJsx.default,\n    visitor\n  };\n});\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}