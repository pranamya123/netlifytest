{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar assert = require(\"assert\");\n\nvar comments = require(\"./comments\");\n\nvar FastPath = require(\"../common/fast-path\");\n\nvar multiparser = require(\"./multiparser\");\n\nvar doc = require(\"../doc\");\n\nvar docBuilders = doc.builders;\nvar concat = docBuilders.concat;\nvar hardline = docBuilders.hardline;\nvar addAlignmentToDoc = docBuilders.addAlignmentToDoc;\nvar docUtils = doc.utils;\n/**\n * Takes an abstract syntax tree (AST) and recursively converts it to a\n * document (series of printing primitives).\n *\n * This is done by descending down the AST recursively. The recursion\n * involves two functions that call each other:\n *\n * 1. printGenerically(), which is defined as an inner function here.\n *    It basically takes care of node caching.\n * 2. callPluginPrintFunction(), which checks for some options, and\n *    ultimately calls the print() function provided by the plugin.\n *\n * The plugin function will call printGenerically() again for child nodes\n * of the current node, which will do its housekeeping, then call the\n * plugin function again, and so on.\n *\n * All the while, these functions pass a \"path\" variable around, which\n * is a stack-like data structure (FastPath) that maintains the current\n * state of the recursion. It is called \"path\", because it represents\n * the path to the current node through the Abstract Syntax Tree.\n */\n\nfunction printAstToDoc(ast, options) {\n  var alignmentSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var printer = options.printer;\n\n  if (printer.preprocess) {\n    ast = printer.preprocess(ast, options);\n  }\n\n  var cache = new Map();\n\n  function printGenerically(path, args) {\n    var node = path.getValue();\n    var shouldCache = node && _typeof(node) === \"object\" && args === undefined;\n\n    if (shouldCache && cache.has(node)) {\n      return cache.get(node);\n    } // We let JSXElement print its comments itself because it adds () around\n    // UnionTypeAnnotation has to align the child without the comments\n\n\n    var res;\n\n    if (printer.willPrintOwnComments && printer.willPrintOwnComments(path, options)) {\n      res = callPluginPrintFunction(path, options, printGenerically, args);\n    } else {\n      // printComments will call the plugin print function and check for\n      // comments to print\n      res = comments.printComments(path, function (p) {\n        return callPluginPrintFunction(p, options, printGenerically, args);\n      }, options, args && args.needsSemi);\n    }\n\n    if (shouldCache) {\n      cache.set(node, res);\n    }\n\n    return res;\n  }\n\n  var doc = printGenerically(new FastPath(ast));\n\n  if (alignmentSize > 0) {\n    // Add a hardline to make the indents take effect\n    // It should be removed in index.js format()\n    doc = addAlignmentToDoc(concat([hardline, doc]), alignmentSize, options.tabWidth);\n  }\n\n  docUtils.propagateBreaks(doc);\n  return doc;\n}\n\nfunction callPluginPrintFunction(path, options, printPath, args) {\n  assert.ok(path instanceof FastPath);\n  var node = path.getValue();\n  var printer = options.printer; // Escape hatch\n\n  if (printer.hasPrettierIgnore && printer.hasPrettierIgnore(path)) {\n    return options.originalText.slice(options.locStart(node), options.locEnd(node));\n  }\n\n  if (node) {\n    try {\n      // Potentially switch to a different parser\n      var sub = multiparser.printSubtree(path, printPath, options, printAstToDoc);\n\n      if (sub) {\n        return sub;\n      }\n    } catch (error) {\n      /* istanbul ignore if */\n      if (process.env.PRETTIER_DEBUG) {\n        throw error;\n      } // Continue with current parser\n\n    }\n  }\n\n  return printer.print(path, options, printPath, args);\n}\n\nmodule.exports = printAstToDoc;","map":{"version":3,"sources":["/Users/pranamyavadlamani/Desktop/Research/PortFolio/portfolio-site/node_modules/@miksu/prettier/lib/main/ast-to-doc.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","assert","require","comments","FastPath","multiparser","doc","docBuilders","builders","concat","hardline","addAlignmentToDoc","docUtils","utils","printAstToDoc","ast","options","alignmentSize","arguments","length","undefined","printer","preprocess","cache","Map","printGenerically","path","args","node","getValue","shouldCache","has","get","res","willPrintOwnComments","callPluginPrintFunction","printComments","p","needsSemi","set","tabWidth","propagateBreaks","printPath","ok","hasPrettierIgnore","originalText","slice","locStart","locEnd","sub","printSubtree","error","process","env","PRETTIER_DEBUG","print","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar assert = require(\"assert\");\n\nvar comments = require(\"./comments\");\n\nvar FastPath = require(\"../common/fast-path\");\n\nvar multiparser = require(\"./multiparser\");\n\nvar doc = require(\"../doc\");\n\nvar docBuilders = doc.builders;\nvar concat = docBuilders.concat;\nvar hardline = docBuilders.hardline;\nvar addAlignmentToDoc = docBuilders.addAlignmentToDoc;\nvar docUtils = doc.utils;\n/**\n * Takes an abstract syntax tree (AST) and recursively converts it to a\n * document (series of printing primitives).\n *\n * This is done by descending down the AST recursively. The recursion\n * involves two functions that call each other:\n *\n * 1. printGenerically(), which is defined as an inner function here.\n *    It basically takes care of node caching.\n * 2. callPluginPrintFunction(), which checks for some options, and\n *    ultimately calls the print() function provided by the plugin.\n *\n * The plugin function will call printGenerically() again for child nodes\n * of the current node, which will do its housekeeping, then call the\n * plugin function again, and so on.\n *\n * All the while, these functions pass a \"path\" variable around, which\n * is a stack-like data structure (FastPath) that maintains the current\n * state of the recursion. It is called \"path\", because it represents\n * the path to the current node through the Abstract Syntax Tree.\n */\n\nfunction printAstToDoc(ast, options) {\n  var alignmentSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var printer = options.printer;\n\n  if (printer.preprocess) {\n    ast = printer.preprocess(ast, options);\n  }\n\n  var cache = new Map();\n\n  function printGenerically(path, args) {\n    var node = path.getValue();\n    var shouldCache = node && _typeof(node) === \"object\" && args === undefined;\n\n    if (shouldCache && cache.has(node)) {\n      return cache.get(node);\n    } // We let JSXElement print its comments itself because it adds () around\n    // UnionTypeAnnotation has to align the child without the comments\n\n\n    var res;\n\n    if (printer.willPrintOwnComments && printer.willPrintOwnComments(path, options)) {\n      res = callPluginPrintFunction(path, options, printGenerically, args);\n    } else {\n      // printComments will call the plugin print function and check for\n      // comments to print\n      res = comments.printComments(path, function (p) {\n        return callPluginPrintFunction(p, options, printGenerically, args);\n      }, options, args && args.needsSemi);\n    }\n\n    if (shouldCache) {\n      cache.set(node, res);\n    }\n\n    return res;\n  }\n\n  var doc = printGenerically(new FastPath(ast));\n\n  if (alignmentSize > 0) {\n    // Add a hardline to make the indents take effect\n    // It should be removed in index.js format()\n    doc = addAlignmentToDoc(concat([hardline, doc]), alignmentSize, options.tabWidth);\n  }\n\n  docUtils.propagateBreaks(doc);\n  return doc;\n}\n\nfunction callPluginPrintFunction(path, options, printPath, args) {\n  assert.ok(path instanceof FastPath);\n  var node = path.getValue();\n  var printer = options.printer; // Escape hatch\n\n  if (printer.hasPrettierIgnore && printer.hasPrettierIgnore(path)) {\n    return options.originalText.slice(options.locStart(node), options.locEnd(node));\n  }\n\n  if (node) {\n    try {\n      // Potentially switch to a different parser\n      var sub = multiparser.printSubtree(path, printPath, options, printAstToDoc);\n\n      if (sub) {\n        return sub;\n      }\n    } catch (error) {\n      /* istanbul ignore if */\n      if (process.env.PRETTIER_DEBUG) {\n        throw error;\n      } // Continue with current parser\n\n    }\n  }\n\n  return printer.print(path, options, printPath, args);\n}\n\nmodule.exports = printAstToDoc;"]},"metadata":{},"sourceType":"script"}