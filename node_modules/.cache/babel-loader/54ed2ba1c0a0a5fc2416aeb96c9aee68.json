{"ast":null,"code":"\"use strict\";\n\nvar privateUtil = require(\"../common/util\");\n\nvar sharedUtil = require(\"../common/util-shared\");\n\nvar addLeadingComment = sharedUtil.addLeadingComment,\n    addTrailingComment = sharedUtil.addTrailingComment,\n    addDanglingComment = sharedUtil.addDanglingComment;\n\nfunction handleOwnLineComment(comment, text, options, ast, isLastComment) {\n  var precedingNode = comment.precedingNode,\n      enclosingNode = comment.enclosingNode,\n      followingNode = comment.followingNode;\n\n  if (handleLastFunctionArgComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleMemberExpressionComments(enclosingNode, followingNode, comment) || handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleTryStatementComments(enclosingNode, precedingNode, followingNode, comment) || handleClassComments(enclosingNode, precedingNode, followingNode, comment) || handleImportSpecifierComments(enclosingNode, comment) || handleForComments(enclosingNode, precedingNode, comment) || handleUnionTypeComments(precedingNode, enclosingNode, followingNode, comment) || handleOnlyComments(enclosingNode, ast, comment, isLastComment) || handleImportDeclarationComments(text, enclosingNode, precedingNode, comment, options) || handleAssignmentPatternComments(enclosingNode, comment) || handleMethodNameComments(text, enclosingNode, precedingNode, comment, options)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleEndOfLineComment(comment, text, options, ast, isLastComment) {\n  var precedingNode = comment.precedingNode,\n      enclosingNode = comment.enclosingNode,\n      followingNode = comment.followingNode;\n\n  if (handleLastFunctionArgComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleConditionalExpressionComments(enclosingNode, precedingNode, followingNode, comment, text, options) || handleImportSpecifierComments(enclosingNode, comment) || handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleTryStatementComments(enclosingNode, precedingNode, followingNode, comment) || handleClassComments(enclosingNode, precedingNode, followingNode, comment) || handleLabeledStatementComments(enclosingNode, comment) || handleCallExpressionComments(precedingNode, enclosingNode, comment) || handlePropertyComments(enclosingNode, comment) || handleOnlyComments(enclosingNode, ast, comment, isLastComment) || handleTypeAliasComments(enclosingNode, followingNode, comment) || handleVariableDeclaratorComments(enclosingNode, followingNode, comment)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleRemainingComment(comment, text, options, ast, isLastComment) {\n  var precedingNode = comment.precedingNode,\n      enclosingNode = comment.enclosingNode,\n      followingNode = comment.followingNode;\n\n  if (handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleObjectPropertyAssignment(enclosingNode, precedingNode, comment) || handleCommentInEmptyParens(text, enclosingNode, comment, options) || handleMethodNameComments(text, enclosingNode, precedingNode, comment, options) || handleOnlyComments(enclosingNode, ast, comment, isLastComment) || handleCommentAfterArrowParams(text, enclosingNode, comment, options) || handleFunctionNameComments(text, enclosingNode, precedingNode, comment, options) || handleTSMappedTypeComments(text, enclosingNode, precedingNode, followingNode, comment) || handleBreakAndContinueStatementComments(enclosingNode, comment)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction addBlockStatementFirstComment(node, comment) {\n  var body = node.body.filter(function (n) {\n    return n.type !== \"EmptyStatement\";\n  });\n\n  if (body.length === 0) {\n    addDanglingComment(node, comment);\n  } else {\n    addLeadingComment(body[0], comment);\n  }\n}\n\nfunction addBlockOrNotComment(node, comment) {\n  if (node.type === \"BlockStatement\") {\n    addBlockStatementFirstComment(node, comment);\n  } else {\n    addLeadingComment(node, comment);\n  }\n} // There are often comments before the else clause of if statements like\n//\n//   if (1) { ... }\n//   // comment\n//   else { ... }\n//\n// They are being attached as leading comments of the BlockExpression which\n// is not well printed. What we want is to instead move the comment inside\n// of the block and make it leadingComment of the first element of the block\n// or dangling comment of the block if there is nothing inside\n//\n//   if (1) { ... }\n//   else {\n//     // comment\n//     ...\n//   }\n\n\nfunction handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) {\n  if (!enclosingNode || enclosingNode.type !== \"IfStatement\" || !followingNode) {\n    return false;\n  } // We unfortunately have no way using the AST or location of nodes to know\n  // if the comment is positioned before the condition parenthesis:\n  //   if (a /* comment */) {}\n  // The only workaround I found is to look at the next character to see if\n  // it is a ).\n\n\n  var nextCharacter = privateUtil.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd);\n\n  if (nextCharacter === \")\") {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  } // Comments before `else`:\n  // - treat as trailing comments of the consequent, if it's a BlockStatement\n  // - treat as a dangling comment otherwise\n\n\n  if (precedingNode === enclosingNode.consequent && followingNode === enclosingNode.alternate) {\n    if (precedingNode.type === \"BlockStatement\") {\n      addTrailingComment(precedingNode, comment);\n    } else {\n      addDanglingComment(enclosingNode, comment);\n    }\n\n    return true;\n  }\n\n  if (followingNode.type === \"BlockStatement\") {\n    addBlockStatementFirstComment(followingNode, comment);\n    return true;\n  }\n\n  if (followingNode.type === \"IfStatement\") {\n    addBlockOrNotComment(followingNode.consequent, comment);\n    return true;\n  } // For comments positioned after the condition parenthesis in an if statement\n  // before the consequent without brackets on, such as\n  // if (a) /* comment */ true,\n  // we look at the next character to see if the following node\n  // is the consequent for the if statement\n\n\n  if (enclosingNode.consequent === followingNode) {\n    addLeadingComment(followingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) {\n  if (!enclosingNode || enclosingNode.type !== \"WhileStatement\" || !followingNode) {\n    return false;\n  } // We unfortunately have no way using the AST or location of nodes to know\n  // if the comment is positioned before the condition parenthesis:\n  //   while (a /* comment */) {}\n  // The only workaround I found is to look at the next character to see if\n  // it is a ).\n\n\n  var nextCharacter = privateUtil.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd);\n\n  if (nextCharacter === \")\") {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  if (followingNode.type === \"BlockStatement\") {\n    addBlockStatementFirstComment(followingNode, comment);\n    return true;\n  }\n\n  return false;\n} // Same as IfStatement but for TryStatement\n\n\nfunction handleTryStatementComments(enclosingNode, precedingNode, followingNode, comment) {\n  if (!enclosingNode || enclosingNode.type !== \"TryStatement\" && enclosingNode.type !== \"CatchClause\" || !followingNode) {\n    return false;\n  }\n\n  if (enclosingNode.type === \"CatchClause\" && precedingNode) {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  if (followingNode.type === \"BlockStatement\") {\n    addBlockStatementFirstComment(followingNode, comment);\n    return true;\n  }\n\n  if (followingNode.type === \"TryStatement\") {\n    addBlockOrNotComment(followingNode.finalizer, comment);\n    return true;\n  }\n\n  if (followingNode.type === \"CatchClause\") {\n    addBlockOrNotComment(followingNode.body, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleMemberExpressionComments(enclosingNode, followingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"MemberExpression\" && followingNode && followingNode.type === \"Identifier\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleConditionalExpressionComments(enclosingNode, precedingNode, followingNode, comment, text, options) {\n  var isSameLineAsPrecedingNode = precedingNode && !privateUtil.hasNewlineInRange(text, options.locEnd(precedingNode), options.locStart(comment));\n\n  if ((!precedingNode || !isSameLineAsPrecedingNode) && enclosingNode && enclosingNode.type === \"ConditionalExpression\" && followingNode) {\n    addLeadingComment(followingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleObjectPropertyAssignment(enclosingNode, precedingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"ObjectProperty\" || enclosingNode.type === \"Property\") && enclosingNode.shorthand && enclosingNode.key === precedingNode && enclosingNode.value.type === \"AssignmentPattern\") {\n    addTrailingComment(enclosingNode.value.left, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleClassComments(enclosingNode, precedingNode, followingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"ClassDeclaration\" || enclosingNode.type === \"ClassExpression\") && enclosingNode.decorators && enclosingNode.decorators.length > 0 && !(followingNode && followingNode.type === \"Decorator\")) {\n    if (!enclosingNode.decorators || enclosingNode.decorators.length === 0) {\n      addLeadingComment(enclosingNode, comment);\n    } else {\n      addTrailingComment(enclosingNode.decorators[enclosingNode.decorators.length - 1], comment);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleMethodNameComments(text, enclosingNode, precedingNode, comment, options) {\n  // This is only needed for estree parsers (flow, typescript) to attach\n  // after a method name:\n  // obj = { fn /*comment*/() {} };\n  if (enclosingNode && precedingNode && (enclosingNode.type === \"Property\" || enclosingNode.type === \"MethodDefinition\") && precedingNode.type === \"Identifier\" && enclosingNode.key === precedingNode && // special Property case: { key: /*comment*/(value) };\n  // comment should be attached to value instead of key\n  privateUtil.getNextNonSpaceNonCommentCharacter(text, precedingNode, options.locEnd) !== \":\") {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  } // Print comments between decorators and class methods as a trailing comment\n  // on the decorator node instead of the method node\n\n\n  if (precedingNode && enclosingNode && precedingNode.type === \"Decorator\" && (enclosingNode.type === \"ClassMethod\" || enclosingNode.type === \"ClassProperty\" || enclosingNode.type === \"TSAbstractClassProperty\" || enclosingNode.type === \"TSAbstractMethodDefinition\" || enclosingNode.type === \"MethodDefinition\")) {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleFunctionNameComments(text, enclosingNode, precedingNode, comment, options) {\n  if (privateUtil.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd) !== \"(\") {\n    return false;\n  }\n\n  if (precedingNode && enclosingNode && (enclosingNode.type === \"FunctionDeclaration\" || enclosingNode.type === \"FunctionExpression\" || enclosingNode.type === \"ClassMethod\" || enclosingNode.type === \"MethodDefinition\" || enclosingNode.type === \"ObjectMethod\")) {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleCommentAfterArrowParams(text, enclosingNode, comment, options) {\n  if (!(enclosingNode && enclosingNode.type === \"ArrowFunctionExpression\")) {\n    return false;\n  }\n\n  var index = sharedUtil.getNextNonSpaceNonCommentCharacterIndex(text, comment, options);\n\n  if (text.substr(index, 2) === \"=>\") {\n    addDanglingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleCommentInEmptyParens(text, enclosingNode, comment, options) {\n  if (privateUtil.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd) !== \")\") {\n    return false;\n  } // Only add dangling comments to fix the case when no params are present,\n  // i.e. a function without any argument.\n\n\n  if (enclosingNode && ((enclosingNode.type === \"FunctionDeclaration\" || enclosingNode.type === \"FunctionExpression\" || enclosingNode.type === \"ArrowFunctionExpression\" || enclosingNode.type === \"ClassMethod\" || enclosingNode.type === \"ObjectMethod\") && enclosingNode.params.length === 0 || (enclosingNode.type === \"CallExpression\" || enclosingNode.type === \"NewExpression\") && enclosingNode.arguments.length === 0)) {\n    addDanglingComment(enclosingNode, comment);\n    return true;\n  }\n\n  if (enclosingNode && enclosingNode.type === \"MethodDefinition\" && enclosingNode.value.params.length === 0) {\n    addDanglingComment(enclosingNode.value, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleLastFunctionArgComments(text, precedingNode, enclosingNode, followingNode, comment, options) {\n  // Type definitions functions\n  if (precedingNode && precedingNode.type === \"FunctionTypeParam\" && enclosingNode && enclosingNode.type === \"FunctionTypeAnnotation\" && followingNode && followingNode.type !== \"FunctionTypeParam\") {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  } // Real functions\n\n\n  if (precedingNode && (precedingNode.type === \"Identifier\" || precedingNode.type === \"AssignmentPattern\") && enclosingNode && (enclosingNode.type === \"ArrowFunctionExpression\" || enclosingNode.type === \"FunctionExpression\" || enclosingNode.type === \"FunctionDeclaration\" || enclosingNode.type === \"ObjectMethod\" || enclosingNode.type === \"ClassMethod\") && privateUtil.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd) === \")\") {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  if (enclosingNode && enclosingNode.type === \"FunctionDeclaration\" && followingNode && followingNode.type === \"BlockStatement\") {\n    var functionParamRightParenIndex = function () {\n      if (enclosingNode.params.length !== 0) {\n        return privateUtil.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, options.locEnd(privateUtil.getLast(enclosingNode.params)));\n      }\n\n      var functionParamLeftParenIndex = privateUtil.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, options.locEnd(enclosingNode.id));\n      return privateUtil.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, functionParamLeftParenIndex + 1);\n    }();\n\n    if (options.locStart(comment) > functionParamRightParenIndex) {\n      addBlockStatementFirstComment(followingNode, comment);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction handleImportSpecifierComments(enclosingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"ImportSpecifier\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleLabeledStatementComments(enclosingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"LabeledStatement\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleBreakAndContinueStatementComments(enclosingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"ContinueStatement\" || enclosingNode.type === \"BreakStatement\") && !enclosingNode.label) {\n    addTrailingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleCallExpressionComments(precedingNode, enclosingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"CallExpression\" && precedingNode && enclosingNode.callee === precedingNode && enclosingNode.arguments.length > 0) {\n    addLeadingComment(enclosingNode.arguments[0], comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleUnionTypeComments(precedingNode, enclosingNode, followingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"UnionTypeAnnotation\" || enclosingNode.type === \"TSUnionType\")) {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handlePropertyComments(enclosingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"Property\" || enclosingNode.type === \"ObjectProperty\")) {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleOnlyComments(enclosingNode, ast, comment, isLastComment) {\n  // With Flow the enclosingNode is undefined so use the AST instead.\n  if (ast && ast.body && ast.body.length === 0) {\n    if (isLastComment) {\n      addDanglingComment(ast, comment);\n    } else {\n      addLeadingComment(ast, comment);\n    }\n\n    return true;\n  } else if (enclosingNode && enclosingNode.type === \"Program\" && enclosingNode.body.length === 0 && enclosingNode.directives && enclosingNode.directives.length === 0) {\n    if (isLastComment) {\n      addDanglingComment(enclosingNode, comment);\n    } else {\n      addLeadingComment(enclosingNode, comment);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleForComments(enclosingNode, precedingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"ForInStatement\" || enclosingNode.type === \"ForOfStatement\")) {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleImportDeclarationComments(text, enclosingNode, precedingNode, comment, options) {\n  if (precedingNode && precedingNode.type === \"ImportSpecifier\" && enclosingNode && enclosingNode.type === \"ImportDeclaration\" && privateUtil.hasNewline(text, options.locEnd(comment))) {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleAssignmentPatternComments(enclosingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"AssignmentPattern\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleTypeAliasComments(enclosingNode, followingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"TypeAlias\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleVariableDeclaratorComments(enclosingNode, followingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"VariableDeclarator\" || enclosingNode.type === \"AssignmentExpression\") && followingNode && (followingNode.type === \"ObjectExpression\" || followingNode.type === \"ArrayExpression\" || followingNode.type === \"TemplateLiteral\" || followingNode.type === \"TaggedTemplateExpression\")) {\n    addLeadingComment(followingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleTSMappedTypeComments(text, enclosingNode, precedingNode, followingNode, comment) {\n  if (!enclosingNode || enclosingNode.type !== \"TSMappedType\") {\n    return false;\n  }\n\n  if (followingNode && followingNode.type === \"TSTypeParameter\" && followingNode.name) {\n    addLeadingComment(followingNode.name, comment);\n    return true;\n  }\n\n  if (precedingNode && precedingNode.type === \"TSTypeParameter\" && precedingNode.constraint) {\n    addTrailingComment(precedingNode.constraint, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction isBlockComment(comment) {\n  return comment.type === \"Block\" || comment.type === \"CommentBlock\";\n}\n\nfunction hasLeadingComment(node) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n    return true;\n  };\n\n  if (node.leadingComments) {\n    return node.leadingComments.some(fn);\n  }\n\n  if (node.comments) {\n    return node.comments.some(function (comment) {\n      return comment.leading && fn(comment);\n    });\n  }\n\n  return false;\n}\n\nmodule.exports = {\n  handleOwnLineComment: handleOwnLineComment,\n  handleEndOfLineComment: handleEndOfLineComment,\n  handleRemainingComment: handleRemainingComment,\n  hasLeadingComment: hasLeadingComment,\n  isBlockComment: isBlockComment\n};","map":{"version":3,"sources":["/Users/pranamyavadlamani/Desktop/Research/PortFolio/portfolio-site/node_modules/@miksu/prettier/lib/language-js/comments.js"],"names":["privateUtil","require","sharedUtil","addLeadingComment","addTrailingComment","addDanglingComment","handleOwnLineComment","comment","text","options","ast","isLastComment","precedingNode","enclosingNode","followingNode","handleLastFunctionArgComments","handleMemberExpressionComments","handleIfStatementComments","handleWhileComments","handleTryStatementComments","handleClassComments","handleImportSpecifierComments","handleForComments","handleUnionTypeComments","handleOnlyComments","handleImportDeclarationComments","handleAssignmentPatternComments","handleMethodNameComments","handleEndOfLineComment","handleConditionalExpressionComments","handleLabeledStatementComments","handleCallExpressionComments","handlePropertyComments","handleTypeAliasComments","handleVariableDeclaratorComments","handleRemainingComment","handleObjectPropertyAssignment","handleCommentInEmptyParens","handleCommentAfterArrowParams","handleFunctionNameComments","handleTSMappedTypeComments","handleBreakAndContinueStatementComments","addBlockStatementFirstComment","node","body","filter","n","type","length","addBlockOrNotComment","nextCharacter","getNextNonSpaceNonCommentCharacter","locEnd","consequent","alternate","finalizer","isSameLineAsPrecedingNode","hasNewlineInRange","locStart","shorthand","key","value","left","decorators","index","getNextNonSpaceNonCommentCharacterIndex","substr","params","arguments","functionParamRightParenIndex","getNextNonSpaceNonCommentCharacterIndexWithStartIndex","getLast","functionParamLeftParenIndex","id","label","callee","directives","hasNewline","name","constraint","isBlockComment","hasLeadingComment","fn","undefined","leadingComments","some","comments","leading","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar privateUtil = require(\"../common/util\");\n\nvar sharedUtil = require(\"../common/util-shared\");\n\nvar addLeadingComment = sharedUtil.addLeadingComment,\n    addTrailingComment = sharedUtil.addTrailingComment,\n    addDanglingComment = sharedUtil.addDanglingComment;\n\nfunction handleOwnLineComment(comment, text, options, ast, isLastComment) {\n  var precedingNode = comment.precedingNode,\n      enclosingNode = comment.enclosingNode,\n      followingNode = comment.followingNode;\n\n  if (handleLastFunctionArgComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleMemberExpressionComments(enclosingNode, followingNode, comment) || handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleTryStatementComments(enclosingNode, precedingNode, followingNode, comment) || handleClassComments(enclosingNode, precedingNode, followingNode, comment) || handleImportSpecifierComments(enclosingNode, comment) || handleForComments(enclosingNode, precedingNode, comment) || handleUnionTypeComments(precedingNode, enclosingNode, followingNode, comment) || handleOnlyComments(enclosingNode, ast, comment, isLastComment) || handleImportDeclarationComments(text, enclosingNode, precedingNode, comment, options) || handleAssignmentPatternComments(enclosingNode, comment) || handleMethodNameComments(text, enclosingNode, precedingNode, comment, options)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleEndOfLineComment(comment, text, options, ast, isLastComment) {\n  var precedingNode = comment.precedingNode,\n      enclosingNode = comment.enclosingNode,\n      followingNode = comment.followingNode;\n\n  if (handleLastFunctionArgComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleConditionalExpressionComments(enclosingNode, precedingNode, followingNode, comment, text, options) || handleImportSpecifierComments(enclosingNode, comment) || handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleTryStatementComments(enclosingNode, precedingNode, followingNode, comment) || handleClassComments(enclosingNode, precedingNode, followingNode, comment) || handleLabeledStatementComments(enclosingNode, comment) || handleCallExpressionComments(precedingNode, enclosingNode, comment) || handlePropertyComments(enclosingNode, comment) || handleOnlyComments(enclosingNode, ast, comment, isLastComment) || handleTypeAliasComments(enclosingNode, followingNode, comment) || handleVariableDeclaratorComments(enclosingNode, followingNode, comment)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleRemainingComment(comment, text, options, ast, isLastComment) {\n  var precedingNode = comment.precedingNode,\n      enclosingNode = comment.enclosingNode,\n      followingNode = comment.followingNode;\n\n  if (handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleObjectPropertyAssignment(enclosingNode, precedingNode, comment) || handleCommentInEmptyParens(text, enclosingNode, comment, options) || handleMethodNameComments(text, enclosingNode, precedingNode, comment, options) || handleOnlyComments(enclosingNode, ast, comment, isLastComment) || handleCommentAfterArrowParams(text, enclosingNode, comment, options) || handleFunctionNameComments(text, enclosingNode, precedingNode, comment, options) || handleTSMappedTypeComments(text, enclosingNode, precedingNode, followingNode, comment) || handleBreakAndContinueStatementComments(enclosingNode, comment)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction addBlockStatementFirstComment(node, comment) {\n  var body = node.body.filter(function (n) {\n    return n.type !== \"EmptyStatement\";\n  });\n\n  if (body.length === 0) {\n    addDanglingComment(node, comment);\n  } else {\n    addLeadingComment(body[0], comment);\n  }\n}\n\nfunction addBlockOrNotComment(node, comment) {\n  if (node.type === \"BlockStatement\") {\n    addBlockStatementFirstComment(node, comment);\n  } else {\n    addLeadingComment(node, comment);\n  }\n} // There are often comments before the else clause of if statements like\n//\n//   if (1) { ... }\n//   // comment\n//   else { ... }\n//\n// They are being attached as leading comments of the BlockExpression which\n// is not well printed. What we want is to instead move the comment inside\n// of the block and make it leadingComment of the first element of the block\n// or dangling comment of the block if there is nothing inside\n//\n//   if (1) { ... }\n//   else {\n//     // comment\n//     ...\n//   }\n\n\nfunction handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) {\n  if (!enclosingNode || enclosingNode.type !== \"IfStatement\" || !followingNode) {\n    return false;\n  } // We unfortunately have no way using the AST or location of nodes to know\n  // if the comment is positioned before the condition parenthesis:\n  //   if (a /* comment */) {}\n  // The only workaround I found is to look at the next character to see if\n  // it is a ).\n\n\n  var nextCharacter = privateUtil.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd);\n\n  if (nextCharacter === \")\") {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  } // Comments before `else`:\n  // - treat as trailing comments of the consequent, if it's a BlockStatement\n  // - treat as a dangling comment otherwise\n\n\n  if (precedingNode === enclosingNode.consequent && followingNode === enclosingNode.alternate) {\n    if (precedingNode.type === \"BlockStatement\") {\n      addTrailingComment(precedingNode, comment);\n    } else {\n      addDanglingComment(enclosingNode, comment);\n    }\n\n    return true;\n  }\n\n  if (followingNode.type === \"BlockStatement\") {\n    addBlockStatementFirstComment(followingNode, comment);\n    return true;\n  }\n\n  if (followingNode.type === \"IfStatement\") {\n    addBlockOrNotComment(followingNode.consequent, comment);\n    return true;\n  } // For comments positioned after the condition parenthesis in an if statement\n  // before the consequent without brackets on, such as\n  // if (a) /* comment */ true,\n  // we look at the next character to see if the following node\n  // is the consequent for the if statement\n\n\n  if (enclosingNode.consequent === followingNode) {\n    addLeadingComment(followingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) {\n  if (!enclosingNode || enclosingNode.type !== \"WhileStatement\" || !followingNode) {\n    return false;\n  } // We unfortunately have no way using the AST or location of nodes to know\n  // if the comment is positioned before the condition parenthesis:\n  //   while (a /* comment */) {}\n  // The only workaround I found is to look at the next character to see if\n  // it is a ).\n\n\n  var nextCharacter = privateUtil.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd);\n\n  if (nextCharacter === \")\") {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  if (followingNode.type === \"BlockStatement\") {\n    addBlockStatementFirstComment(followingNode, comment);\n    return true;\n  }\n\n  return false;\n} // Same as IfStatement but for TryStatement\n\n\nfunction handleTryStatementComments(enclosingNode, precedingNode, followingNode, comment) {\n  if (!enclosingNode || enclosingNode.type !== \"TryStatement\" && enclosingNode.type !== \"CatchClause\" || !followingNode) {\n    return false;\n  }\n\n  if (enclosingNode.type === \"CatchClause\" && precedingNode) {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  if (followingNode.type === \"BlockStatement\") {\n    addBlockStatementFirstComment(followingNode, comment);\n    return true;\n  }\n\n  if (followingNode.type === \"TryStatement\") {\n    addBlockOrNotComment(followingNode.finalizer, comment);\n    return true;\n  }\n\n  if (followingNode.type === \"CatchClause\") {\n    addBlockOrNotComment(followingNode.body, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleMemberExpressionComments(enclosingNode, followingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"MemberExpression\" && followingNode && followingNode.type === \"Identifier\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleConditionalExpressionComments(enclosingNode, precedingNode, followingNode, comment, text, options) {\n  var isSameLineAsPrecedingNode = precedingNode && !privateUtil.hasNewlineInRange(text, options.locEnd(precedingNode), options.locStart(comment));\n\n  if ((!precedingNode || !isSameLineAsPrecedingNode) && enclosingNode && enclosingNode.type === \"ConditionalExpression\" && followingNode) {\n    addLeadingComment(followingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleObjectPropertyAssignment(enclosingNode, precedingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"ObjectProperty\" || enclosingNode.type === \"Property\") && enclosingNode.shorthand && enclosingNode.key === precedingNode && enclosingNode.value.type === \"AssignmentPattern\") {\n    addTrailingComment(enclosingNode.value.left, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleClassComments(enclosingNode, precedingNode, followingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"ClassDeclaration\" || enclosingNode.type === \"ClassExpression\") && enclosingNode.decorators && enclosingNode.decorators.length > 0 && !(followingNode && followingNode.type === \"Decorator\")) {\n    if (!enclosingNode.decorators || enclosingNode.decorators.length === 0) {\n      addLeadingComment(enclosingNode, comment);\n    } else {\n      addTrailingComment(enclosingNode.decorators[enclosingNode.decorators.length - 1], comment);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleMethodNameComments(text, enclosingNode, precedingNode, comment, options) {\n  // This is only needed for estree parsers (flow, typescript) to attach\n  // after a method name:\n  // obj = { fn /*comment*/() {} };\n  if (enclosingNode && precedingNode && (enclosingNode.type === \"Property\" || enclosingNode.type === \"MethodDefinition\") && precedingNode.type === \"Identifier\" && enclosingNode.key === precedingNode && // special Property case: { key: /*comment*/(value) };\n  // comment should be attached to value instead of key\n  privateUtil.getNextNonSpaceNonCommentCharacter(text, precedingNode, options.locEnd) !== \":\") {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  } // Print comments between decorators and class methods as a trailing comment\n  // on the decorator node instead of the method node\n\n\n  if (precedingNode && enclosingNode && precedingNode.type === \"Decorator\" && (enclosingNode.type === \"ClassMethod\" || enclosingNode.type === \"ClassProperty\" || enclosingNode.type === \"TSAbstractClassProperty\" || enclosingNode.type === \"TSAbstractMethodDefinition\" || enclosingNode.type === \"MethodDefinition\")) {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleFunctionNameComments(text, enclosingNode, precedingNode, comment, options) {\n  if (privateUtil.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd) !== \"(\") {\n    return false;\n  }\n\n  if (precedingNode && enclosingNode && (enclosingNode.type === \"FunctionDeclaration\" || enclosingNode.type === \"FunctionExpression\" || enclosingNode.type === \"ClassMethod\" || enclosingNode.type === \"MethodDefinition\" || enclosingNode.type === \"ObjectMethod\")) {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleCommentAfterArrowParams(text, enclosingNode, comment, options) {\n  if (!(enclosingNode && enclosingNode.type === \"ArrowFunctionExpression\")) {\n    return false;\n  }\n\n  var index = sharedUtil.getNextNonSpaceNonCommentCharacterIndex(text, comment, options);\n\n  if (text.substr(index, 2) === \"=>\") {\n    addDanglingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleCommentInEmptyParens(text, enclosingNode, comment, options) {\n  if (privateUtil.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd) !== \")\") {\n    return false;\n  } // Only add dangling comments to fix the case when no params are present,\n  // i.e. a function without any argument.\n\n\n  if (enclosingNode && ((enclosingNode.type === \"FunctionDeclaration\" || enclosingNode.type === \"FunctionExpression\" || enclosingNode.type === \"ArrowFunctionExpression\" || enclosingNode.type === \"ClassMethod\" || enclosingNode.type === \"ObjectMethod\") && enclosingNode.params.length === 0 || (enclosingNode.type === \"CallExpression\" || enclosingNode.type === \"NewExpression\") && enclosingNode.arguments.length === 0)) {\n    addDanglingComment(enclosingNode, comment);\n    return true;\n  }\n\n  if (enclosingNode && enclosingNode.type === \"MethodDefinition\" && enclosingNode.value.params.length === 0) {\n    addDanglingComment(enclosingNode.value, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleLastFunctionArgComments(text, precedingNode, enclosingNode, followingNode, comment, options) {\n  // Type definitions functions\n  if (precedingNode && precedingNode.type === \"FunctionTypeParam\" && enclosingNode && enclosingNode.type === \"FunctionTypeAnnotation\" && followingNode && followingNode.type !== \"FunctionTypeParam\") {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  } // Real functions\n\n\n  if (precedingNode && (precedingNode.type === \"Identifier\" || precedingNode.type === \"AssignmentPattern\") && enclosingNode && (enclosingNode.type === \"ArrowFunctionExpression\" || enclosingNode.type === \"FunctionExpression\" || enclosingNode.type === \"FunctionDeclaration\" || enclosingNode.type === \"ObjectMethod\" || enclosingNode.type === \"ClassMethod\") && privateUtil.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd) === \")\") {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  if (enclosingNode && enclosingNode.type === \"FunctionDeclaration\" && followingNode && followingNode.type === \"BlockStatement\") {\n    var functionParamRightParenIndex = function () {\n      if (enclosingNode.params.length !== 0) {\n        return privateUtil.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, options.locEnd(privateUtil.getLast(enclosingNode.params)));\n      }\n\n      var functionParamLeftParenIndex = privateUtil.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, options.locEnd(enclosingNode.id));\n      return privateUtil.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, functionParamLeftParenIndex + 1);\n    }();\n\n    if (options.locStart(comment) > functionParamRightParenIndex) {\n      addBlockStatementFirstComment(followingNode, comment);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction handleImportSpecifierComments(enclosingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"ImportSpecifier\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleLabeledStatementComments(enclosingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"LabeledStatement\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleBreakAndContinueStatementComments(enclosingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"ContinueStatement\" || enclosingNode.type === \"BreakStatement\") && !enclosingNode.label) {\n    addTrailingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleCallExpressionComments(precedingNode, enclosingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"CallExpression\" && precedingNode && enclosingNode.callee === precedingNode && enclosingNode.arguments.length > 0) {\n    addLeadingComment(enclosingNode.arguments[0], comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleUnionTypeComments(precedingNode, enclosingNode, followingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"UnionTypeAnnotation\" || enclosingNode.type === \"TSUnionType\")) {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handlePropertyComments(enclosingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"Property\" || enclosingNode.type === \"ObjectProperty\")) {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleOnlyComments(enclosingNode, ast, comment, isLastComment) {\n  // With Flow the enclosingNode is undefined so use the AST instead.\n  if (ast && ast.body && ast.body.length === 0) {\n    if (isLastComment) {\n      addDanglingComment(ast, comment);\n    } else {\n      addLeadingComment(ast, comment);\n    }\n\n    return true;\n  } else if (enclosingNode && enclosingNode.type === \"Program\" && enclosingNode.body.length === 0 && enclosingNode.directives && enclosingNode.directives.length === 0) {\n    if (isLastComment) {\n      addDanglingComment(enclosingNode, comment);\n    } else {\n      addLeadingComment(enclosingNode, comment);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleForComments(enclosingNode, precedingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"ForInStatement\" || enclosingNode.type === \"ForOfStatement\")) {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleImportDeclarationComments(text, enclosingNode, precedingNode, comment, options) {\n  if (precedingNode && precedingNode.type === \"ImportSpecifier\" && enclosingNode && enclosingNode.type === \"ImportDeclaration\" && privateUtil.hasNewline(text, options.locEnd(comment))) {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleAssignmentPatternComments(enclosingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"AssignmentPattern\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleTypeAliasComments(enclosingNode, followingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"TypeAlias\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleVariableDeclaratorComments(enclosingNode, followingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"VariableDeclarator\" || enclosingNode.type === \"AssignmentExpression\") && followingNode && (followingNode.type === \"ObjectExpression\" || followingNode.type === \"ArrayExpression\" || followingNode.type === \"TemplateLiteral\" || followingNode.type === \"TaggedTemplateExpression\")) {\n    addLeadingComment(followingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleTSMappedTypeComments(text, enclosingNode, precedingNode, followingNode, comment) {\n  if (!enclosingNode || enclosingNode.type !== \"TSMappedType\") {\n    return false;\n  }\n\n  if (followingNode && followingNode.type === \"TSTypeParameter\" && followingNode.name) {\n    addLeadingComment(followingNode.name, comment);\n    return true;\n  }\n\n  if (precedingNode && precedingNode.type === \"TSTypeParameter\" && precedingNode.constraint) {\n    addTrailingComment(precedingNode.constraint, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction isBlockComment(comment) {\n  return comment.type === \"Block\" || comment.type === \"CommentBlock\";\n}\n\nfunction hasLeadingComment(node) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n    return true;\n  };\n\n  if (node.leadingComments) {\n    return node.leadingComments.some(fn);\n  }\n\n  if (node.comments) {\n    return node.comments.some(function (comment) {\n      return comment.leading && fn(comment);\n    });\n  }\n\n  return false;\n}\n\nmodule.exports = {\n  handleOwnLineComment: handleOwnLineComment,\n  handleEndOfLineComment: handleEndOfLineComment,\n  handleRemainingComment: handleRemainingComment,\n  hasLeadingComment: hasLeadingComment,\n  isBlockComment: isBlockComment\n};"]},"metadata":{},"sourceType":"script"}