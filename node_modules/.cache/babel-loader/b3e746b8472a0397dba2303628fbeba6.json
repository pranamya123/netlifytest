{"ast":null,"code":"\"use strict\";\n\nvar stringWidth = require(\"string-width\");\n\nvar escapeStringRegexp = require(\"escape-string-regexp\");\n\nvar getLast = require(\"../utils/get-last\"); // eslint-disable-next-line no-control-regex\n\n\nvar notAsciiRegex = /[^\\x20-\\x7F]/;\n\nfunction isExportDeclaration(node) {\n  if (node) {\n    switch (node.type) {\n      case \"ExportDefaultDeclaration\":\n      case \"ExportDefaultSpecifier\":\n      case \"DeclareExportDeclaration\":\n      case \"ExportNamedDeclaration\":\n      case \"ExportAllDeclaration\":\n        return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getParentExportDeclaration(path) {\n  var parentNode = path.getParentNode();\n\n  if (path.getName() === \"declaration\" && isExportDeclaration(parentNode)) {\n    return parentNode;\n  }\n\n  return null;\n}\n\nfunction getPenultimate(arr) {\n  if (arr.length > 1) {\n    return arr[arr.length - 2];\n  }\n\n  return null;\n}\n\nfunction skip(chars) {\n  return function (text, index, opts) {\n    var backwards = opts && opts.backwards; // Allow `skip` functions to be threaded together without having\n    // to check for failures (did someone say monads?).\n\n    if (index === false) {\n      return false;\n    }\n\n    var length = text.length;\n    var cursor = index;\n\n    while (cursor >= 0 && cursor < length) {\n      var c = text.charAt(cursor);\n\n      if (chars instanceof RegExp) {\n        if (!chars.test(c)) {\n          return cursor;\n        }\n      } else if (chars.indexOf(c) === -1) {\n        return cursor;\n      }\n\n      backwards ? cursor-- : cursor++;\n    }\n\n    if (cursor === -1 || cursor === length) {\n      // If we reached the beginning or end of the file, return the\n      // out-of-bounds cursor. It's up to the caller to handle this\n      // correctly. We don't want to indicate `false` though if it\n      // actually skipped valid characters.\n      return cursor;\n    }\n\n    return false;\n  };\n}\n\nvar skipWhitespace = skip(/\\s/);\nvar skipSpaces = skip(\" \\t\");\nvar skipToLineEnd = skip(\",; \\t\");\nvar skipEverythingButNewLine = skip(/[^\\r\\n]/);\n\nfunction skipInlineComment(text, index) {\n  if (index === false) {\n    return false;\n  }\n\n  if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"*\") {\n    for (var i = index + 2; i < text.length; ++i) {\n      if (text.charAt(i) === \"*\" && text.charAt(i + 1) === \"/\") {\n        return i + 2;\n      }\n    }\n  }\n\n  return index;\n}\n\nfunction skipTrailingComment(text, index) {\n  if (index === false) {\n    return false;\n  }\n\n  if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"/\") {\n    return skipEverythingButNewLine(text, index);\n  }\n\n  return index;\n} // This one doesn't use the above helper function because it wants to\n// test \\r\\n in order and `skip` doesn't support ordering and we only\n// want to skip one newline. It's simple to implement.\n\n\nfunction skipNewline(text, index, opts) {\n  var backwards = opts && opts.backwards;\n\n  if (index === false) {\n    return false;\n  }\n\n  var atIndex = text.charAt(index);\n\n  if (backwards) {\n    if (text.charAt(index - 1) === \"\\r\" && atIndex === \"\\n\") {\n      return index - 2;\n    }\n\n    if (atIndex === \"\\n\" || atIndex === \"\\r\" || atIndex === \"\\u2028\" || atIndex === \"\\u2029\") {\n      return index - 1;\n    }\n  } else {\n    if (atIndex === \"\\r\" && text.charAt(index + 1) === \"\\n\") {\n      return index + 2;\n    }\n\n    if (atIndex === \"\\n\" || atIndex === \"\\r\" || atIndex === \"\\u2028\" || atIndex === \"\\u2029\") {\n      return index + 1;\n    }\n  }\n\n  return index;\n}\n\nfunction hasNewline(text, index, opts) {\n  opts = opts || {};\n  var idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);\n  var idx2 = skipNewline(text, idx, opts);\n  return idx !== idx2;\n}\n\nfunction hasNewlineInRange(text, start, end) {\n  for (var i = start; i < end; ++i) {\n    if (text.charAt(i) === \"\\n\") {\n      return true;\n    }\n  }\n\n  return false;\n} // Note: this function doesn't ignore leading comments unlike isNextLineEmpty\n\n\nfunction isPreviousLineEmpty(text, node, locStart) {\n  var idx = locStart(node) - 1;\n  idx = skipSpaces(text, idx, {\n    backwards: true\n  });\n  idx = skipNewline(text, idx, {\n    backwards: true\n  });\n  idx = skipSpaces(text, idx, {\n    backwards: true\n  });\n  var idx2 = skipNewline(text, idx, {\n    backwards: true\n  });\n  return idx !== idx2;\n}\n\nfunction isNextLineEmptyAfterIndex(text, index) {\n  var oldIdx = null;\n  var idx = index;\n\n  while (idx !== oldIdx) {\n    // We need to skip all the potential trailing inline comments\n    oldIdx = idx;\n    idx = skipToLineEnd(text, idx);\n    idx = skipInlineComment(text, idx);\n    idx = skipSpaces(text, idx);\n  }\n\n  idx = skipTrailingComment(text, idx);\n  idx = skipNewline(text, idx);\n  return hasNewline(text, idx);\n}\n\nfunction isNextLineEmpty(text, node, locEnd) {\n  return isNextLineEmptyAfterIndex(text, locEnd(node));\n}\n\nfunction getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, idx) {\n  var oldIdx = null;\n\n  while (idx !== oldIdx) {\n    oldIdx = idx;\n    idx = skipSpaces(text, idx);\n    idx = skipInlineComment(text, idx);\n    idx = skipTrailingComment(text, idx);\n    idx = skipNewline(text, idx);\n  }\n\n  return idx;\n}\n\nfunction getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd) {\n  return getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, locEnd(node));\n}\n\nfunction getNextNonSpaceNonCommentCharacter(text, node, locEnd) {\n  return text.charAt(getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd));\n}\n\nfunction hasSpaces(text, index, opts) {\n  opts = opts || {};\n  var idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);\n  return idx !== index;\n}\n\nfunction setLocStart(node, index) {\n  if (node.range) {\n    node.range[0] = index;\n  } else {\n    node.start = index;\n  }\n}\n\nfunction setLocEnd(node, index) {\n  if (node.range) {\n    node.range[1] = index;\n  } else {\n    node.end = index;\n  }\n}\n\nvar PRECEDENCE = {};\n[[\"|>\"], [\"??\"], [\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"===\", \"!=\", \"!==\"], [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"], [\">>\", \"<<\", \">>>\"], [\"+\", \"-\"], [\"*\", \"/\", \"%\"], [\"**\"]].forEach(function (tier, i) {\n  tier.forEach(function (op) {\n    PRECEDENCE[op] = i;\n  });\n});\n\nfunction getPrecedence(op) {\n  return PRECEDENCE[op];\n}\n\nvar equalityOperators = {\n  \"==\": true,\n  \"!=\": true,\n  \"===\": true,\n  \"!==\": true\n};\nvar multiplicativeOperators = {\n  \"*\": true,\n  \"/\": true,\n  \"%\": true\n};\nvar bitshiftOperators = {\n  \">>\": true,\n  \">>>\": true,\n  \"<<\": true\n};\n\nfunction shouldFlatten(parentOp, nodeOp) {\n  if (getPrecedence(nodeOp) !== getPrecedence(parentOp)) {\n    return false;\n  } // ** is right-associative\n  // x ** y ** z --> x ** (y ** z)\n\n\n  if (parentOp === \"**\") {\n    return false;\n  } // x == y == z --> (x == y) == z\n\n\n  if (equalityOperators[parentOp] && equalityOperators[nodeOp]) {\n    return false;\n  } // x * y % z --> (x * y) % z\n\n\n  if (nodeOp === \"%\" && multiplicativeOperators[parentOp] || parentOp === \"%\" && multiplicativeOperators[nodeOp]) {\n    return false;\n  } // x * y / z --> (x * y) / z\n  // x / y * z --> (x / y) * z\n\n\n  if (nodeOp !== parentOp && multiplicativeOperators[nodeOp] && multiplicativeOperators[parentOp]) {\n    return false;\n  } // x << y << z --> (x << y) << z\n\n\n  if (bitshiftOperators[parentOp] && bitshiftOperators[nodeOp]) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isBitwiseOperator(operator) {\n  return !!bitshiftOperators[operator] || operator === \"|\" || operator === \"^\" || operator === \"&\";\n} // Tests if an expression starts with `{`, or (if forbidFunctionClassAndDoExpr\n// holds) `function`, `class`, or `do {}`. Will be overzealous if there's\n// already necessary grouping parentheses.\n\n\nfunction startsWithNoLookaheadToken(node, forbidFunctionClassAndDoExpr) {\n  node = getLeftMost(node);\n\n  switch (node.type) {\n    case \"FunctionExpression\":\n    case \"ClassExpression\":\n    case \"DoExpression\":\n      return forbidFunctionClassAndDoExpr;\n\n    case \"ObjectExpression\":\n      return true;\n\n    case \"MemberExpression\":\n      return startsWithNoLookaheadToken(node.object, forbidFunctionClassAndDoExpr);\n\n    case \"TaggedTemplateExpression\":\n      if (node.tag.type === \"FunctionExpression\") {\n        // IIFEs are always already parenthesized\n        return false;\n      }\n\n      return startsWithNoLookaheadToken(node.tag, forbidFunctionClassAndDoExpr);\n\n    case \"CallExpression\":\n      if (node.callee.type === \"FunctionExpression\") {\n        // IIFEs are always already parenthesized\n        return false;\n      }\n\n      return startsWithNoLookaheadToken(node.callee, forbidFunctionClassAndDoExpr);\n\n    case \"ConditionalExpression\":\n      return startsWithNoLookaheadToken(node.test, forbidFunctionClassAndDoExpr);\n\n    case \"UpdateExpression\":\n      return !node.prefix && startsWithNoLookaheadToken(node.argument, forbidFunctionClassAndDoExpr);\n\n    case \"BindExpression\":\n      return node.object && startsWithNoLookaheadToken(node.object, forbidFunctionClassAndDoExpr);\n\n    case \"SequenceExpression\":\n      return startsWithNoLookaheadToken(node.expressions[0], forbidFunctionClassAndDoExpr);\n\n    case \"TSAsExpression\":\n      return startsWithNoLookaheadToken(node.expression, forbidFunctionClassAndDoExpr);\n\n    default:\n      return false;\n  }\n}\n\nfunction getLeftMost(node) {\n  if (node.left) {\n    return getLeftMost(node.left);\n  }\n\n  return node;\n}\n\nfunction getAlignmentSize(value, tabWidth, startIndex) {\n  startIndex = startIndex || 0;\n  var size = 0;\n\n  for (var i = startIndex; i < value.length; ++i) {\n    if (value[i] === \"\\t\") {\n      // Tabs behave in a way that they are aligned to the nearest\n      // multiple of tabWidth:\n      // 0 -> 4, 1 -> 4, 2 -> 4, 3 -> 4\n      // 4 -> 8, 5 -> 8, 6 -> 8, 7 -> 8 ...\n      size = size + tabWidth - size % tabWidth;\n    } else {\n      size++;\n    }\n  }\n\n  return size;\n}\n\nfunction getIndentSize(value, tabWidth) {\n  var lastNewlineIndex = value.lastIndexOf(\"\\n\");\n\n  if (lastNewlineIndex === -1) {\n    return 0;\n  }\n\n  return getAlignmentSize( // All the leading whitespaces\n  value.slice(lastNewlineIndex + 1).match(/^[ \\t]*/)[0], tabWidth);\n}\n\nfunction getPreferredQuote(raw, preferredQuote) {\n  // `rawContent` is the string exactly like it appeared in the input source\n  // code, without its enclosing quotes.\n  var rawContent = raw;\n  var _double = {\n    quote: '\"',\n    regex: /\"/g\n  };\n  var single = {\n    quote: \"'\",\n    regex: /'/g\n  };\n  var preferred = preferredQuote === \"'\" ? single : _double;\n  var alternate = preferred === single ? _double : single;\n  var result = preferred.quote; // If `rawContent` contains at least one of the quote preferred for enclosing\n  // the string, we might want to enclose with the alternate quote instead, to\n  // minimize the number of escaped quotes.\n\n  if (rawContent.includes(preferred.quote) || rawContent.includes(alternate.quote)) {\n    var numPreferredQuotes = (rawContent.match(preferred.regex) || []).length;\n    var numAlternateQuotes = (rawContent.match(alternate.regex) || []).length;\n    result = numPreferredQuotes > numAlternateQuotes ? alternate.quote : preferred.quote;\n  }\n\n  return result;\n}\n\nfunction printString(raw, options, isDirectiveLiteral) {\n  // `rawContent` is the string exactly like it appeared in the input source\n  // code, without its enclosing quotes.\n  var rawContent = raw; // Check for the alternate quote, to determine if we're allowed to swap\n  // the quotes on a DirectiveLiteral.\n\n  var canChangeDirectiveQuotes = !rawContent.includes('\"') && !rawContent.includes(\"'\");\n  var enclosingQuote = options.parser === \"json\" ? '\"' : options.__isInHtmlAttribute ? \"'\" : getPreferredQuote(raw, options.singleQuote ? \"'\" : '\"'); // Directives are exact code unit sequences, which means that you can't\n  // change the escape sequences they use.\n  // See https://github.com/prettier/prettier/issues/1555\n  // and https://tc39.github.io/ecma262/#directive-prologue\n\n  if (isDirectiveLiteral) {\n    if (canChangeDirectiveQuotes) {\n      return enclosingQuote + rawContent + enclosingQuote;\n    }\n\n    return raw;\n  } // It might sound unnecessary to use `makeString` even if the string already\n  // is enclosed with `enclosingQuote`, but it isn't. The string could contain\n  // unnecessary escapes (such as in `\"\\'\"`). Always using `makeString` makes\n  // sure that we consistently output the minimum amount of escaped quotes.\n\n\n  return makeString(rawContent, enclosingQuote, !(options.parser === \"css\" || options.parser === \"less\" || options.parser === \"scss\" || options.embeddedInHtml));\n}\n\nfunction makeString(rawContent, enclosingQuote, unescapeUnnecessaryEscapes) {\n  var otherQuote = enclosingQuote === '\"' ? \"'\" : '\"'; // Matches _any_ escape and unescaped quotes (both single and double).\n\n  var regex = /\\\\([\\s\\S])|(['\"])/g; // Escape and unescape single and double quotes as needed to be able to\n  // enclose `rawContent` with `enclosingQuote`.\n\n  var newContent = rawContent.replace(regex, function (match, escaped, quote) {\n    // If we matched an escape, and the escaped character is a quote of the\n    // other type than we intend to enclose the string with, there's no need for\n    // it to be escaped, so return it _without_ the backslash.\n    if (escaped === otherQuote) {\n      return escaped;\n    } // If we matched an unescaped quote and it is of the _same_ type as we\n    // intend to enclose the string with, it must be escaped, so return it with\n    // a backslash.\n\n\n    if (quote === enclosingQuote) {\n      return \"\\\\\" + quote;\n    }\n\n    if (quote) {\n      return quote;\n    } // Unescape any unnecessarily escaped character.\n    // Adapted from https://github.com/eslint/eslint/blob/de0b4ad7bd820ade41b1f606008bea68683dc11a/lib/rules/no-useless-escape.js#L27\n\n\n    return unescapeUnnecessaryEscapes && /^[^\\\\nrvtbfux\\r\\n\\u2028\\u2029\"'0-7]$/.test(escaped) ? escaped : \"\\\\\" + escaped;\n  });\n  return enclosingQuote + newContent + enclosingQuote;\n}\n\nfunction printNumber(rawNumber) {\n  return rawNumber.toLowerCase() // Remove unnecessary plus and zeroes from scientific notation.\n  .replace(/^([+-]?[\\d.]+e)(?:\\+|(-))?0*(\\d)/, \"$1$2$3\") // Remove unnecessary scientific notation (1e0).\n  .replace(/^([+-]?[\\d.]+)e[+-]?0+$/, \"$1\") // Make sure numbers always start with a digit.\n  .replace(/^([+-])?\\./, \"$10.\") // Remove extraneous trailing decimal zeroes.\n  .replace(/(\\.\\d+?)0+(?=e|$)/, \"$1\") // Remove trailing dot.\n  .replace(/\\.(?=e|$)/, \"\");\n}\n\nfunction getMaxContinuousCount(str, target) {\n  var results = str.match(new RegExp(\"(\".concat(escapeStringRegexp(target), \")+\"), \"g\"));\n\n  if (results === null) {\n    return 0;\n  }\n\n  return results.reduce(function (maxCount, result) {\n    return Math.max(maxCount, result.length / target.length);\n  }, 0);\n}\n\nfunction getMinNotPresentContinuousCount(str, target) {\n  var matches = str.match(new RegExp(\"(\".concat(escapeStringRegexp(target), \")+\"), \"g\"));\n\n  if (matches === null) {\n    return 0;\n  }\n\n  var countPresent = new Map();\n  var max = 0;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = matches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var match = _step.value;\n      var count = match.length / target.length;\n      countPresent.set(count, true);\n\n      if (count > max) {\n        max = count;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  for (var i = 1; i < max; i++) {\n    if (!countPresent.get(i)) {\n      return i;\n    }\n  }\n\n  return max + 1;\n}\n\nfunction getStringWidth(text) {\n  if (!text) {\n    return 0;\n  } // shortcut to avoid needless string `RegExp`s, replacements, and allocations within `string-width`\n\n\n  if (!notAsciiRegex.test(text)) {\n    return text.length;\n  }\n\n  return stringWidth(text);\n}\n\nfunction hasIgnoreComment(path) {\n  var node = path.getValue();\n  return hasNodeIgnoreComment(node);\n}\n\nfunction hasNodeIgnoreComment(node) {\n  return node && node.comments && node.comments.length > 0 && node.comments.some(function (comment) {\n    return comment.value.trim() === \"prettier-ignore\";\n  });\n}\n\nfunction matchAncestorTypes(path, types, index) {\n  index = index || 0;\n  types = types.slice();\n\n  while (types.length) {\n    var parent = path.getParentNode(index);\n    var type = types.shift();\n\n    if (!parent || parent.type !== type) {\n      return false;\n    }\n\n    index++;\n  }\n\n  return true;\n}\n\nfunction addCommentHelper(node, comment) {\n  var comments = node.comments || (node.comments = []);\n  comments.push(comment);\n  comment.printed = false; // For some reason, TypeScript parses `// x` inside of JSXText as a comment\n  // We already \"print\" it via the raw text, we don't need to re-print it as a\n  // comment\n\n  if (node.type === \"JSXText\") {\n    comment.printed = true;\n  }\n}\n\nfunction addLeadingComment(node, comment) {\n  comment.leading = true;\n  comment.trailing = false;\n  addCommentHelper(node, comment);\n}\n\nfunction addDanglingComment(node, comment) {\n  comment.leading = false;\n  comment.trailing = false;\n  addCommentHelper(node, comment);\n}\n\nfunction addTrailingComment(node, comment) {\n  comment.leading = false;\n  comment.trailing = true;\n  addCommentHelper(node, comment);\n}\n\nfunction isWithinParentArrayProperty(path, propertyName) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n\n  if (parent == null) {\n    return false;\n  }\n\n  if (!Array.isArray(parent[propertyName])) {\n    return false;\n  }\n\n  var key = path.getName();\n  return parent[propertyName][key] === node;\n}\n\nfunction replaceEndOfLineWith(text, replacement) {\n  var parts = [];\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = text.split(\"\\n\")[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var part = _step2.value;\n\n      if (parts.length !== 0) {\n        parts.push(replacement);\n      }\n\n      parts.push(part);\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n        _iterator2[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return parts;\n}\n\nmodule.exports = {\n  replaceEndOfLineWith: replaceEndOfLineWith,\n  getStringWidth: getStringWidth,\n  getMaxContinuousCount: getMaxContinuousCount,\n  getMinNotPresentContinuousCount: getMinNotPresentContinuousCount,\n  getPrecedence: getPrecedence,\n  shouldFlatten: shouldFlatten,\n  isBitwiseOperator: isBitwiseOperator,\n  isExportDeclaration: isExportDeclaration,\n  getParentExportDeclaration: getParentExportDeclaration,\n  getPenultimate: getPenultimate,\n  getLast: getLast,\n  getNextNonSpaceNonCommentCharacterIndexWithStartIndex: getNextNonSpaceNonCommentCharacterIndexWithStartIndex,\n  getNextNonSpaceNonCommentCharacterIndex: getNextNonSpaceNonCommentCharacterIndex,\n  getNextNonSpaceNonCommentCharacter: getNextNonSpaceNonCommentCharacter,\n  skip: skip,\n  skipWhitespace: skipWhitespace,\n  skipSpaces: skipSpaces,\n  skipToLineEnd: skipToLineEnd,\n  skipEverythingButNewLine: skipEverythingButNewLine,\n  skipInlineComment: skipInlineComment,\n  skipTrailingComment: skipTrailingComment,\n  skipNewline: skipNewline,\n  isNextLineEmptyAfterIndex: isNextLineEmptyAfterIndex,\n  isNextLineEmpty: isNextLineEmpty,\n  isPreviousLineEmpty: isPreviousLineEmpty,\n  hasNewline: hasNewline,\n  hasNewlineInRange: hasNewlineInRange,\n  hasSpaces: hasSpaces,\n  setLocStart: setLocStart,\n  setLocEnd: setLocEnd,\n  startsWithNoLookaheadToken: startsWithNoLookaheadToken,\n  getAlignmentSize: getAlignmentSize,\n  getIndentSize: getIndentSize,\n  getPreferredQuote: getPreferredQuote,\n  printString: printString,\n  printNumber: printNumber,\n  hasIgnoreComment: hasIgnoreComment,\n  hasNodeIgnoreComment: hasNodeIgnoreComment,\n  makeString: makeString,\n  matchAncestorTypes: matchAncestorTypes,\n  addLeadingComment: addLeadingComment,\n  addDanglingComment: addDanglingComment,\n  addTrailingComment: addTrailingComment,\n  isWithinParentArrayProperty: isWithinParentArrayProperty\n};","map":{"version":3,"sources":["/Users/pranamyavadlamani/Desktop/Research/PortFolio/portfolio-site/node_modules/@miksu/prettier/lib/common/util.js"],"names":["stringWidth","require","escapeStringRegexp","getLast","notAsciiRegex","isExportDeclaration","node","type","getParentExportDeclaration","path","parentNode","getParentNode","getName","getPenultimate","arr","length","skip","chars","text","index","opts","backwards","cursor","c","charAt","RegExp","test","indexOf","skipWhitespace","skipSpaces","skipToLineEnd","skipEverythingButNewLine","skipInlineComment","i","skipTrailingComment","skipNewline","atIndex","hasNewline","idx","idx2","hasNewlineInRange","start","end","isPreviousLineEmpty","locStart","isNextLineEmptyAfterIndex","oldIdx","isNextLineEmpty","locEnd","getNextNonSpaceNonCommentCharacterIndexWithStartIndex","getNextNonSpaceNonCommentCharacterIndex","getNextNonSpaceNonCommentCharacter","hasSpaces","setLocStart","range","setLocEnd","PRECEDENCE","forEach","tier","op","getPrecedence","equalityOperators","multiplicativeOperators","bitshiftOperators","shouldFlatten","parentOp","nodeOp","isBitwiseOperator","operator","startsWithNoLookaheadToken","forbidFunctionClassAndDoExpr","getLeftMost","object","tag","callee","prefix","argument","expressions","expression","left","getAlignmentSize","value","tabWidth","startIndex","size","getIndentSize","lastNewlineIndex","lastIndexOf","slice","match","getPreferredQuote","raw","preferredQuote","rawContent","_double","quote","regex","single","preferred","alternate","result","includes","numPreferredQuotes","numAlternateQuotes","printString","options","isDirectiveLiteral","canChangeDirectiveQuotes","enclosingQuote","parser","__isInHtmlAttribute","singleQuote","makeString","embeddedInHtml","unescapeUnnecessaryEscapes","otherQuote","newContent","replace","escaped","printNumber","rawNumber","toLowerCase","getMaxContinuousCount","str","target","results","concat","reduce","maxCount","Math","max","getMinNotPresentContinuousCount","matches","countPresent","Map","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","count","set","err","get","getStringWidth","hasIgnoreComment","getValue","hasNodeIgnoreComment","comments","some","comment","trim","matchAncestorTypes","types","parent","shift","addCommentHelper","push","printed","addLeadingComment","leading","trailing","addDanglingComment","addTrailingComment","isWithinParentArrayProperty","propertyName","Array","isArray","key","replaceEndOfLineWith","replacement","parts","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","split","_step2","part","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar stringWidth = require(\"string-width\");\n\nvar escapeStringRegexp = require(\"escape-string-regexp\");\n\nvar getLast = require(\"../utils/get-last\"); // eslint-disable-next-line no-control-regex\n\n\nvar notAsciiRegex = /[^\\x20-\\x7F]/;\n\nfunction isExportDeclaration(node) {\n  if (node) {\n    switch (node.type) {\n      case \"ExportDefaultDeclaration\":\n      case \"ExportDefaultSpecifier\":\n      case \"DeclareExportDeclaration\":\n      case \"ExportNamedDeclaration\":\n      case \"ExportAllDeclaration\":\n        return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getParentExportDeclaration(path) {\n  var parentNode = path.getParentNode();\n\n  if (path.getName() === \"declaration\" && isExportDeclaration(parentNode)) {\n    return parentNode;\n  }\n\n  return null;\n}\n\nfunction getPenultimate(arr) {\n  if (arr.length > 1) {\n    return arr[arr.length - 2];\n  }\n\n  return null;\n}\n\nfunction skip(chars) {\n  return function (text, index, opts) {\n    var backwards = opts && opts.backwards; // Allow `skip` functions to be threaded together without having\n    // to check for failures (did someone say monads?).\n\n    if (index === false) {\n      return false;\n    }\n\n    var length = text.length;\n    var cursor = index;\n\n    while (cursor >= 0 && cursor < length) {\n      var c = text.charAt(cursor);\n\n      if (chars instanceof RegExp) {\n        if (!chars.test(c)) {\n          return cursor;\n        }\n      } else if (chars.indexOf(c) === -1) {\n        return cursor;\n      }\n\n      backwards ? cursor-- : cursor++;\n    }\n\n    if (cursor === -1 || cursor === length) {\n      // If we reached the beginning or end of the file, return the\n      // out-of-bounds cursor. It's up to the caller to handle this\n      // correctly. We don't want to indicate `false` though if it\n      // actually skipped valid characters.\n      return cursor;\n    }\n\n    return false;\n  };\n}\n\nvar skipWhitespace = skip(/\\s/);\nvar skipSpaces = skip(\" \\t\");\nvar skipToLineEnd = skip(\",; \\t\");\nvar skipEverythingButNewLine = skip(/[^\\r\\n]/);\n\nfunction skipInlineComment(text, index) {\n  if (index === false) {\n    return false;\n  }\n\n  if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"*\") {\n    for (var i = index + 2; i < text.length; ++i) {\n      if (text.charAt(i) === \"*\" && text.charAt(i + 1) === \"/\") {\n        return i + 2;\n      }\n    }\n  }\n\n  return index;\n}\n\nfunction skipTrailingComment(text, index) {\n  if (index === false) {\n    return false;\n  }\n\n  if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"/\") {\n    return skipEverythingButNewLine(text, index);\n  }\n\n  return index;\n} // This one doesn't use the above helper function because it wants to\n// test \\r\\n in order and `skip` doesn't support ordering and we only\n// want to skip one newline. It's simple to implement.\n\n\nfunction skipNewline(text, index, opts) {\n  var backwards = opts && opts.backwards;\n\n  if (index === false) {\n    return false;\n  }\n\n  var atIndex = text.charAt(index);\n\n  if (backwards) {\n    if (text.charAt(index - 1) === \"\\r\" && atIndex === \"\\n\") {\n      return index - 2;\n    }\n\n    if (atIndex === \"\\n\" || atIndex === \"\\r\" || atIndex === \"\\u2028\" || atIndex === \"\\u2029\") {\n      return index - 1;\n    }\n  } else {\n    if (atIndex === \"\\r\" && text.charAt(index + 1) === \"\\n\") {\n      return index + 2;\n    }\n\n    if (atIndex === \"\\n\" || atIndex === \"\\r\" || atIndex === \"\\u2028\" || atIndex === \"\\u2029\") {\n      return index + 1;\n    }\n  }\n\n  return index;\n}\n\nfunction hasNewline(text, index, opts) {\n  opts = opts || {};\n  var idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);\n  var idx2 = skipNewline(text, idx, opts);\n  return idx !== idx2;\n}\n\nfunction hasNewlineInRange(text, start, end) {\n  for (var i = start; i < end; ++i) {\n    if (text.charAt(i) === \"\\n\") {\n      return true;\n    }\n  }\n\n  return false;\n} // Note: this function doesn't ignore leading comments unlike isNextLineEmpty\n\n\nfunction isPreviousLineEmpty(text, node, locStart) {\n  var idx = locStart(node) - 1;\n  idx = skipSpaces(text, idx, {\n    backwards: true\n  });\n  idx = skipNewline(text, idx, {\n    backwards: true\n  });\n  idx = skipSpaces(text, idx, {\n    backwards: true\n  });\n  var idx2 = skipNewline(text, idx, {\n    backwards: true\n  });\n  return idx !== idx2;\n}\n\nfunction isNextLineEmptyAfterIndex(text, index) {\n  var oldIdx = null;\n  var idx = index;\n\n  while (idx !== oldIdx) {\n    // We need to skip all the potential trailing inline comments\n    oldIdx = idx;\n    idx = skipToLineEnd(text, idx);\n    idx = skipInlineComment(text, idx);\n    idx = skipSpaces(text, idx);\n  }\n\n  idx = skipTrailingComment(text, idx);\n  idx = skipNewline(text, idx);\n  return hasNewline(text, idx);\n}\n\nfunction isNextLineEmpty(text, node, locEnd) {\n  return isNextLineEmptyAfterIndex(text, locEnd(node));\n}\n\nfunction getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, idx) {\n  var oldIdx = null;\n\n  while (idx !== oldIdx) {\n    oldIdx = idx;\n    idx = skipSpaces(text, idx);\n    idx = skipInlineComment(text, idx);\n    idx = skipTrailingComment(text, idx);\n    idx = skipNewline(text, idx);\n  }\n\n  return idx;\n}\n\nfunction getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd) {\n  return getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, locEnd(node));\n}\n\nfunction getNextNonSpaceNonCommentCharacter(text, node, locEnd) {\n  return text.charAt(getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd));\n}\n\nfunction hasSpaces(text, index, opts) {\n  opts = opts || {};\n  var idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);\n  return idx !== index;\n}\n\nfunction setLocStart(node, index) {\n  if (node.range) {\n    node.range[0] = index;\n  } else {\n    node.start = index;\n  }\n}\n\nfunction setLocEnd(node, index) {\n  if (node.range) {\n    node.range[1] = index;\n  } else {\n    node.end = index;\n  }\n}\n\nvar PRECEDENCE = {};\n[[\"|>\"], [\"??\"], [\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"===\", \"!=\", \"!==\"], [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"], [\">>\", \"<<\", \">>>\"], [\"+\", \"-\"], [\"*\", \"/\", \"%\"], [\"**\"]].forEach(function (tier, i) {\n  tier.forEach(function (op) {\n    PRECEDENCE[op] = i;\n  });\n});\n\nfunction getPrecedence(op) {\n  return PRECEDENCE[op];\n}\n\nvar equalityOperators = {\n  \"==\": true,\n  \"!=\": true,\n  \"===\": true,\n  \"!==\": true\n};\nvar multiplicativeOperators = {\n  \"*\": true,\n  \"/\": true,\n  \"%\": true\n};\nvar bitshiftOperators = {\n  \">>\": true,\n  \">>>\": true,\n  \"<<\": true\n};\n\nfunction shouldFlatten(parentOp, nodeOp) {\n  if (getPrecedence(nodeOp) !== getPrecedence(parentOp)) {\n    return false;\n  } // ** is right-associative\n  // x ** y ** z --> x ** (y ** z)\n\n\n  if (parentOp === \"**\") {\n    return false;\n  } // x == y == z --> (x == y) == z\n\n\n  if (equalityOperators[parentOp] && equalityOperators[nodeOp]) {\n    return false;\n  } // x * y % z --> (x * y) % z\n\n\n  if (nodeOp === \"%\" && multiplicativeOperators[parentOp] || parentOp === \"%\" && multiplicativeOperators[nodeOp]) {\n    return false;\n  } // x * y / z --> (x * y) / z\n  // x / y * z --> (x / y) * z\n\n\n  if (nodeOp !== parentOp && multiplicativeOperators[nodeOp] && multiplicativeOperators[parentOp]) {\n    return false;\n  } // x << y << z --> (x << y) << z\n\n\n  if (bitshiftOperators[parentOp] && bitshiftOperators[nodeOp]) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isBitwiseOperator(operator) {\n  return !!bitshiftOperators[operator] || operator === \"|\" || operator === \"^\" || operator === \"&\";\n} // Tests if an expression starts with `{`, or (if forbidFunctionClassAndDoExpr\n// holds) `function`, `class`, or `do {}`. Will be overzealous if there's\n// already necessary grouping parentheses.\n\n\nfunction startsWithNoLookaheadToken(node, forbidFunctionClassAndDoExpr) {\n  node = getLeftMost(node);\n\n  switch (node.type) {\n    case \"FunctionExpression\":\n    case \"ClassExpression\":\n    case \"DoExpression\":\n      return forbidFunctionClassAndDoExpr;\n\n    case \"ObjectExpression\":\n      return true;\n\n    case \"MemberExpression\":\n      return startsWithNoLookaheadToken(node.object, forbidFunctionClassAndDoExpr);\n\n    case \"TaggedTemplateExpression\":\n      if (node.tag.type === \"FunctionExpression\") {\n        // IIFEs are always already parenthesized\n        return false;\n      }\n\n      return startsWithNoLookaheadToken(node.tag, forbidFunctionClassAndDoExpr);\n\n    case \"CallExpression\":\n      if (node.callee.type === \"FunctionExpression\") {\n        // IIFEs are always already parenthesized\n        return false;\n      }\n\n      return startsWithNoLookaheadToken(node.callee, forbidFunctionClassAndDoExpr);\n\n    case \"ConditionalExpression\":\n      return startsWithNoLookaheadToken(node.test, forbidFunctionClassAndDoExpr);\n\n    case \"UpdateExpression\":\n      return !node.prefix && startsWithNoLookaheadToken(node.argument, forbidFunctionClassAndDoExpr);\n\n    case \"BindExpression\":\n      return node.object && startsWithNoLookaheadToken(node.object, forbidFunctionClassAndDoExpr);\n\n    case \"SequenceExpression\":\n      return startsWithNoLookaheadToken(node.expressions[0], forbidFunctionClassAndDoExpr);\n\n    case \"TSAsExpression\":\n      return startsWithNoLookaheadToken(node.expression, forbidFunctionClassAndDoExpr);\n\n    default:\n      return false;\n  }\n}\n\nfunction getLeftMost(node) {\n  if (node.left) {\n    return getLeftMost(node.left);\n  }\n\n  return node;\n}\n\nfunction getAlignmentSize(value, tabWidth, startIndex) {\n  startIndex = startIndex || 0;\n  var size = 0;\n\n  for (var i = startIndex; i < value.length; ++i) {\n    if (value[i] === \"\\t\") {\n      // Tabs behave in a way that they are aligned to the nearest\n      // multiple of tabWidth:\n      // 0 -> 4, 1 -> 4, 2 -> 4, 3 -> 4\n      // 4 -> 8, 5 -> 8, 6 -> 8, 7 -> 8 ...\n      size = size + tabWidth - size % tabWidth;\n    } else {\n      size++;\n    }\n  }\n\n  return size;\n}\n\nfunction getIndentSize(value, tabWidth) {\n  var lastNewlineIndex = value.lastIndexOf(\"\\n\");\n\n  if (lastNewlineIndex === -1) {\n    return 0;\n  }\n\n  return getAlignmentSize( // All the leading whitespaces\n  value.slice(lastNewlineIndex + 1).match(/^[ \\t]*/)[0], tabWidth);\n}\n\nfunction getPreferredQuote(raw, preferredQuote) {\n  // `rawContent` is the string exactly like it appeared in the input source\n  // code, without its enclosing quotes.\n  var rawContent = raw;\n  var _double = {\n    quote: '\"',\n    regex: /\"/g\n  };\n  var single = {\n    quote: \"'\",\n    regex: /'/g\n  };\n  var preferred = preferredQuote === \"'\" ? single : _double;\n  var alternate = preferred === single ? _double : single;\n  var result = preferred.quote; // If `rawContent` contains at least one of the quote preferred for enclosing\n  // the string, we might want to enclose with the alternate quote instead, to\n  // minimize the number of escaped quotes.\n\n  if (rawContent.includes(preferred.quote) || rawContent.includes(alternate.quote)) {\n    var numPreferredQuotes = (rawContent.match(preferred.regex) || []).length;\n    var numAlternateQuotes = (rawContent.match(alternate.regex) || []).length;\n    result = numPreferredQuotes > numAlternateQuotes ? alternate.quote : preferred.quote;\n  }\n\n  return result;\n}\n\nfunction printString(raw, options, isDirectiveLiteral) {\n  // `rawContent` is the string exactly like it appeared in the input source\n  // code, without its enclosing quotes.\n  var rawContent = raw; // Check for the alternate quote, to determine if we're allowed to swap\n  // the quotes on a DirectiveLiteral.\n\n  var canChangeDirectiveQuotes = !rawContent.includes('\"') && !rawContent.includes(\"'\");\n  var enclosingQuote = options.parser === \"json\" ? '\"' : options.__isInHtmlAttribute ? \"'\" : getPreferredQuote(raw, options.singleQuote ? \"'\" : '\"'); // Directives are exact code unit sequences, which means that you can't\n  // change the escape sequences they use.\n  // See https://github.com/prettier/prettier/issues/1555\n  // and https://tc39.github.io/ecma262/#directive-prologue\n\n  if (isDirectiveLiteral) {\n    if (canChangeDirectiveQuotes) {\n      return enclosingQuote + rawContent + enclosingQuote;\n    }\n\n    return raw;\n  } // It might sound unnecessary to use `makeString` even if the string already\n  // is enclosed with `enclosingQuote`, but it isn't. The string could contain\n  // unnecessary escapes (such as in `\"\\'\"`). Always using `makeString` makes\n  // sure that we consistently output the minimum amount of escaped quotes.\n\n\n  return makeString(rawContent, enclosingQuote, !(options.parser === \"css\" || options.parser === \"less\" || options.parser === \"scss\" || options.embeddedInHtml));\n}\n\nfunction makeString(rawContent, enclosingQuote, unescapeUnnecessaryEscapes) {\n  var otherQuote = enclosingQuote === '\"' ? \"'\" : '\"'; // Matches _any_ escape and unescaped quotes (both single and double).\n\n  var regex = /\\\\([\\s\\S])|(['\"])/g; // Escape and unescape single and double quotes as needed to be able to\n  // enclose `rawContent` with `enclosingQuote`.\n\n  var newContent = rawContent.replace(regex, function (match, escaped, quote) {\n    // If we matched an escape, and the escaped character is a quote of the\n    // other type than we intend to enclose the string with, there's no need for\n    // it to be escaped, so return it _without_ the backslash.\n    if (escaped === otherQuote) {\n      return escaped;\n    } // If we matched an unescaped quote and it is of the _same_ type as we\n    // intend to enclose the string with, it must be escaped, so return it with\n    // a backslash.\n\n\n    if (quote === enclosingQuote) {\n      return \"\\\\\" + quote;\n    }\n\n    if (quote) {\n      return quote;\n    } // Unescape any unnecessarily escaped character.\n    // Adapted from https://github.com/eslint/eslint/blob/de0b4ad7bd820ade41b1f606008bea68683dc11a/lib/rules/no-useless-escape.js#L27\n\n\n    return unescapeUnnecessaryEscapes && /^[^\\\\nrvtbfux\\r\\n\\u2028\\u2029\"'0-7]$/.test(escaped) ? escaped : \"\\\\\" + escaped;\n  });\n  return enclosingQuote + newContent + enclosingQuote;\n}\n\nfunction printNumber(rawNumber) {\n  return rawNumber.toLowerCase() // Remove unnecessary plus and zeroes from scientific notation.\n  .replace(/^([+-]?[\\d.]+e)(?:\\+|(-))?0*(\\d)/, \"$1$2$3\") // Remove unnecessary scientific notation (1e0).\n  .replace(/^([+-]?[\\d.]+)e[+-]?0+$/, \"$1\") // Make sure numbers always start with a digit.\n  .replace(/^([+-])?\\./, \"$10.\") // Remove extraneous trailing decimal zeroes.\n  .replace(/(\\.\\d+?)0+(?=e|$)/, \"$1\") // Remove trailing dot.\n  .replace(/\\.(?=e|$)/, \"\");\n}\n\nfunction getMaxContinuousCount(str, target) {\n  var results = str.match(new RegExp(\"(\".concat(escapeStringRegexp(target), \")+\"), \"g\"));\n\n  if (results === null) {\n    return 0;\n  }\n\n  return results.reduce(function (maxCount, result) {\n    return Math.max(maxCount, result.length / target.length);\n  }, 0);\n}\n\nfunction getMinNotPresentContinuousCount(str, target) {\n  var matches = str.match(new RegExp(\"(\".concat(escapeStringRegexp(target), \")+\"), \"g\"));\n\n  if (matches === null) {\n    return 0;\n  }\n\n  var countPresent = new Map();\n  var max = 0;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = matches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var match = _step.value;\n      var count = match.length / target.length;\n      countPresent.set(count, true);\n\n      if (count > max) {\n        max = count;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  for (var i = 1; i < max; i++) {\n    if (!countPresent.get(i)) {\n      return i;\n    }\n  }\n\n  return max + 1;\n}\n\nfunction getStringWidth(text) {\n  if (!text) {\n    return 0;\n  } // shortcut to avoid needless string `RegExp`s, replacements, and allocations within `string-width`\n\n\n  if (!notAsciiRegex.test(text)) {\n    return text.length;\n  }\n\n  return stringWidth(text);\n}\n\nfunction hasIgnoreComment(path) {\n  var node = path.getValue();\n  return hasNodeIgnoreComment(node);\n}\n\nfunction hasNodeIgnoreComment(node) {\n  return node && node.comments && node.comments.length > 0 && node.comments.some(function (comment) {\n    return comment.value.trim() === \"prettier-ignore\";\n  });\n}\n\nfunction matchAncestorTypes(path, types, index) {\n  index = index || 0;\n  types = types.slice();\n\n  while (types.length) {\n    var parent = path.getParentNode(index);\n    var type = types.shift();\n\n    if (!parent || parent.type !== type) {\n      return false;\n    }\n\n    index++;\n  }\n\n  return true;\n}\n\nfunction addCommentHelper(node, comment) {\n  var comments = node.comments || (node.comments = []);\n  comments.push(comment);\n  comment.printed = false; // For some reason, TypeScript parses `// x` inside of JSXText as a comment\n  // We already \"print\" it via the raw text, we don't need to re-print it as a\n  // comment\n\n  if (node.type === \"JSXText\") {\n    comment.printed = true;\n  }\n}\n\nfunction addLeadingComment(node, comment) {\n  comment.leading = true;\n  comment.trailing = false;\n  addCommentHelper(node, comment);\n}\n\nfunction addDanglingComment(node, comment) {\n  comment.leading = false;\n  comment.trailing = false;\n  addCommentHelper(node, comment);\n}\n\nfunction addTrailingComment(node, comment) {\n  comment.leading = false;\n  comment.trailing = true;\n  addCommentHelper(node, comment);\n}\n\nfunction isWithinParentArrayProperty(path, propertyName) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n\n  if (parent == null) {\n    return false;\n  }\n\n  if (!Array.isArray(parent[propertyName])) {\n    return false;\n  }\n\n  var key = path.getName();\n  return parent[propertyName][key] === node;\n}\n\nfunction replaceEndOfLineWith(text, replacement) {\n  var parts = [];\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = text.split(\"\\n\")[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var part = _step2.value;\n\n      if (parts.length !== 0) {\n        parts.push(replacement);\n      }\n\n      parts.push(part);\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n        _iterator2[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return parts;\n}\n\nmodule.exports = {\n  replaceEndOfLineWith: replaceEndOfLineWith,\n  getStringWidth: getStringWidth,\n  getMaxContinuousCount: getMaxContinuousCount,\n  getMinNotPresentContinuousCount: getMinNotPresentContinuousCount,\n  getPrecedence: getPrecedence,\n  shouldFlatten: shouldFlatten,\n  isBitwiseOperator: isBitwiseOperator,\n  isExportDeclaration: isExportDeclaration,\n  getParentExportDeclaration: getParentExportDeclaration,\n  getPenultimate: getPenultimate,\n  getLast: getLast,\n  getNextNonSpaceNonCommentCharacterIndexWithStartIndex: getNextNonSpaceNonCommentCharacterIndexWithStartIndex,\n  getNextNonSpaceNonCommentCharacterIndex: getNextNonSpaceNonCommentCharacterIndex,\n  getNextNonSpaceNonCommentCharacter: getNextNonSpaceNonCommentCharacter,\n  skip: skip,\n  skipWhitespace: skipWhitespace,\n  skipSpaces: skipSpaces,\n  skipToLineEnd: skipToLineEnd,\n  skipEverythingButNewLine: skipEverythingButNewLine,\n  skipInlineComment: skipInlineComment,\n  skipTrailingComment: skipTrailingComment,\n  skipNewline: skipNewline,\n  isNextLineEmptyAfterIndex: isNextLineEmptyAfterIndex,\n  isNextLineEmpty: isNextLineEmpty,\n  isPreviousLineEmpty: isPreviousLineEmpty,\n  hasNewline: hasNewline,\n  hasNewlineInRange: hasNewlineInRange,\n  hasSpaces: hasSpaces,\n  setLocStart: setLocStart,\n  setLocEnd: setLocEnd,\n  startsWithNoLookaheadToken: startsWithNoLookaheadToken,\n  getAlignmentSize: getAlignmentSize,\n  getIndentSize: getIndentSize,\n  getPreferredQuote: getPreferredQuote,\n  printString: printString,\n  printNumber: printNumber,\n  hasIgnoreComment: hasIgnoreComment,\n  hasNodeIgnoreComment: hasNodeIgnoreComment,\n  makeString: makeString,\n  matchAncestorTypes: matchAncestorTypes,\n  addLeadingComment: addLeadingComment,\n  addDanglingComment: addDanglingComment,\n  addTrailingComment: addTrailingComment,\n  isWithinParentArrayProperty: isWithinParentArrayProperty\n};"]},"metadata":{},"sourceType":"script"}