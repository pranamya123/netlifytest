{"ast":null,"code":"\"use strict\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar normalizePath = require(\"normalize-path\");\n\nvar UndefinedParserError = require(\"../common/errors\").UndefinedParserError;\n\nvar getSupportInfo = require(\"../main/support\").getSupportInfo;\n\nvar normalizer = require(\"./options-normalizer\");\n\nvar resolveParser = require(\"./parser\").resolveParser;\n\nvar hiddenDefaults = {\n  astFormat: \"estree\",\n  printer: {},\n  originalText: undefined,\n  locStart: null,\n  locEnd: null\n}; // Copy options and fill in default values.\n\nfunction normalize(options, opts) {\n  opts = opts || {};\n  var rawOptions = Object.assign({}, options);\n  var supportOptions = getSupportInfo(null, {\n    plugins: options.plugins,\n    showUnreleased: true,\n    showDeprecated: true\n  }).options;\n  var defaults = supportOptions.reduce(function (reduced, optionInfo) {\n    return optionInfo[\"default\"] !== undefined ? Object.assign(reduced, _defineProperty({}, optionInfo.name, optionInfo[\"default\"])) : reduced;\n  }, Object.assign({}, hiddenDefaults));\n\n  if (!rawOptions.parser) {\n    if (!rawOptions.filepath) {\n      var logger = opts.logger || console;\n      logger.warn(\"No parser and no filepath given, using 'babel' the parser now \" + \"but this will throw an error in the future. \" + \"Please specify a parser or a filepath so one can be inferred.\");\n      rawOptions.parser = \"babel\";\n    } else {\n      rawOptions.parser = inferParser(rawOptions.filepath, rawOptions.plugins);\n\n      if (!rawOptions.parser) {\n        throw new UndefinedParserError(\"No parser could be inferred for file: \".concat(rawOptions.filepath));\n      }\n    }\n  }\n\n  var parser = resolveParser(normalizer.normalizeApiOptions(rawOptions, [supportOptions.find(function (x) {\n    return x.name === \"parser\";\n  })], {\n    passThrough: true,\n    logger: false\n  }));\n  rawOptions.astFormat = parser.astFormat;\n  rawOptions.locEnd = parser.locEnd;\n  rawOptions.locStart = parser.locStart;\n  var plugin = getPlugin(rawOptions);\n  rawOptions.printer = plugin.printers[rawOptions.astFormat];\n  var pluginDefaults = supportOptions.filter(function (optionInfo) {\n    return optionInfo.pluginDefaults && optionInfo.pluginDefaults[plugin.name] !== undefined;\n  }).reduce(function (reduced, optionInfo) {\n    return Object.assign(reduced, _defineProperty({}, optionInfo.name, optionInfo.pluginDefaults[plugin.name]));\n  }, {});\n  var mixedDefaults = Object.assign({}, defaults, pluginDefaults);\n  Object.keys(mixedDefaults).forEach(function (k) {\n    if (rawOptions[k] == null) {\n      rawOptions[k] = mixedDefaults[k];\n    }\n  });\n\n  if (rawOptions.parser === \"json\") {\n    rawOptions.trailingComma = \"none\";\n  }\n\n  return normalizer.normalizeApiOptions(rawOptions, supportOptions, Object.assign({\n    passThrough: Object.keys(hiddenDefaults)\n  }, opts));\n}\n\nfunction getPlugin(options) {\n  var astFormat = options.astFormat;\n\n  if (!astFormat) {\n    throw new Error(\"getPlugin() requires astFormat to be set\");\n  }\n\n  var printerPlugin = options.plugins.find(function (plugin) {\n    return plugin.printers && plugin.printers[astFormat];\n  });\n\n  if (!printerPlugin) {\n    throw new Error(\"Couldn't find plugin for AST format \\\"\".concat(astFormat, \"\\\"\"));\n  }\n\n  return printerPlugin;\n}\n\nfunction getInterpreter() {\n  return \"\";\n}\n\nfunction inferParser(filepath, plugins) {\n  var filepathParts = normalizePath(filepath).split(\"/\");\n  var filename = filepathParts[filepathParts.length - 1].toLowerCase(); // If the file has no extension, we can try to infer the language from the\n  // interpreter in the shebang line, if any; but since this requires FS access,\n  // do it last.\n\n  var language = getSupportInfo(null, {\n    plugins: plugins\n  }).languages.find(function (language) {\n    return language.since !== null && (language.extensions && language.extensions.some(function (extension) {\n      return filename.endsWith(extension);\n    }) || language.filenames && language.filenames.find(function (name) {\n      return name.toLowerCase() === filename;\n    }) || filename.indexOf(\".\") === -1 && language.interpreters && language.interpreters.indexOf(getInterpreter(filepath)) !== -1);\n  });\n  return language && language.parsers[0];\n}\n\nmodule.exports = {\n  normalize: normalize,\n  hiddenDefaults: hiddenDefaults,\n  inferParser: inferParser\n};","map":{"version":3,"sources":["/Users/pranamyavadlamani/Desktop/Research/PortFolio/portfolio-site/node_modules/@miksu/prettier/lib/main/options.js"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","normalizePath","require","UndefinedParserError","getSupportInfo","normalizer","resolveParser","hiddenDefaults","astFormat","printer","originalText","undefined","locStart","locEnd","normalize","options","opts","rawOptions","assign","supportOptions","plugins","showUnreleased","showDeprecated","defaults","reduce","reduced","optionInfo","name","parser","filepath","logger","console","warn","inferParser","concat","normalizeApiOptions","find","x","passThrough","plugin","getPlugin","printers","pluginDefaults","filter","mixedDefaults","keys","forEach","k","trailingComma","Error","printerPlugin","getInterpreter","filepathParts","split","filename","length","toLowerCase","language","languages","since","extensions","some","extension","endsWith","filenames","indexOf","interpreters","parsers","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar normalizePath = require(\"normalize-path\");\n\nvar UndefinedParserError = require(\"../common/errors\").UndefinedParserError;\n\nvar getSupportInfo = require(\"../main/support\").getSupportInfo;\n\nvar normalizer = require(\"./options-normalizer\");\n\nvar resolveParser = require(\"./parser\").resolveParser;\n\nvar hiddenDefaults = {\n  astFormat: \"estree\",\n  printer: {},\n  originalText: undefined,\n  locStart: null,\n  locEnd: null\n}; // Copy options and fill in default values.\n\nfunction normalize(options, opts) {\n  opts = opts || {};\n  var rawOptions = Object.assign({}, options);\n  var supportOptions = getSupportInfo(null, {\n    plugins: options.plugins,\n    showUnreleased: true,\n    showDeprecated: true\n  }).options;\n  var defaults = supportOptions.reduce(function (reduced, optionInfo) {\n    return optionInfo[\"default\"] !== undefined ? Object.assign(reduced, _defineProperty({}, optionInfo.name, optionInfo[\"default\"])) : reduced;\n  }, Object.assign({}, hiddenDefaults));\n\n  if (!rawOptions.parser) {\n    if (!rawOptions.filepath) {\n      var logger = opts.logger || console;\n      logger.warn(\"No parser and no filepath given, using 'babel' the parser now \" + \"but this will throw an error in the future. \" + \"Please specify a parser or a filepath so one can be inferred.\");\n      rawOptions.parser = \"babel\";\n    } else {\n      rawOptions.parser = inferParser(rawOptions.filepath, rawOptions.plugins);\n\n      if (!rawOptions.parser) {\n        throw new UndefinedParserError(\"No parser could be inferred for file: \".concat(rawOptions.filepath));\n      }\n    }\n  }\n\n  var parser = resolveParser(normalizer.normalizeApiOptions(rawOptions, [supportOptions.find(function (x) {\n    return x.name === \"parser\";\n  })], {\n    passThrough: true,\n    logger: false\n  }));\n  rawOptions.astFormat = parser.astFormat;\n  rawOptions.locEnd = parser.locEnd;\n  rawOptions.locStart = parser.locStart;\n  var plugin = getPlugin(rawOptions);\n  rawOptions.printer = plugin.printers[rawOptions.astFormat];\n  var pluginDefaults = supportOptions.filter(function (optionInfo) {\n    return optionInfo.pluginDefaults && optionInfo.pluginDefaults[plugin.name] !== undefined;\n  }).reduce(function (reduced, optionInfo) {\n    return Object.assign(reduced, _defineProperty({}, optionInfo.name, optionInfo.pluginDefaults[plugin.name]));\n  }, {});\n  var mixedDefaults = Object.assign({}, defaults, pluginDefaults);\n  Object.keys(mixedDefaults).forEach(function (k) {\n    if (rawOptions[k] == null) {\n      rawOptions[k] = mixedDefaults[k];\n    }\n  });\n\n  if (rawOptions.parser === \"json\") {\n    rawOptions.trailingComma = \"none\";\n  }\n\n  return normalizer.normalizeApiOptions(rawOptions, supportOptions, Object.assign({\n    passThrough: Object.keys(hiddenDefaults)\n  }, opts));\n}\n\nfunction getPlugin(options) {\n  var astFormat = options.astFormat;\n\n  if (!astFormat) {\n    throw new Error(\"getPlugin() requires astFormat to be set\");\n  }\n\n  var printerPlugin = options.plugins.find(function (plugin) {\n    return plugin.printers && plugin.printers[astFormat];\n  });\n\n  if (!printerPlugin) {\n    throw new Error(\"Couldn't find plugin for AST format \\\"\".concat(astFormat, \"\\\"\"));\n  }\n\n  return printerPlugin;\n}\n\nfunction getInterpreter() {\n  return \"\";\n}\n\nfunction inferParser(filepath, plugins) {\n  var filepathParts = normalizePath(filepath).split(\"/\");\n  var filename = filepathParts[filepathParts.length - 1].toLowerCase(); // If the file has no extension, we can try to infer the language from the\n  // interpreter in the shebang line, if any; but since this requires FS access,\n  // do it last.\n\n  var language = getSupportInfo(null, {\n    plugins: plugins\n  }).languages.find(function (language) {\n    return language.since !== null && (language.extensions && language.extensions.some(function (extension) {\n      return filename.endsWith(extension);\n    }) || language.filenames && language.filenames.find(function (name) {\n      return name.toLowerCase() === filename;\n    }) || filename.indexOf(\".\") === -1 && language.interpreters && language.interpreters.indexOf(getInterpreter(filepath)) !== -1);\n  });\n  return language && language.parsers[0];\n}\n\nmodule.exports = {\n  normalize: normalize,\n  hiddenDefaults: hiddenDefaults,\n  inferParser: inferParser\n};"]},"metadata":{},"sourceType":"script"}