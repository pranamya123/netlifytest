{"ast":null,"code":"\"use strict\"; // We match any whitespace except line terminators because\n// Flow annotation comments cannot be split across lines. For example:\n//\n// (this /*\n// : any */).foo = 5;\n//\n// is not picked up by Flow (see https://github.com/facebook/flow/issues/7050), so\n// removing the newline would create a type annotation that the user did not intend\n// to create.\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar NON_LINE_TERMINATING_WHITE_SPACE = \"(?:(?=.)\\\\s)\";\nvar FLOW_SHORTHAND_ANNOTATION = new RegExp(\"^\".concat(NON_LINE_TERMINATING_WHITE_SPACE, \"*:\"));\nvar FLOW_ANNOTATION = new RegExp(\"^\".concat(NON_LINE_TERMINATING_WHITE_SPACE, \"*::\"));\n\nfunction hasFlowShorthandAnnotationComment(node) {\n  // https://flow.org/en/docs/types/comments/\n  // Syntax example: const r = new (window.Request /*: Class<Request> */)(\"\");\n  return node.extra && node.extra.parenthesized && node.trailingComments && node.trailingComments[0].value.match(FLOW_SHORTHAND_ANNOTATION);\n}\n\nfunction hasFlowAnnotationComment(comments) {\n  return comments && comments[0].value.match(FLOW_ANNOTATION);\n}\n\nfunction hasNode(node, fn) {\n  if (!node || _typeof(node) !== \"object\") {\n    return false;\n  }\n\n  if (Array.isArray(node)) {\n    return node.some(function (value) {\n      return hasNode(value, fn);\n    });\n  }\n\n  var result = fn(node);\n  return typeof result === \"boolean\" ? result : Object.keys(node).some(function (key) {\n    return hasNode(node[key], fn);\n  });\n}\n\nfunction hasNakedLeftSide(node) {\n  return node.type === \"AssignmentExpression\" || node.type === \"BinaryExpression\" || node.type === \"LogicalExpression\" || node.type === \"NGPipeExpression\" || node.type === \"ConditionalExpression\" || node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\" || node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\" || node.type === \"SequenceExpression\" || node.type === \"TaggedTemplateExpression\" || node.type === \"BindExpression\" || node.type === \"UpdateExpression\" && !node.prefix || node.type === \"TSAsExpression\" || node.type === \"TSNonNullExpression\";\n}\n\nfunction getLeftSide(node) {\n  if (node.expressions) {\n    return node.expressions[0];\n  }\n\n  return node.left || node.test || node.callee || node.object || node.tag || node.argument || node.expression;\n}\n\nfunction getLeftSidePathName(path, node) {\n  if (node.expressions) {\n    return [\"expressions\", 0];\n  }\n\n  if (node.left) {\n    return [\"left\"];\n  }\n\n  if (node.test) {\n    return [\"test\"];\n  }\n\n  if (node.object) {\n    return [\"object\"];\n  }\n\n  if (node.callee) {\n    return [\"callee\"];\n  }\n\n  if (node.tag) {\n    return [\"tag\"];\n  }\n\n  if (node.argument) {\n    return [\"argument\"];\n  }\n\n  if (node.expression) {\n    return [\"expression\"];\n  }\n\n  throw new Error(\"Unexpected node has no left side\", node);\n}\n\nmodule.exports = {\n  getLeftSide: getLeftSide,\n  getLeftSidePathName: getLeftSidePathName,\n  hasNakedLeftSide: hasNakedLeftSide,\n  hasNode: hasNode,\n  hasFlowShorthandAnnotationComment: hasFlowShorthandAnnotationComment,\n  hasFlowAnnotationComment: hasFlowAnnotationComment\n};","map":{"version":3,"sources":["/Users/pranamyavadlamani/Desktop/Research/PortFolio/portfolio-site/node_modules/@miksu/prettier/lib/language-js/utils.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","NON_LINE_TERMINATING_WHITE_SPACE","FLOW_SHORTHAND_ANNOTATION","RegExp","concat","FLOW_ANNOTATION","hasFlowShorthandAnnotationComment","node","extra","parenthesized","trailingComments","value","match","hasFlowAnnotationComment","comments","hasNode","fn","Array","isArray","some","result","Object","keys","key","hasNakedLeftSide","type","prefix","getLeftSide","expressions","left","test","callee","object","tag","argument","expression","getLeftSidePathName","path","Error","module","exports"],"mappings":"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","sourcesContent":["\"use strict\"; // We match any whitespace except line terminators because\n// Flow annotation comments cannot be split across lines. For example:\n//\n// (this /*\n// : any */).foo = 5;\n//\n// is not picked up by Flow (see https://github.com/facebook/flow/issues/7050), so\n// removing the newline would create a type annotation that the user did not intend\n// to create.\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar NON_LINE_TERMINATING_WHITE_SPACE = \"(?:(?=.)\\\\s)\";\nvar FLOW_SHORTHAND_ANNOTATION = new RegExp(\"^\".concat(NON_LINE_TERMINATING_WHITE_SPACE, \"*:\"));\nvar FLOW_ANNOTATION = new RegExp(\"^\".concat(NON_LINE_TERMINATING_WHITE_SPACE, \"*::\"));\n\nfunction hasFlowShorthandAnnotationComment(node) {\n  // https://flow.org/en/docs/types/comments/\n  // Syntax example: const r = new (window.Request /*: Class<Request> */)(\"\");\n  return node.extra && node.extra.parenthesized && node.trailingComments && node.trailingComments[0].value.match(FLOW_SHORTHAND_ANNOTATION);\n}\n\nfunction hasFlowAnnotationComment(comments) {\n  return comments && comments[0].value.match(FLOW_ANNOTATION);\n}\n\nfunction hasNode(node, fn) {\n  if (!node || _typeof(node) !== \"object\") {\n    return false;\n  }\n\n  if (Array.isArray(node)) {\n    return node.some(function (value) {\n      return hasNode(value, fn);\n    });\n  }\n\n  var result = fn(node);\n  return typeof result === \"boolean\" ? result : Object.keys(node).some(function (key) {\n    return hasNode(node[key], fn);\n  });\n}\n\nfunction hasNakedLeftSide(node) {\n  return node.type === \"AssignmentExpression\" || node.type === \"BinaryExpression\" || node.type === \"LogicalExpression\" || node.type === \"NGPipeExpression\" || node.type === \"ConditionalExpression\" || node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\" || node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\" || node.type === \"SequenceExpression\" || node.type === \"TaggedTemplateExpression\" || node.type === \"BindExpression\" || node.type === \"UpdateExpression\" && !node.prefix || node.type === \"TSAsExpression\" || node.type === \"TSNonNullExpression\";\n}\n\nfunction getLeftSide(node) {\n  if (node.expressions) {\n    return node.expressions[0];\n  }\n\n  return node.left || node.test || node.callee || node.object || node.tag || node.argument || node.expression;\n}\n\nfunction getLeftSidePathName(path, node) {\n  if (node.expressions) {\n    return [\"expressions\", 0];\n  }\n\n  if (node.left) {\n    return [\"left\"];\n  }\n\n  if (node.test) {\n    return [\"test\"];\n  }\n\n  if (node.object) {\n    return [\"object\"];\n  }\n\n  if (node.callee) {\n    return [\"callee\"];\n  }\n\n  if (node.tag) {\n    return [\"tag\"];\n  }\n\n  if (node.argument) {\n    return [\"argument\"];\n  }\n\n  if (node.expression) {\n    return [\"expression\"];\n  }\n\n  throw new Error(\"Unexpected node has no left side\", node);\n}\n\nmodule.exports = {\n  getLeftSide: getLeftSide,\n  getLeftSidePathName: getLeftSidePathName,\n  hasNakedLeftSide: hasNakedLeftSide,\n  hasNode: hasNode,\n  hasFlowShorthandAnnotationComment: hasFlowShorthandAnnotationComment,\n  hasFlowAnnotationComment: hasFlowAnnotationComment\n};"]},"metadata":{},"sourceType":"script"}