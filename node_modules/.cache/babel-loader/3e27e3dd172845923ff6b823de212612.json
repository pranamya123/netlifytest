{"ast":null,"code":"\"use strict\";\n\nvar diff = require(\"diff\");\n\nvar normalizeOptions = require(\"./options\").normalize;\n\nvar massageAST = require(\"./massage-ast\");\n\nvar comments = require(\"./comments\");\n\nvar parser = require(\"./parser\");\n\nvar printAstToDoc = require(\"./ast-to-doc\");\n\nvar _require = require(\"../common/end-of-line\"),\n    guessEndOfLine = _require.guessEndOfLine,\n    convertEndOfLineToChars = _require.convertEndOfLineToChars;\n\nvar rangeUtil = require(\"./range-util\");\n\nvar privateUtil = require(\"../common/util\");\n\nvar _require2 = require(\"../doc\"),\n    mapDoc = _require2.utils.mapDoc,\n    _printDocToString = _require2.printer.printDocToString,\n    printDocToDebug = _require2.debug.printDocToDebug;\n\nvar UTF8BOM = 0xfeff;\nvar CURSOR = Symbol(\"cursor\");\nvar PLACEHOLDERS = {\n  cursorOffset: \"<<<PRETTIER_CURSOR>>>\",\n  rangeStart: \"<<<PRETTIER_RANGE_START>>>\",\n  rangeEnd: \"<<<PRETTIER_RANGE_END>>>\"\n};\n\nfunction ensureAllCommentsPrinted(astComments) {\n  if (!astComments) {\n    return;\n  }\n\n  for (var i = 0; i < astComments.length; ++i) {\n    if (astComments[i].value.trim() === \"prettier-ignore\") {\n      // If there's a prettier-ignore, we're not printing that sub-tree so we\n      // don't know if the comments was printed or not.\n      return;\n    }\n  }\n\n  astComments.forEach(function (comment) {\n    if (!comment.printed) {\n      throw new Error('Comment \"' + comment.value.trim() + '\" was not printed. Please report this error!');\n    }\n\n    delete comment.printed;\n  });\n}\n\nfunction attachComments(text, ast, opts) {\n  var astComments = ast.comments;\n\n  if (astComments) {\n    delete ast.comments;\n    comments.attach(astComments, ast, text, opts);\n  }\n\n  ast.tokens = [];\n  opts.originalText = opts.parser === \"yaml\" ? text : text.trimRight();\n  return astComments;\n}\n\nfunction coreFormat(text, opts, addAlignmentSize) {\n  if (!text || !text.trim().length) {\n    return {\n      formatted: \"\",\n      cursorOffset: 0\n    };\n  }\n\n  addAlignmentSize = addAlignmentSize || 0;\n  var parsed = parser.parse(text, opts);\n  var ast = parsed.ast;\n  text = parsed.text;\n\n  if (opts.cursorOffset >= 0) {\n    var nodeResult = rangeUtil.findNodeAtOffset(ast, opts.cursorOffset, opts);\n\n    if (nodeResult && nodeResult.node) {\n      opts.cursorNode = nodeResult.node;\n    }\n  }\n\n  var astComments = attachComments(text, ast, opts);\n  var doc = printAstToDoc(ast, opts, addAlignmentSize);\n  var eol = convertEndOfLineToChars(opts.endOfLine);\n\n  var result = _printDocToString(opts.endOfLine === \"lf\" ? doc : mapDoc(doc, function (currentDoc) {\n    return typeof currentDoc === \"string\" && currentDoc.indexOf(\"\\n\") !== -1 ? currentDoc.replace(/\\n/g, eol) : currentDoc;\n  }), opts);\n\n  ensureAllCommentsPrinted(astComments); // Remove extra leading indentation as well as the added indentation after last newline\n\n  if (addAlignmentSize > 0) {\n    var trimmed = result.formatted.trim();\n\n    if (result.cursorNodeStart !== undefined) {\n      result.cursorNodeStart -= result.formatted.indexOf(trimmed);\n    }\n\n    result.formatted = trimmed + convertEndOfLineToChars(opts.endOfLine);\n  }\n\n  if (opts.cursorOffset >= 0) {\n    var oldCursorNodeStart;\n    var oldCursorNodeText;\n    var cursorOffsetRelativeToOldCursorNode;\n    var newCursorNodeStart;\n    var newCursorNodeText;\n\n    if (opts.cursorNode && result.cursorNodeText) {\n      oldCursorNodeStart = opts.locStart(opts.cursorNode);\n      oldCursorNodeText = text.slice(oldCursorNodeStart, opts.locEnd(opts.cursorNode));\n      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset - oldCursorNodeStart;\n      newCursorNodeStart = result.cursorNodeStart;\n      newCursorNodeText = result.cursorNodeText;\n    } else {\n      oldCursorNodeStart = 0;\n      oldCursorNodeText = text;\n      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset;\n      newCursorNodeStart = 0;\n      newCursorNodeText = result.formatted;\n    }\n\n    if (oldCursorNodeText === newCursorNodeText) {\n      return {\n        formatted: result.formatted,\n        cursorOffset: newCursorNodeStart + cursorOffsetRelativeToOldCursorNode\n      };\n    } // diff old and new cursor node texts, with a special cursor\n    // symbol inserted to find out where it moves to\n\n\n    var oldCursorNodeCharArray = oldCursorNodeText.split(\"\");\n    oldCursorNodeCharArray.splice(cursorOffsetRelativeToOldCursorNode, 0, CURSOR);\n    var newCursorNodeCharArray = newCursorNodeText.split(\"\");\n    var cursorNodeDiff = diff.diffArrays(oldCursorNodeCharArray, newCursorNodeCharArray);\n    var cursorOffset = newCursorNodeStart;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = cursorNodeDiff[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var entry = _step.value;\n\n        if (entry.removed) {\n          if (entry.value.indexOf(CURSOR) > -1) {\n            break;\n          }\n        } else {\n          cursorOffset += entry.count;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return {\n      formatted: result.formatted,\n      cursorOffset: cursorOffset\n    };\n  }\n\n  return {\n    formatted: result.formatted\n  };\n}\n\nfunction formatRange(text, opts) {\n  var parsed = parser.parse(text, opts);\n  var ast = parsed.ast;\n  text = parsed.text;\n  var range = rangeUtil.calculateRange(text, opts, ast);\n  var rangeStart = range.rangeStart;\n  var rangeEnd = range.rangeEnd;\n  var rangeString = text.slice(rangeStart, rangeEnd); // Try to extend the range backwards to the beginning of the line.\n  // This is so we can detect indentation correctly and restore it.\n  // Use `Math.min` since `lastIndexOf` returns 0 when `rangeStart` is 0\n\n  var rangeStart2 = Math.min(rangeStart, text.lastIndexOf(\"\\n\", rangeStart) + 1);\n  var indentString = text.slice(rangeStart2, rangeStart);\n  var alignmentSize = privateUtil.getAlignmentSize(indentString, opts.tabWidth);\n  var rangeResult = coreFormat(rangeString, Object.assign({}, opts, {\n    rangeStart: 0,\n    rangeEnd: Infinity,\n    // track the cursor offset only if it's within our range\n    cursorOffset: opts.cursorOffset >= rangeStart && opts.cursorOffset < rangeEnd ? opts.cursorOffset - rangeStart : -1\n  }), alignmentSize); // Since the range contracts to avoid trailing whitespace,\n  // we need to remove the newline that was inserted by the `format` call.\n\n  var rangeTrimmed = rangeResult.formatted.trimRight();\n  var rangeLeft = text.slice(0, rangeStart);\n  var rangeRight = text.slice(rangeEnd);\n  var cursorOffset = opts.cursorOffset;\n\n  if (opts.cursorOffset >= rangeEnd) {\n    // handle the case where the cursor was past the end of the range\n    cursorOffset = opts.cursorOffset - rangeEnd + (rangeStart + rangeTrimmed.length);\n  } else if (rangeResult.cursorOffset !== undefined) {\n    // handle the case where the cursor was in the range\n    cursorOffset = rangeResult.cursorOffset + rangeStart;\n  } // keep the cursor as it was if it was before the start of the range\n\n\n  var formatted;\n\n  if (opts.endOfLine === \"lf\") {\n    formatted = rangeLeft + rangeTrimmed + rangeRight;\n  } else {\n    var eol = convertEndOfLineToChars(opts.endOfLine);\n\n    if (cursorOffset >= 0) {\n      var parts = [rangeLeft, rangeTrimmed, rangeRight];\n      var partIndex = 0;\n      var partOffset = cursorOffset;\n\n      while (partIndex < parts.length) {\n        var part = parts[partIndex];\n\n        if (partOffset < part.length) {\n          parts[partIndex] = parts[partIndex].slice(0, partOffset) + PLACEHOLDERS.cursorOffset + parts[partIndex].slice(partOffset);\n          break;\n        }\n\n        partIndex++;\n        partOffset -= part.length;\n      }\n\n      var newRangeLeft = parts[0],\n          newRangeTrimmed = parts[1],\n          newRangeRight = parts[2];\n      formatted = (newRangeLeft.replace(/\\n/g, eol) + newRangeTrimmed + newRangeRight.replace(/\\n/g, eol)).replace(PLACEHOLDERS.cursorOffset, function (_, index) {\n        cursorOffset = index;\n        return \"\";\n      });\n    } else {\n      formatted = rangeLeft.replace(/\\n/g, eol) + rangeTrimmed + rangeRight.replace(/\\n/g, eol);\n    }\n  }\n\n  return {\n    formatted: formatted,\n    cursorOffset: cursorOffset\n  };\n}\n\nfunction format(text, opts) {\n  var selectedParser = parser.resolveParser(opts);\n  var hasPragma = !selectedParser.hasPragma || selectedParser.hasPragma(text);\n\n  if (opts.requirePragma && !hasPragma) {\n    return {\n      formatted: text\n    };\n  }\n\n  if (opts.endOfLine === \"auto\") {\n    opts.endOfLine = guessEndOfLine(text);\n  }\n\n  var hasCursor = opts.cursorOffset >= 0;\n  var hasRangeStart = opts.rangeStart > 0;\n  var hasRangeEnd = opts.rangeEnd < text.length; // get rid of CR/CRLF parsing\n\n  if (text.indexOf(\"\\r\") !== -1) {\n    var offsetKeys = [hasCursor && \"cursorOffset\", hasRangeStart && \"rangeStart\", hasRangeEnd && \"rangeEnd\"].filter(Boolean).sort(function (aKey, bKey) {\n      return opts[aKey] - opts[bKey];\n    });\n\n    for (var i = offsetKeys.length - 1; i >= 0; i--) {\n      var key = offsetKeys[i];\n      text = text.slice(0, opts[key]) + PLACEHOLDERS[key] + text.slice(opts[key]);\n    }\n\n    text = text.replace(/\\r\\n?/g, \"\\n\");\n\n    var _loop = function _loop(_i) {\n      var key = offsetKeys[_i];\n      text = text.replace(PLACEHOLDERS[key], function (_, index) {\n        opts[key] = index;\n        return \"\";\n      });\n    };\n\n    for (var _i = 0; _i < offsetKeys.length; _i++) {\n      _loop(_i);\n    }\n  }\n\n  var hasUnicodeBOM = text.charCodeAt(0) === UTF8BOM;\n\n  if (hasUnicodeBOM) {\n    text = text.substring(1);\n\n    if (hasCursor) {\n      opts.cursorOffset++;\n    }\n\n    if (hasRangeStart) {\n      opts.rangeStart++;\n    }\n\n    if (hasRangeEnd) {\n      opts.rangeEnd++;\n    }\n  }\n\n  if (!hasCursor) {\n    opts.cursorOffset = -1;\n  }\n\n  if (opts.rangeStart < 0) {\n    opts.rangeStart = 0;\n  }\n\n  if (opts.rangeEnd > text.length) {\n    opts.rangeEnd = text.length;\n  }\n\n  var result = hasRangeStart || hasRangeEnd ? formatRange(text, opts) : coreFormat(opts.insertPragma && opts.printer.insertPragma && !hasPragma ? opts.printer.insertPragma(text) : text, opts);\n\n  if (hasUnicodeBOM) {\n    result.formatted = String.fromCharCode(UTF8BOM) + result.formatted;\n\n    if (hasCursor) {\n      result.cursorOffset++;\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  formatWithCursor: function formatWithCursor(text, opts) {\n    opts = normalizeOptions(opts);\n    return format(text, opts);\n  },\n  parse: function parse(text, opts, massage) {\n    opts = normalizeOptions(opts);\n\n    if (text.indexOf(\"\\r\") !== -1) {\n      text = text.replace(/\\r\\n?/g, \"\\n\");\n    }\n\n    var parsed = parser.parse(text, opts);\n\n    if (massage) {\n      parsed.ast = massageAST(parsed.ast, opts);\n    }\n\n    return parsed;\n  },\n  formatAST: function formatAST(ast, opts) {\n    opts = normalizeOptions(opts);\n    var doc = printAstToDoc(ast, opts);\n    return _printDocToString(doc, opts);\n  },\n  // Doesn't handle shebang for now\n  formatDoc: function formatDoc(doc, opts) {\n    var debug = printDocToDebug(doc);\n    opts = normalizeOptions(Object.assign({}, opts, {\n      parser: \"babel\"\n    }));\n    return format(debug, opts).formatted;\n  },\n  printToDoc: function printToDoc(text, opts) {\n    opts = normalizeOptions(opts);\n    var parsed = parser.parse(text, opts);\n    var ast = parsed.ast;\n    text = parsed.text;\n    attachComments(text, ast, opts);\n    return printAstToDoc(ast, opts);\n  },\n  printDocToString: function printDocToString(doc, opts) {\n    return _printDocToString(doc, normalizeOptions(opts));\n  }\n};","map":{"version":3,"sources":["/Users/pranamyavadlamani/Desktop/Research/PortFolio/portfolio-site/node_modules/@miksu/prettier/lib/main/core.js"],"names":["diff","require","normalizeOptions","normalize","massageAST","comments","parser","printAstToDoc","_require","guessEndOfLine","convertEndOfLineToChars","rangeUtil","privateUtil","_require2","mapDoc","utils","_printDocToString","printer","printDocToString","printDocToDebug","debug","UTF8BOM","CURSOR","Symbol","PLACEHOLDERS","cursorOffset","rangeStart","rangeEnd","ensureAllCommentsPrinted","astComments","i","length","value","trim","forEach","comment","printed","Error","attachComments","text","ast","opts","attach","tokens","originalText","trimRight","coreFormat","addAlignmentSize","formatted","parsed","parse","nodeResult","findNodeAtOffset","node","cursorNode","doc","eol","endOfLine","result","currentDoc","indexOf","replace","trimmed","cursorNodeStart","undefined","oldCursorNodeStart","oldCursorNodeText","cursorOffsetRelativeToOldCursorNode","newCursorNodeStart","newCursorNodeText","cursorNodeText","locStart","slice","locEnd","oldCursorNodeCharArray","split","splice","newCursorNodeCharArray","cursorNodeDiff","diffArrays","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","iterator","_step","next","done","entry","removed","count","err","formatRange","range","calculateRange","rangeString","rangeStart2","Math","min","lastIndexOf","indentString","alignmentSize","getAlignmentSize","tabWidth","rangeResult","Object","assign","Infinity","rangeTrimmed","rangeLeft","rangeRight","parts","partIndex","partOffset","part","newRangeLeft","newRangeTrimmed","newRangeRight","_","index","format","selectedParser","resolveParser","hasPragma","requirePragma","hasCursor","hasRangeStart","hasRangeEnd","offsetKeys","filter","Boolean","sort","aKey","bKey","key","_loop","_i","hasUnicodeBOM","charCodeAt","substring","insertPragma","String","fromCharCode","module","exports","formatWithCursor","massage","formatAST","formatDoc","printToDoc"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar diff = require(\"diff\");\n\nvar normalizeOptions = require(\"./options\").normalize;\n\nvar massageAST = require(\"./massage-ast\");\n\nvar comments = require(\"./comments\");\n\nvar parser = require(\"./parser\");\n\nvar printAstToDoc = require(\"./ast-to-doc\");\n\nvar _require = require(\"../common/end-of-line\"),\n    guessEndOfLine = _require.guessEndOfLine,\n    convertEndOfLineToChars = _require.convertEndOfLineToChars;\n\nvar rangeUtil = require(\"./range-util\");\n\nvar privateUtil = require(\"../common/util\");\n\nvar _require2 = require(\"../doc\"),\n    mapDoc = _require2.utils.mapDoc,\n    _printDocToString = _require2.printer.printDocToString,\n    printDocToDebug = _require2.debug.printDocToDebug;\n\nvar UTF8BOM = 0xfeff;\nvar CURSOR = Symbol(\"cursor\");\nvar PLACEHOLDERS = {\n  cursorOffset: \"<<<PRETTIER_CURSOR>>>\",\n  rangeStart: \"<<<PRETTIER_RANGE_START>>>\",\n  rangeEnd: \"<<<PRETTIER_RANGE_END>>>\"\n};\n\nfunction ensureAllCommentsPrinted(astComments) {\n  if (!astComments) {\n    return;\n  }\n\n  for (var i = 0; i < astComments.length; ++i) {\n    if (astComments[i].value.trim() === \"prettier-ignore\") {\n      // If there's a prettier-ignore, we're not printing that sub-tree so we\n      // don't know if the comments was printed or not.\n      return;\n    }\n  }\n\n  astComments.forEach(function (comment) {\n    if (!comment.printed) {\n      throw new Error('Comment \"' + comment.value.trim() + '\" was not printed. Please report this error!');\n    }\n\n    delete comment.printed;\n  });\n}\n\nfunction attachComments(text, ast, opts) {\n  var astComments = ast.comments;\n\n  if (astComments) {\n    delete ast.comments;\n    comments.attach(astComments, ast, text, opts);\n  }\n\n  ast.tokens = [];\n  opts.originalText = opts.parser === \"yaml\" ? text : text.trimRight();\n  return astComments;\n}\n\nfunction coreFormat(text, opts, addAlignmentSize) {\n  if (!text || !text.trim().length) {\n    return {\n      formatted: \"\",\n      cursorOffset: 0\n    };\n  }\n\n  addAlignmentSize = addAlignmentSize || 0;\n  var parsed = parser.parse(text, opts);\n  var ast = parsed.ast;\n  text = parsed.text;\n\n  if (opts.cursorOffset >= 0) {\n    var nodeResult = rangeUtil.findNodeAtOffset(ast, opts.cursorOffset, opts);\n\n    if (nodeResult && nodeResult.node) {\n      opts.cursorNode = nodeResult.node;\n    }\n  }\n\n  var astComments = attachComments(text, ast, opts);\n  var doc = printAstToDoc(ast, opts, addAlignmentSize);\n  var eol = convertEndOfLineToChars(opts.endOfLine);\n\n  var result = _printDocToString(opts.endOfLine === \"lf\" ? doc : mapDoc(doc, function (currentDoc) {\n    return typeof currentDoc === \"string\" && currentDoc.indexOf(\"\\n\") !== -1 ? currentDoc.replace(/\\n/g, eol) : currentDoc;\n  }), opts);\n\n  ensureAllCommentsPrinted(astComments); // Remove extra leading indentation as well as the added indentation after last newline\n\n  if (addAlignmentSize > 0) {\n    var trimmed = result.formatted.trim();\n\n    if (result.cursorNodeStart !== undefined) {\n      result.cursorNodeStart -= result.formatted.indexOf(trimmed);\n    }\n\n    result.formatted = trimmed + convertEndOfLineToChars(opts.endOfLine);\n  }\n\n  if (opts.cursorOffset >= 0) {\n    var oldCursorNodeStart;\n    var oldCursorNodeText;\n    var cursorOffsetRelativeToOldCursorNode;\n    var newCursorNodeStart;\n    var newCursorNodeText;\n\n    if (opts.cursorNode && result.cursorNodeText) {\n      oldCursorNodeStart = opts.locStart(opts.cursorNode);\n      oldCursorNodeText = text.slice(oldCursorNodeStart, opts.locEnd(opts.cursorNode));\n      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset - oldCursorNodeStart;\n      newCursorNodeStart = result.cursorNodeStart;\n      newCursorNodeText = result.cursorNodeText;\n    } else {\n      oldCursorNodeStart = 0;\n      oldCursorNodeText = text;\n      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset;\n      newCursorNodeStart = 0;\n      newCursorNodeText = result.formatted;\n    }\n\n    if (oldCursorNodeText === newCursorNodeText) {\n      return {\n        formatted: result.formatted,\n        cursorOffset: newCursorNodeStart + cursorOffsetRelativeToOldCursorNode\n      };\n    } // diff old and new cursor node texts, with a special cursor\n    // symbol inserted to find out where it moves to\n\n\n    var oldCursorNodeCharArray = oldCursorNodeText.split(\"\");\n    oldCursorNodeCharArray.splice(cursorOffsetRelativeToOldCursorNode, 0, CURSOR);\n    var newCursorNodeCharArray = newCursorNodeText.split(\"\");\n    var cursorNodeDiff = diff.diffArrays(oldCursorNodeCharArray, newCursorNodeCharArray);\n    var cursorOffset = newCursorNodeStart;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = cursorNodeDiff[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var entry = _step.value;\n\n        if (entry.removed) {\n          if (entry.value.indexOf(CURSOR) > -1) {\n            break;\n          }\n        } else {\n          cursorOffset += entry.count;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return {\n      formatted: result.formatted,\n      cursorOffset: cursorOffset\n    };\n  }\n\n  return {\n    formatted: result.formatted\n  };\n}\n\nfunction formatRange(text, opts) {\n  var parsed = parser.parse(text, opts);\n  var ast = parsed.ast;\n  text = parsed.text;\n  var range = rangeUtil.calculateRange(text, opts, ast);\n  var rangeStart = range.rangeStart;\n  var rangeEnd = range.rangeEnd;\n  var rangeString = text.slice(rangeStart, rangeEnd); // Try to extend the range backwards to the beginning of the line.\n  // This is so we can detect indentation correctly and restore it.\n  // Use `Math.min` since `lastIndexOf` returns 0 when `rangeStart` is 0\n\n  var rangeStart2 = Math.min(rangeStart, text.lastIndexOf(\"\\n\", rangeStart) + 1);\n  var indentString = text.slice(rangeStart2, rangeStart);\n  var alignmentSize = privateUtil.getAlignmentSize(indentString, opts.tabWidth);\n  var rangeResult = coreFormat(rangeString, Object.assign({}, opts, {\n    rangeStart: 0,\n    rangeEnd: Infinity,\n    // track the cursor offset only if it's within our range\n    cursorOffset: opts.cursorOffset >= rangeStart && opts.cursorOffset < rangeEnd ? opts.cursorOffset - rangeStart : -1\n  }), alignmentSize); // Since the range contracts to avoid trailing whitespace,\n  // we need to remove the newline that was inserted by the `format` call.\n\n  var rangeTrimmed = rangeResult.formatted.trimRight();\n  var rangeLeft = text.slice(0, rangeStart);\n  var rangeRight = text.slice(rangeEnd);\n  var cursorOffset = opts.cursorOffset;\n\n  if (opts.cursorOffset >= rangeEnd) {\n    // handle the case where the cursor was past the end of the range\n    cursorOffset = opts.cursorOffset - rangeEnd + (rangeStart + rangeTrimmed.length);\n  } else if (rangeResult.cursorOffset !== undefined) {\n    // handle the case where the cursor was in the range\n    cursorOffset = rangeResult.cursorOffset + rangeStart;\n  } // keep the cursor as it was if it was before the start of the range\n\n\n  var formatted;\n\n  if (opts.endOfLine === \"lf\") {\n    formatted = rangeLeft + rangeTrimmed + rangeRight;\n  } else {\n    var eol = convertEndOfLineToChars(opts.endOfLine);\n\n    if (cursorOffset >= 0) {\n      var parts = [rangeLeft, rangeTrimmed, rangeRight];\n      var partIndex = 0;\n      var partOffset = cursorOffset;\n\n      while (partIndex < parts.length) {\n        var part = parts[partIndex];\n\n        if (partOffset < part.length) {\n          parts[partIndex] = parts[partIndex].slice(0, partOffset) + PLACEHOLDERS.cursorOffset + parts[partIndex].slice(partOffset);\n          break;\n        }\n\n        partIndex++;\n        partOffset -= part.length;\n      }\n\n      var newRangeLeft = parts[0],\n          newRangeTrimmed = parts[1],\n          newRangeRight = parts[2];\n      formatted = (newRangeLeft.replace(/\\n/g, eol) + newRangeTrimmed + newRangeRight.replace(/\\n/g, eol)).replace(PLACEHOLDERS.cursorOffset, function (_, index) {\n        cursorOffset = index;\n        return \"\";\n      });\n    } else {\n      formatted = rangeLeft.replace(/\\n/g, eol) + rangeTrimmed + rangeRight.replace(/\\n/g, eol);\n    }\n  }\n\n  return {\n    formatted: formatted,\n    cursorOffset: cursorOffset\n  };\n}\n\nfunction format(text, opts) {\n  var selectedParser = parser.resolveParser(opts);\n  var hasPragma = !selectedParser.hasPragma || selectedParser.hasPragma(text);\n\n  if (opts.requirePragma && !hasPragma) {\n    return {\n      formatted: text\n    };\n  }\n\n  if (opts.endOfLine === \"auto\") {\n    opts.endOfLine = guessEndOfLine(text);\n  }\n\n  var hasCursor = opts.cursorOffset >= 0;\n  var hasRangeStart = opts.rangeStart > 0;\n  var hasRangeEnd = opts.rangeEnd < text.length; // get rid of CR/CRLF parsing\n\n  if (text.indexOf(\"\\r\") !== -1) {\n    var offsetKeys = [hasCursor && \"cursorOffset\", hasRangeStart && \"rangeStart\", hasRangeEnd && \"rangeEnd\"].filter(Boolean).sort(function (aKey, bKey) {\n      return opts[aKey] - opts[bKey];\n    });\n\n    for (var i = offsetKeys.length - 1; i >= 0; i--) {\n      var key = offsetKeys[i];\n      text = text.slice(0, opts[key]) + PLACEHOLDERS[key] + text.slice(opts[key]);\n    }\n\n    text = text.replace(/\\r\\n?/g, \"\\n\");\n\n    var _loop = function _loop(_i) {\n      var key = offsetKeys[_i];\n      text = text.replace(PLACEHOLDERS[key], function (_, index) {\n        opts[key] = index;\n        return \"\";\n      });\n    };\n\n    for (var _i = 0; _i < offsetKeys.length; _i++) {\n      _loop(_i);\n    }\n  }\n\n  var hasUnicodeBOM = text.charCodeAt(0) === UTF8BOM;\n\n  if (hasUnicodeBOM) {\n    text = text.substring(1);\n\n    if (hasCursor) {\n      opts.cursorOffset++;\n    }\n\n    if (hasRangeStart) {\n      opts.rangeStart++;\n    }\n\n    if (hasRangeEnd) {\n      opts.rangeEnd++;\n    }\n  }\n\n  if (!hasCursor) {\n    opts.cursorOffset = -1;\n  }\n\n  if (opts.rangeStart < 0) {\n    opts.rangeStart = 0;\n  }\n\n  if (opts.rangeEnd > text.length) {\n    opts.rangeEnd = text.length;\n  }\n\n  var result = hasRangeStart || hasRangeEnd ? formatRange(text, opts) : coreFormat(opts.insertPragma && opts.printer.insertPragma && !hasPragma ? opts.printer.insertPragma(text) : text, opts);\n\n  if (hasUnicodeBOM) {\n    result.formatted = String.fromCharCode(UTF8BOM) + result.formatted;\n\n    if (hasCursor) {\n      result.cursorOffset++;\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  formatWithCursor: function formatWithCursor(text, opts) {\n    opts = normalizeOptions(opts);\n    return format(text, opts);\n  },\n  parse: function parse(text, opts, massage) {\n    opts = normalizeOptions(opts);\n\n    if (text.indexOf(\"\\r\") !== -1) {\n      text = text.replace(/\\r\\n?/g, \"\\n\");\n    }\n\n    var parsed = parser.parse(text, opts);\n\n    if (massage) {\n      parsed.ast = massageAST(parsed.ast, opts);\n    }\n\n    return parsed;\n  },\n  formatAST: function formatAST(ast, opts) {\n    opts = normalizeOptions(opts);\n    var doc = printAstToDoc(ast, opts);\n    return _printDocToString(doc, opts);\n  },\n  // Doesn't handle shebang for now\n  formatDoc: function formatDoc(doc, opts) {\n    var debug = printDocToDebug(doc);\n    opts = normalizeOptions(Object.assign({}, opts, {\n      parser: \"babel\"\n    }));\n    return format(debug, opts).formatted;\n  },\n  printToDoc: function printToDoc(text, opts) {\n    opts = normalizeOptions(opts);\n    var parsed = parser.parse(text, opts);\n    var ast = parsed.ast;\n    text = parsed.text;\n    attachComments(text, ast, opts);\n    return printAstToDoc(ast, opts);\n  },\n  printDocToString: function printDocToString(doc, opts) {\n    return _printDocToString(doc, normalizeOptions(opts));\n  }\n};"]},"metadata":{},"sourceType":"script"}