{"ast":null,"code":"\"use strict\";\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar assert = require(\"assert\"); // TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.\n\n\nvar comments = require(\"../main/comments\");\n\nvar _require = require(\"../common/util\"),\n    getParentExportDeclaration = _require.getParentExportDeclaration,\n    isExportDeclaration = _require.isExportDeclaration,\n    shouldFlatten = _require.shouldFlatten,\n    getNextNonSpaceNonCommentCharacter = _require.getNextNonSpaceNonCommentCharacter,\n    hasNewline = _require.hasNewline,\n    hasNewlineInRange = _require.hasNewlineInRange,\n    getLast = _require.getLast,\n    getStringWidth = _require.getStringWidth,\n    printString = _require.printString,\n    printNumber = _require.printNumber,\n    hasIgnoreComment = _require.hasIgnoreComment,\n    skipWhitespace = _require.skipWhitespace,\n    hasNodeIgnoreComment = _require.hasNodeIgnoreComment,\n    getPenultimate = _require.getPenultimate,\n    startsWithNoLookaheadToken = _require.startsWithNoLookaheadToken,\n    getIndentSize = _require.getIndentSize,\n    matchAncestorTypes = _require.matchAncestorTypes,\n    getPreferredQuote = _require.getPreferredQuote;\n\nvar _require2 = require(\"../common/util-shared\"),\n    isNextLineEmpty = _require2.isNextLineEmpty,\n    isNextLineEmptyAfterIndex = _require2.isNextLineEmptyAfterIndex,\n    getNextNonSpaceNonCommentCharacterIndex = _require2.getNextNonSpaceNonCommentCharacterIndex;\n\nvar isIdentifierName = require(\"esutils\").keyword.isIdentifierNameES5;\n\nvar embed = require(\"./embed\");\n\nvar clean = require(\"./clean\");\n\nvar insertPragma = require(\"./pragma\").insertPragma;\n\nvar handleComments = require(\"./comments\");\n\nvar pathNeedsParens = require(\"./needs-parens\");\n\nvar _require3 = require(\"./html-binding\"),\n    printHtmlBinding = _require3.printHtmlBinding,\n    isVueEventBindingExpression = _require3.isVueEventBindingExpression;\n\nvar preprocess = require(\"./preprocess\");\n\nvar _require4 = require(\"./utils\"),\n    getLeftSide = _require4.getLeftSide,\n    getLeftSidePathName = _require4.getLeftSidePathName,\n    hasNakedLeftSide = _require4.hasNakedLeftSide,\n    hasNode = _require4.hasNode,\n    hasFlowAnnotationComment = _require4.hasFlowAnnotationComment,\n    hasFlowShorthandAnnotationComment = _require4.hasFlowShorthandAnnotationComment;\n\nvar needsQuoteProps = new WeakMap();\n\nvar _require5 = require(\"../doc\"),\n    _require5$builders = _require5.builders,\n    concat = _require5$builders.concat,\n    join = _require5$builders.join,\n    line = _require5$builders.line,\n    hardline = _require5$builders.hardline,\n    softline = _require5$builders.softline,\n    literalline = _require5$builders.literalline,\n    group = _require5$builders.group,\n    indent = _require5$builders.indent,\n    align = _require5$builders.align,\n    conditionalGroup = _require5$builders.conditionalGroup,\n    fill = _require5$builders.fill,\n    ifBreak = _require5$builders.ifBreak,\n    breakParent = _require5$builders.breakParent,\n    lineSuffixBoundary = _require5$builders.lineSuffixBoundary,\n    addAlignmentToDoc = _require5$builders.addAlignmentToDoc,\n    dedent = _require5$builders.dedent,\n    _require5$utils = _require5.utils,\n    willBreak = _require5$utils.willBreak,\n    isLineNext = _require5$utils.isLineNext,\n    isEmpty = _require5$utils.isEmpty,\n    removeLines = _require5$utils.removeLines,\n    printDocToString = _require5.printer.printDocToString;\n\nvar uid = 0;\n\nfunction shouldPrintComma(options, level) {\n  level = level || \"es5\";\n\n  switch (options.trailingComma) {\n    case \"all\":\n      if (level === \"all\") {\n        return true;\n      }\n\n    // fallthrough\n\n    case \"es5\":\n      if (level === \"es5\") {\n        return true;\n      }\n\n    // fallthrough\n\n    case \"none\":\n    default:\n      return false;\n  }\n}\n\nfunction genericPrint(path, options, printPath, args) {\n  var node = path.getValue();\n  var needsParens = false;\n  var linesWithoutParens = printPathNoParens(path, options, printPath, args);\n\n  if (!node || isEmpty(linesWithoutParens)) {\n    return linesWithoutParens;\n  }\n\n  var parentExportDecl = getParentExportDeclaration(path);\n  var decorators = [];\n\n  if (node.type === \"ClassMethod\" || node.type === \"ClassPrivateMethod\" || node.type === \"ClassProperty\" || node.type === \"TSAbstractClassProperty\" || node.type === \"ClassPrivateProperty\" || node.type === \"MethodDefinition\" || node.type === \"TSAbstractMethodDefinition\") {// their decorators are handled themselves\n  } else if (node.decorators && node.decorators.length > 0 && // If the parent node is an export declaration and the decorator\n  // was written before the export, the export will be responsible\n  // for printing the decorators.\n  !(parentExportDecl && options.locStart(parentExportDecl, {\n    ignoreDecorators: true\n  }) > options.locStart(node.decorators[0]))) {\n    var shouldBreak = node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\" || hasNewlineBetweenOrAfterDecorators(node, options);\n    var separator = shouldBreak ? hardline : line;\n    path.each(function (decoratorPath) {\n      var decorator = decoratorPath.getValue();\n\n      if (decorator.expression) {\n        decorator = decorator.expression;\n      } else {\n        decorator = decorator.callee;\n      }\n\n      decorators.push(printPath(decoratorPath), separator);\n    }, \"decorators\");\n\n    if (parentExportDecl) {\n      decorators.unshift(hardline);\n    }\n  } else if (isExportDeclaration(node) && node.declaration && node.declaration.decorators && node.declaration.decorators.length > 0 && // Only print decorators here if they were written before the export,\n  // otherwise they are printed by the node.declaration\n  options.locStart(node, {\n    ignoreDecorators: true\n  }) > options.locStart(node.declaration.decorators[0])) {\n    // Export declarations are responsible for printing any decorators\n    // that logically apply to node.declaration.\n    path.each(function (decoratorPath) {\n      var decorator = decoratorPath.getValue();\n      var prefix = decorator.type === \"Decorator\" ? \"\" : \"@\";\n      decorators.push(prefix, printPath(decoratorPath), hardline);\n    }, \"declaration\", \"decorators\");\n  } else {\n    // Nodes with decorators can't have parentheses, so we can avoid\n    // computing pathNeedsParens() except in this case.\n    needsParens = pathNeedsParens(path, options);\n  }\n\n  var parts = [];\n\n  if (needsParens) {\n    parts.unshift(\"(\");\n  }\n\n  parts.push(linesWithoutParens);\n\n  if (needsParens) {\n    var _node = path.getValue();\n\n    if (hasFlowShorthandAnnotationComment(_node)) {\n      parts.push(\" /*\");\n      parts.push(_node.trailingComments[0].value.trimLeft());\n      parts.push(\"*/\");\n      _node.trailingComments[0].printed = true;\n    }\n\n    parts.push(\")\");\n  }\n\n  if (decorators.length > 0) {\n    return group(concat(decorators.concat(parts)));\n  }\n\n  return concat(parts);\n}\n\nfunction hasNewlineBetweenOrAfterDecorators(node, options) {\n  return hasNewlineInRange(options.originalText, options.locStart(node.decorators[0]), options.locEnd(getLast(node.decorators))) || hasNewline(options.originalText, options.locEnd(getLast(node.decorators)));\n}\n\nfunction printDecorators(path, options, print) {\n  var node = path.getValue();\n  return group(concat([join(line, path.map(print, \"decorators\")), hasNewlineBetweenOrAfterDecorators(node, options) ? hardline : line]));\n}\n\nfunction hasPrettierIgnore(path) {\n  return hasIgnoreComment(path) || hasJsxIgnoreComment(path);\n}\n\nfunction hasJsxIgnoreComment(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n\n  if (!parent || !node || !isJSXNode(node) || !isJSXNode(parent)) {\n    return false;\n  } // Lookup the previous sibling, ignoring any empty JSXText elements\n\n\n  var index = parent.children.indexOf(node);\n  var prevSibling = null;\n\n  for (var i = index; i > 0; i--) {\n    var candidate = parent.children[i - 1];\n\n    if (candidate.type === \"JSXText\" && !isMeaningfulJSXText(candidate)) {\n      continue;\n    }\n\n    prevSibling = candidate;\n    break;\n  }\n\n  return prevSibling && prevSibling.type === \"JSXExpressionContainer\" && prevSibling.expression.type === \"JSXEmptyExpression\" && prevSibling.expression.comments && prevSibling.expression.comments.find(function (comment) {\n    return comment.value.trim() === \"prettier-ignore\";\n  });\n}\n/**\n * The following is the shared logic for\n * ternary operators, namely ConditionalExpression\n * and TSConditionalType\n * @typedef {Object} OperatorOptions\n * @property {() => Array<string | Doc>} beforeParts - Parts to print before the `?`.\n * @property {(breakClosingParen: boolean) => Array<string | Doc>} afterParts - Parts to print after the conditional expression.\n * @property {boolean} shouldCheckJsx - Whether to check for and print in JSX mode.\n * @property {string} conditionalNodeType - The type of the conditional expression node, ie \"ConditionalExpression\" or \"TSConditionalType\".\n * @property {string} consequentNodePropertyName - The property at which the consequent node can be found on the main node, eg \"consequent\".\n * @property {string} alternateNodePropertyName - The property at which the alternate node can be found on the main node, eg \"alternate\".\n * @property {string} testNodePropertyName - The property at which the test node can be found on the main node, eg \"test\".\n * @property {boolean} breakNested - Whether to break all nested ternaries when one breaks.\n * @param {FastPath} path - The path to the ConditionalExpression/TSConditionalType node.\n * @param {Options} options - Prettier options\n * @param {Function} print - Print function to call recursively\n * @param {OperatorOptions} operatorOptions\n * @returns Doc\n */\n\n\nfunction printTernaryOperator(path, options, print, operatorOptions) {\n  var node = path.getValue();\n  var testNode = node[operatorOptions.testNodePropertyName];\n  var consequentNode = node[operatorOptions.consequentNodePropertyName];\n  var alternateNode = node[operatorOptions.alternateNodePropertyName];\n  var parts = []; // We print a ConditionalExpression in either \"JSX mode\" or \"normal mode\".\n  // See tests/jsx/conditional-expression.js for more info.\n\n  var jsxMode = false;\n  var parent = path.getParentNode();\n  var forceNoIndent = parent.type === operatorOptions.conditionalNodeType; // Find the outermost non-ConditionalExpression parent, and the outermost\n  // ConditionalExpression parent. We'll use these to determine if we should\n  // print in JSX mode.\n\n  var currentParent;\n  var previousParent;\n  var i = 0;\n\n  do {\n    previousParent = currentParent || node;\n    currentParent = path.getParentNode(i);\n    i++;\n  } while (currentParent && currentParent.type === operatorOptions.conditionalNodeType);\n\n  var firstNonConditionalParent = currentParent || parent;\n  var lastConditionalParent = previousParent;\n\n  if (operatorOptions.shouldCheckJsx && (isJSXNode(testNode) || isJSXNode(consequentNode) || isJSXNode(alternateNode) || conditionalExpressionChainContainsJSX(lastConditionalParent))) {\n    jsxMode = true;\n    forceNoIndent = true; // Even though they don't need parens, we wrap (almost) everything in\n    // parens when using ?: within JSX, because the parens are analogous to\n    // curly braces in an if statement.\n\n    var wrap = function wrap(doc) {\n      return concat([ifBreak(\"(\", \"\"), indent(concat([softline, doc])), softline, ifBreak(\")\", \"\")]);\n    }; // The only things we don't wrap are:\n    // * Nested conditional expressions in alternates\n    // * null\n\n\n    var isNull = function isNull(node) {\n      return node.type === \"NullLiteral\" || node.type === \"Literal\" && node.value === null;\n    };\n\n    parts.push(\" ? \", isNull(consequentNode) ? path.call(print, operatorOptions.consequentNodePropertyName) : wrap(path.call(print, operatorOptions.consequentNodePropertyName)), \" : \", alternateNode.type === operatorOptions.conditionalNodeType || isNull(alternateNode) ? path.call(print, operatorOptions.alternateNodePropertyName) : wrap(path.call(print, operatorOptions.alternateNodePropertyName)));\n  } else {\n    // normal mode\n    var part = concat([line, \"? \", consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak(\"\", \"(\") : \"\", align(2, path.call(print, operatorOptions.consequentNodePropertyName)), consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak(\"\", \")\") : \"\", line, \": \", alternateNode.type === operatorOptions.conditionalNodeType ? path.call(print, operatorOptions.alternateNodePropertyName) : align(2, path.call(print, operatorOptions.alternateNodePropertyName))]);\n    parts.push(parent.type !== operatorOptions.conditionalNodeType || parent[operatorOptions.alternateNodePropertyName] === node ? part : options.useTabs ? dedent(indent(part)) : align(Math.max(0, options.tabWidth - 2), part));\n  } // We want a whole chain of ConditionalExpressions to all\n  // break if any of them break. That means we should only group around the\n  // outer-most ConditionalExpression.\n\n\n  var maybeGroup = function maybeGroup(doc) {\n    return operatorOptions.breakNested ? parent === firstNonConditionalParent ? group(doc) : doc : group(doc);\n  }; // Break the closing paren to keep the chain right after it:\n  // (a\n  //   ? b\n  //   : c\n  // ).call()\n\n\n  var breakClosingParen = !jsxMode && (parent.type === \"MemberExpression\" || parent.type === \"OptionalMemberExpression\") && !parent.computed;\n  return maybeGroup(concat([].concat(function (testDoc) {\n    return (\n      /**\n       *     a\n       *       ? b\n       *       : multiline\n       *         test\n       *         node\n       *       ^^ align(2)\n       *       ? d\n       *       : e\n       */\n      parent.type === operatorOptions.conditionalNodeType && parent[operatorOptions.alternateNodePropertyName] === node ? align(2, testDoc) : testDoc\n    );\n  }(concat(operatorOptions.beforeParts())), forceNoIndent ? concat(parts) : indent(concat(parts)), operatorOptions.afterParts(breakClosingParen))));\n}\n\nfunction getTypeScriptMappedTypeModifier(tokenNode, keyword) {\n  if (tokenNode === \"+\") {\n    return \"+\" + keyword;\n  } else if (tokenNode === \"-\") {\n    return \"-\" + keyword;\n  }\n\n  return keyword;\n}\n\nfunction printPathNoParens(path, options, print, args) {\n  var n = path.getValue();\n  var semi = options.semi ? \";\" : \"\";\n\n  if (!n) {\n    return \"\";\n  }\n\n  if (typeof n === \"string\") {\n    return n;\n  }\n\n  var htmlBinding = printHtmlBinding(path, options, print);\n\n  if (htmlBinding) {\n    return htmlBinding;\n  }\n\n  var parts = [];\n\n  switch (n.type) {\n    case \"JsExpressionRoot\":\n      return path.call(print, \"node\");\n\n    case \"JsonRoot\":\n      return concat([path.call(print, \"node\"), hardline]);\n\n    case \"File\":\n      // Print @babel/parser's InterpreterDirective here so that\n      // leading comments on the `Program` node get printed after the hashbang.\n      if (n.program && n.program.interpreter) {\n        parts.push(path.call(function (programPath) {\n          return programPath.call(print, \"interpreter\");\n        }, \"program\"));\n      }\n\n      parts.push(path.call(print, \"program\"));\n      return concat(parts);\n\n    case \"Program\":\n      // Babel 6\n      if (n.directives) {\n        path.each(function (childPath) {\n          parts.push(print(childPath), semi, hardline);\n\n          if (isNextLineEmpty(options.originalText, childPath.getValue(), options)) {\n            parts.push(hardline);\n          }\n        }, \"directives\");\n      }\n\n      parts.push(path.call(function (bodyPath) {\n        return printStatementSequence(bodyPath, options, print);\n      }, \"body\"));\n      parts.push(comments.printDanglingComments(path, options,\n      /* sameIndent */\n      true)); // Only force a trailing newline if there were any contents.\n\n      if (n.body.length || n.comments) {\n        parts.push(hardline);\n      }\n\n      return concat(parts);\n    // Babel extension.\n\n    case \"EmptyStatement\":\n      return \"\";\n\n    case \"ExpressionStatement\":\n      // Detect Flow-parsed directives\n      if (n.directive) {\n        return concat([nodeStr(n.expression, options, true), semi]);\n      }\n\n      if (options.parser === \"__vue_event_binding\") {\n        var parent = path.getParentNode();\n\n        if (parent.type === \"Program\" && parent.body.length === 1 && parent.body[0] === n) {\n          return concat([path.call(print, \"expression\"), isVueEventBindingExpression(n.expression) ? \";\" : \"\"]);\n        }\n      } // Do not append semicolon after the only JSX element in a program\n\n\n      return concat([path.call(print, \"expression\"), isTheOnlyJSXElementInMarkdown(options, path) ? \"\" : semi]);\n    // Babel extension.\n\n    case \"ParenthesizedExpression\":\n      return concat([\"(\", path.call(print, \"expression\"), \")\"]);\n\n    case \"AssignmentExpression\":\n      return printAssignment(n.left, path.call(print, \"left\"), concat([\" \", n.operator]), n.right, path.call(print, \"right\"), options);\n\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n    case \"NGPipeExpression\":\n      {\n        var _parent = path.getParentNode();\n\n        var parentParent = path.getParentNode(1);\n        var isInsideParenthesis = n !== _parent.body && (_parent.type === \"IfStatement\" || _parent.type === \"WhileStatement\" || _parent.type === \"DoWhileStatement\");\n\n        var _parts = printBinaryishExpressions(path, print, options,\n        /* isNested */\n        false, isInsideParenthesis); //   if (\n        //     this.hasPlugin(\"dynamicImports\") && this.lookahead().type === tt.parenLeft\n        //   ) {\n        //\n        // looks super weird, we want to break the children if the parent breaks\n        //\n        //   if (\n        //     this.hasPlugin(\"dynamicImports\") &&\n        //     this.lookahead().type === tt.parenLeft\n        //   ) {\n\n\n        if (isInsideParenthesis) {\n          return concat(_parts);\n        } // Break between the parens in\n        // unaries or in a member or specific call expression, i.e.\n        //\n        //   (\n        //     a &&\n        //     b &&\n        //     c\n        //   ).call()\n\n\n        if (_parent.type === \"CallExpression\" && _parent.callee === n || _parent.type === \"UnaryExpression\" || (_parent.type === \"MemberExpression\" || _parent.type === \"OptionalMemberExpression\") && !_parent.computed) {\n          return group(concat([indent(concat([softline, concat(_parts)])), softline]));\n        } // Avoid indenting sub-expressions in some cases where the first sub-expression is already\n        // indented accordingly. We should indent sub-expressions where the first case isn't indented.\n\n\n        var shouldNotIndent = _parent.type === \"ReturnStatement\" || _parent.type === \"JSXExpressionContainer\" && parentParent.type === \"JSXAttribute\" || n.type !== \"NGPipeExpression\" && (_parent.type === \"NGRoot\" && options.parser === \"__ng_binding\" || _parent.type === \"NGMicrosyntaxExpression\" && parentParent.type === \"NGMicrosyntax\" && parentParent.body.length === 1) || n === _parent.body && _parent.type === \"ArrowFunctionExpression\" || n !== _parent.body && _parent.type === \"ForStatement\" || _parent.type === \"ConditionalExpression\" && parentParent.type !== \"ReturnStatement\" && parentParent.type !== \"CallExpression\";\n        var shouldIndentIfInlining = _parent.type === \"AssignmentExpression\" || _parent.type === \"VariableDeclarator\" || _parent.type === \"ClassProperty\" || _parent.type === \"TSAbstractClassProperty\" || _parent.type === \"ClassPrivateProperty\" || _parent.type === \"ObjectProperty\" || _parent.type === \"Property\";\n        var samePrecedenceSubExpression = isBinaryish(n.left) && shouldFlatten(n.operator, n.left.operator);\n\n        if (shouldNotIndent || shouldInlineLogicalExpression(n) && !samePrecedenceSubExpression || !shouldInlineLogicalExpression(n) && shouldIndentIfInlining) {\n          return group(concat(_parts));\n        }\n\n        if (_parts.length === 0) {\n          return \"\";\n        } // If the right part is a JSX node, we include it in a separate group to\n        // prevent it breaking the whole chain, so we can print the expression like:\n        //\n        //   foo && bar && (\n        //     <Foo>\n        //       <Bar />\n        //     </Foo>\n        //   )\n\n\n        var hasJSX = isJSXNode(n.right);\n        var rest = concat(hasJSX ? _parts.slice(1, -1) : _parts.slice(1));\n        var groupId = Symbol(\"logicalChain-\" + ++uid);\n        var chain = group(concat([// Don't include the initial expression in the indentation\n        // level. The first item is guaranteed to be the first\n        // left-most expression.\n        _parts.length > 0 ? _parts[0] : \"\", indent(rest)]), {\n          id: groupId\n        });\n\n        if (!hasJSX) {\n          return chain;\n        }\n\n        var jsxPart = getLast(_parts);\n        return group(concat([chain, ifBreak(indent(jsxPart), jsxPart, {\n          groupId: groupId\n        })]));\n      }\n\n    case \"AssignmentPattern\":\n      return concat([path.call(print, \"left\"), \" = \", path.call(print, \"right\")]);\n\n    case \"TSTypeAssertion\":\n      {\n        var shouldBreakAfterCast = !(n.expression.type === \"ArrayExpression\" || n.expression.type === \"ObjectExpression\");\n        var castGroup = group(concat([\"<\", indent(concat([softline, path.call(print, \"typeAnnotation\")])), softline, \">\"]));\n        var exprContents = concat([ifBreak(\"(\"), indent(concat([softline, path.call(print, \"expression\")])), softline, ifBreak(\")\")]);\n\n        if (shouldBreakAfterCast) {\n          return conditionalGroup([concat([castGroup, path.call(print, \"expression\")]), concat([castGroup, group(exprContents, {\n            shouldBreak: true\n          })]), concat([castGroup, path.call(print, \"expression\")])]);\n        }\n\n        return group(concat([castGroup, path.call(print, \"expression\")]));\n      }\n\n    case \"OptionalMemberExpression\":\n    case \"MemberExpression\":\n      {\n        var _parent2 = path.getParentNode();\n\n        var firstNonMemberParent;\n        var i = 0;\n\n        do {\n          firstNonMemberParent = path.getParentNode(i);\n          i++;\n        } while (firstNonMemberParent && (firstNonMemberParent.type === \"MemberExpression\" || firstNonMemberParent.type === \"OptionalMemberExpression\" || firstNonMemberParent.type === \"TSNonNullExpression\"));\n\n        var shouldInline = firstNonMemberParent && (firstNonMemberParent.type === \"NewExpression\" || firstNonMemberParent.type === \"BindExpression\" || firstNonMemberParent.type === \"VariableDeclarator\" && firstNonMemberParent.id.type !== \"Identifier\" || firstNonMemberParent.type === \"AssignmentExpression\" && firstNonMemberParent.left.type !== \"Identifier\") || n.computed || n.object.type === \"Identifier\" && n.property.type === \"Identifier\" && _parent2.type !== \"MemberExpression\" && _parent2.type !== \"OptionalMemberExpression\";\n        return concat([path.call(print, \"object\"), shouldInline ? printMemberLookup(path, options, print) : group(indent(concat([softline, printMemberLookup(path, options, print)])))]);\n      }\n\n    case \"MetaProperty\":\n      return concat([path.call(print, \"meta\"), \".\", path.call(print, \"property\")]);\n\n    case \"BindExpression\":\n      if (n.object) {\n        parts.push(path.call(print, \"object\"));\n      }\n\n      parts.push(group(indent(concat([softline, printBindExpressionCallee(path, options, print)]))));\n      return concat(parts);\n\n    case \"Identifier\":\n      {\n        return concat([n.name, printOptionalToken(path), printTypeAnnotation(path, options, print)]);\n      }\n\n    case \"SpreadElement\":\n    case \"SpreadElementPattern\":\n    case \"RestProperty\":\n    case \"SpreadProperty\":\n    case \"SpreadPropertyPattern\":\n    case \"RestElement\":\n    case \"ObjectTypeSpreadProperty\":\n      return concat([\"...\", path.call(print, \"argument\"), printTypeAnnotation(path, options, print)]);\n\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n      parts.push(printFunctionDeclaration(path, print, options));\n\n      if (!n.body) {\n        parts.push(semi);\n      }\n\n      return concat(parts);\n\n    case \"ArrowFunctionExpression\":\n      {\n        if (n.async) {\n          parts.push(\"async \");\n        }\n\n        if (shouldPrintParamsWithoutParens(path, options)) {\n          parts.push(path.call(print, \"params\", 0));\n        } else {\n          parts.push(group(concat([printFunctionParams(path, print, options,\n          /* expandLast */\n          args && (args.expandLastArg || args.expandFirstArg),\n          /* printTypeParams */\n          true), printReturnType(path, print, options)])));\n        }\n\n        var dangling = comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true, function (comment) {\n          var nextCharacter = getNextNonSpaceNonCommentCharacterIndex(options.originalText, comment, options);\n          return options.originalText.substr(nextCharacter, 2) === \"=>\";\n        });\n\n        if (dangling) {\n          parts.push(\" \", dangling);\n        }\n\n        parts.push(\" =>\");\n        var body = path.call(function (bodyPath) {\n          return print(bodyPath, args);\n        }, \"body\"); // We want to always keep these types of nodes on the same line\n        // as the arrow.\n\n        if (!hasLeadingOwnLineComment(options.originalText, n.body, options) && (n.body.type === \"ArrayExpression\" || n.body.type === \"ObjectExpression\" || n.body.type === \"BlockStatement\" || isJSXNode(n.body) || isTemplateOnItsOwnLine(n.body, options.originalText, options) || n.body.type === \"ArrowFunctionExpression\" || n.body.type === \"DoExpression\")) {\n          return group(concat([concat(parts), \" \", body]));\n        } // We handle sequence expressions as the body of arrows specially,\n        // so that the required parentheses end up on their own lines.\n\n\n        if (n.body.type === \"SequenceExpression\") {\n          return group(concat([concat(parts), group(concat([\" (\", indent(concat([softline, body])), softline, \")\"]))]));\n        } // if the arrow function is expanded as last argument, we are adding a\n        // level of indentation and need to add a softline to align the closing )\n        // with the opening (, or if it's inside a JSXExpression (e.g. an attribute)\n        // we should align the expression's closing } with the line with the opening {.\n\n\n        var shouldAddSoftLine = (args && args.expandLastArg || path.getParentNode().type === \"JSXExpressionContainer\") && !(n.comments && n.comments.length);\n        var printTrailingComma = args && args.expandLastArg && shouldPrintComma(options, \"all\"); // In order to avoid confusion between\n        // a => a ? a : a\n        // a <= a ? a : a\n\n        var shouldAddParens = n.body.type === \"ConditionalExpression\" && !startsWithNoLookaheadToken(n.body,\n        /* forbidFunctionAndClass */\n        false);\n        return group(concat([concat(parts), group(concat([indent(concat([line, shouldAddParens ? ifBreak(\"\", \"(\") : \"\", body, shouldAddParens ? ifBreak(\"\", \")\") : \"\"])), shouldAddSoftLine ? concat([ifBreak(printTrailingComma ? \",\" : \"\"), softline]) : \"\"]))]));\n      }\n\n    case \"MethodDefinition\":\n    case \"TSAbstractMethodDefinition\":\n      if (n.decorators && n.decorators.length !== 0) {\n        parts.push(printDecorators(path, options, print));\n      }\n\n      if (n.accessibility) {\n        parts.push(n.accessibility + \" \");\n      }\n\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      if (n.type === \"TSAbstractMethodDefinition\") {\n        parts.push(\"abstract \");\n      }\n\n      parts.push(printMethod(path, options, print));\n      return concat(parts);\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n\n      if (n.delegate) {\n        parts.push(\"*\");\n      }\n\n      if (n.argument) {\n        parts.push(\" \", path.call(print, \"argument\"));\n      }\n\n      return concat(parts);\n\n    case \"AwaitExpression\":\n      return concat([\"await \", path.call(print, \"argument\")]);\n\n    case \"ImportSpecifier\":\n      if (n.importKind) {\n        parts.push(path.call(print, \"importKind\"), \" \");\n      }\n\n      parts.push(path.call(print, \"imported\"));\n\n      if (n.local && n.local.name !== n.imported.name) {\n        parts.push(\" as \", path.call(print, \"local\"));\n      }\n\n      return concat(parts);\n\n    case \"ExportSpecifier\":\n      parts.push(path.call(print, \"local\"));\n\n      if (n.exported && n.exported.name !== n.local.name) {\n        parts.push(\" as \", path.call(print, \"exported\"));\n      }\n\n      return concat(parts);\n\n    case \"ImportNamespaceSpecifier\":\n      parts.push(\"* as \");\n      parts.push(path.call(print, \"local\"));\n      return concat(parts);\n\n    case \"ImportDefaultSpecifier\":\n      return path.call(print, \"local\");\n\n    case \"TSExportAssignment\":\n      return concat([\"export = \", path.call(print, \"expression\"), semi]);\n\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n      return printExportDeclaration(path, options, print);\n\n    case \"ExportAllDeclaration\":\n      parts.push(\"export \");\n\n      if (n.exportKind === \"type\") {\n        parts.push(\"type \");\n      }\n\n      parts.push(\"* from \", path.call(print, \"source\"), semi);\n      return concat(parts);\n\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      return path.call(print, \"exported\");\n\n    case \"ImportDeclaration\":\n      {\n        parts.push(\"import \");\n\n        if (n.importKind && n.importKind !== \"value\") {\n          parts.push(n.importKind + \" \");\n        }\n\n        var standalones = [];\n        var grouped = [];\n\n        if (n.specifiers && n.specifiers.length > 0) {\n          path.each(function (specifierPath) {\n            var value = specifierPath.getValue();\n\n            if (value.type === \"ImportDefaultSpecifier\" || value.type === \"ImportNamespaceSpecifier\") {\n              standalones.push(print(specifierPath));\n            } else {\n              grouped.push(print(specifierPath));\n            }\n          }, \"specifiers\");\n\n          if (standalones.length > 0) {\n            parts.push(join(\", \", standalones));\n          }\n\n          if (standalones.length > 0 && grouped.length > 0) {\n            parts.push(\", \");\n          }\n\n          if (grouped.length === 1 && standalones.length === 0 && n.specifiers && !n.specifiers.some(function (node) {\n            return node.comments;\n          })) {\n            parts.push(concat([\"{\", options.bracketSpacing ? \" \" : \"\", concat(grouped), options.bracketSpacing ? \" \" : \"\", \"}\"]));\n          } else if (grouped.length >= 1) {\n            parts.push(group(concat([\"{\", indent(concat([options.bracketSpacing ? line : softline, join(concat([\",\", line]), grouped)])), ifBreak(shouldPrintComma(options) ? \",\" : \"\"), options.bracketSpacing ? line : softline, \"}\"])));\n          }\n\n          parts.push(\" from \");\n        } else if (n.importKind && n.importKind === \"type\" || // import {} from 'x'\n        /{\\s*}/.test(options.originalText.slice(options.locStart(n), options.locStart(n.source)))) {\n          parts.push(\"{} from \");\n        }\n\n        parts.push(path.call(print, \"source\"), semi);\n        return concat(parts);\n      }\n\n    case \"Import\":\n      return \"import\";\n\n    case \"TSModuleBlock\":\n    case \"BlockStatement\":\n      {\n        var naked = path.call(function (bodyPath) {\n          return printStatementSequence(bodyPath, options, print);\n        }, \"body\");\n        var hasContent = n.body.find(function (node) {\n          return node.type !== \"EmptyStatement\";\n        });\n        var hasDirectives = n.directives && n.directives.length > 0;\n\n        var _parent3 = path.getParentNode();\n\n        var _parentParent = path.getParentNode(1);\n\n        if (!hasContent && !hasDirectives && !hasDanglingComments(n) && (_parent3.type === \"ArrowFunctionExpression\" || _parent3.type === \"FunctionExpression\" || _parent3.type === \"FunctionDeclaration\" || _parent3.type === \"ObjectMethod\" || _parent3.type === \"ClassMethod\" || _parent3.type === \"ClassPrivateMethod\" || _parent3.type === \"ForStatement\" || _parent3.type === \"WhileStatement\" || _parent3.type === \"DoWhileStatement\" || _parent3.type === \"DoExpression\" || _parent3.type === \"CatchClause\" && !_parentParent.finalizer || _parent3.type === \"TSModuleDeclaration\")) {\n          return \"{}\";\n        }\n\n        parts.push(\"{\"); // Babel 6\n\n        if (hasDirectives) {\n          path.each(function (childPath) {\n            parts.push(indent(concat([hardline, print(childPath), semi])));\n\n            if (isNextLineEmpty(options.originalText, childPath.getValue(), options)) {\n              parts.push(hardline);\n            }\n          }, \"directives\");\n        }\n\n        if (hasContent) {\n          parts.push(indent(concat([hardline, naked])));\n        }\n\n        parts.push(comments.printDanglingComments(path, options));\n        parts.push(hardline, \"}\");\n        return concat(parts);\n      }\n\n    case \"ReturnStatement\":\n      parts.push(\"return\");\n\n      if (n.argument) {\n        if (returnArgumentHasLeadingComment(options, n.argument)) {\n          parts.push(concat([\" (\", indent(concat([hardline, path.call(print, \"argument\")])), hardline, \")\"]));\n        } else if (n.argument.type === \"LogicalExpression\" || n.argument.type === \"BinaryExpression\" || n.argument.type === \"SequenceExpression\") {\n          parts.push(group(concat([ifBreak(\" (\", \" \"), indent(concat([softline, path.call(print, \"argument\")])), softline, ifBreak(\")\")])));\n        } else {\n          parts.push(\" \", path.call(print, \"argument\"));\n        }\n      }\n\n      if (hasDanglingComments(n)) {\n        parts.push(\" \", comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true));\n      }\n\n      parts.push(semi);\n      return concat(parts);\n\n    case \"NewExpression\":\n    case \"OptionalCallExpression\":\n    case \"CallExpression\":\n      {\n        var isNew = n.type === \"NewExpression\";\n        var optional = printOptionalToken(path);\n\n        if ( // We want to keep CommonJS- and AMD-style require calls, and AMD-style\n        // define calls, as a unit.\n        // e.g. `define([\"some/lib\", (lib) => {`\n        !isNew && n.callee.type === \"Identifier\" && (n.callee.name === \"require\" || n.callee.name === \"define\") || // Template literals as single arguments\n        n.arguments.length === 1 && isTemplateOnItsOwnLine(n.arguments[0], options.originalText, options) || // Keep test declarations on a single line\n        // e.g. `it('long name', () => {`\n        !isNew && isTestCall(n, path.getParentNode())) {\n          return concat([isNew ? \"new \" : \"\", path.call(print, \"callee\"), optional, printFunctionTypeParameters(path, options, print), concat([\"(\", join(\", \", path.map(print, \"arguments\")), \")\"])]);\n        } // Inline Flow annotation comments following Identifiers in Call nodes need to\n        // stay with the Identifier. For example:\n        //\n        // foo /*:: <SomeGeneric> */(bar);\n        //\n        // Here, we ensure that such comments stay between the Identifier and the Callee.\n\n\n        var isIdentifierWithFlowAnnotation = n.callee.type === \"Identifier\" && hasFlowAnnotationComment(n.callee.trailingComments);\n\n        if (isIdentifierWithFlowAnnotation) {\n          n.callee.trailingComments[0].printed = true;\n        } // We detect calls on member lookups and possibly print them in a\n        // special chain format. See `printMemberChain` for more info.\n\n\n        if (!isNew && isMemberish(n.callee)) {\n          return printMemberChain(path, options, print);\n        }\n\n        return concat([isNew ? \"new \" : \"\", path.call(print, \"callee\"), optional, isIdentifierWithFlowAnnotation ? \"/*:: \".concat(n.callee.trailingComments[0].value.substring(2).trim(), \" */\") : \"\", printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]);\n      }\n\n    case \"TSInterfaceDeclaration\":\n      if (isNodeStartingWithDeclare(n, options)) {\n        parts.push(\"declare \");\n      }\n\n      parts.push(n[\"abstract\"] ? \"abstract \" : \"\", printTypeScriptModifiers(path, options, print), \"interface \", path.call(print, \"id\"), n.typeParameters ? path.call(print, \"typeParameters\") : \"\", \" \");\n\n      if (n[\"extends\"] && n[\"extends\"].length) {\n        parts.push(group(indent(concat([softline, \"extends \", (n[\"extends\"].length === 1 ? identity : indent)(join(concat([\",\", line]), path.map(print, \"extends\"))), \" \"]))));\n      }\n\n      parts.push(path.call(print, \"body\"));\n      return concat(parts);\n\n    case \"ObjectTypeInternalSlot\":\n      return concat([n[\"static\"] ? \"static \" : \"\", \"[[\", path.call(print, \"id\"), \"]]\", printOptionalToken(path), n.method ? \"\" : \": \", path.call(print, \"value\")]);\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n    case \"ObjectTypeAnnotation\":\n    case \"TSInterfaceBody\":\n    case \"TSTypeLiteral\":\n      {\n        var propertiesField;\n\n        if (n.type === \"TSTypeLiteral\") {\n          propertiesField = \"members\";\n        } else if (n.type === \"TSInterfaceBody\") {\n          propertiesField = \"body\";\n        } else {\n          propertiesField = \"properties\";\n        }\n\n        var isTypeAnnotation = n.type === \"ObjectTypeAnnotation\";\n        var fields = [];\n\n        if (isTypeAnnotation) {\n          fields.push(\"indexers\", \"callProperties\", \"internalSlots\");\n        }\n\n        fields.push(propertiesField);\n        var firstProperty = fields.map(function (field) {\n          return n[field][0];\n        }).sort(function (a, b) {\n          return options.locStart(a) - options.locStart(b);\n        })[0];\n\n        var _parent4 = path.getParentNode(0);\n\n        var isFlowInterfaceLikeBody = isTypeAnnotation && _parent4 && (_parent4.type === \"InterfaceDeclaration\" || _parent4.type === \"DeclareInterface\" || _parent4.type === \"DeclareClass\") && path.getName() === \"body\";\n        var shouldBreak = n.type === \"TSInterfaceBody\" || isFlowInterfaceLikeBody || n.type === \"ObjectPattern\" && _parent4.type !== \"FunctionDeclaration\" && _parent4.type !== \"FunctionExpression\" && _parent4.type !== \"ArrowFunctionExpression\" && _parent4.type !== \"AssignmentPattern\" && _parent4.type !== \"CatchClause\" && n.properties.some(function (property) {\n          return property.value && (property.value.type === \"ObjectPattern\" || property.value.type === \"ArrayPattern\");\n        }) || n.type !== \"ObjectPattern\" && firstProperty && hasNewlineInRange(options.originalText, options.locStart(n), options.locStart(firstProperty));\n        var separator = isFlowInterfaceLikeBody ? \";\" : n.type === \"TSInterfaceBody\" || n.type === \"TSTypeLiteral\" ? ifBreak(semi, \";\") : \",\";\n        var leftBrace = n.exact ? \"{|\" : \"{\";\n        var rightBrace = n.exact ? \"|}\" : \"}\"; // Unfortunately, things are grouped together in the ast can be\n        // interleaved in the source code. So we need to reorder them before\n        // printing them.\n\n        var propsAndLoc = [];\n        fields.forEach(function (field) {\n          path.each(function (childPath) {\n            var node = childPath.getValue();\n            propsAndLoc.push({\n              node: node,\n              printed: print(childPath),\n              loc: options.locStart(node)\n            });\n          }, field);\n        });\n        var separatorParts = [];\n        var props = propsAndLoc.sort(function (a, b) {\n          return a.loc - b.loc;\n        }).map(function (prop) {\n          var result = concat(separatorParts.concat(group(prop.printed)));\n          separatorParts = [separator, line];\n\n          if ((prop.node.type === \"TSPropertySignature\" || prop.node.type === \"TSMethodSignature\" || prop.node.type === \"TSConstructSignatureDeclaration\") && hasNodeIgnoreComment(prop.node)) {\n            separatorParts.shift();\n          }\n\n          if (isNextLineEmpty(options.originalText, prop.node, options)) {\n            separatorParts.push(hardline);\n          }\n\n          return result;\n        });\n\n        if (n.inexact) {\n          props.push(concat(separatorParts.concat(group(\"...\"))));\n        }\n\n        var lastElem = getLast(n[propertiesField]);\n        var canHaveTrailingSeparator = !(lastElem && (lastElem.type === \"RestProperty\" || lastElem.type === \"RestElement\" || hasNodeIgnoreComment(lastElem) || n.inexact));\n        var content;\n\n        if (props.length === 0) {\n          if (!hasDanglingComments(n)) {\n            return concat([leftBrace, rightBrace, printTypeAnnotation(path, options, print)]);\n          }\n\n          content = group(concat([leftBrace, comments.printDanglingComments(path, options), softline, rightBrace, printOptionalToken(path), printTypeAnnotation(path, options, print)]));\n        } else {\n          content = concat([leftBrace, indent(concat([options.bracketSpacing ? line : softline, concat(props)])), ifBreak(canHaveTrailingSeparator && (separator !== \",\" || shouldPrintComma(options)) ? separator : \"\"), concat([options.bracketSpacing ? line : softline, rightBrace]), printOptionalToken(path), printTypeAnnotation(path, options, print)]);\n        } // If we inline the object as first argument of the parent, we don't want\n        // to create another group so that the object breaks before the return\n        // type\n\n\n        var parentParentParent = path.getParentNode(2);\n\n        if (n.type === \"ObjectPattern\" && _parent4 && shouldHugArguments(_parent4) && !n.decorators && _parent4.params[0] === n || shouldHugType(n) && parentParentParent && shouldHugArguments(parentParentParent) && parentParentParent.params[0].typeAnnotation && parentParentParent.params[0].typeAnnotation.typeAnnotation === n) {\n          return content;\n        }\n\n        return group(content, {\n          shouldBreak: shouldBreak\n        });\n      }\n    // Babel 6\n\n    case \"ObjectProperty\": // Non-standard AST node type.\n\n    case \"Property\":\n      if (n.method || n.kind === \"get\" || n.kind === \"set\") {\n        return printMethod(path, options, print);\n      }\n\n      if (n.shorthand) {\n        parts.push(path.call(print, \"value\"));\n      } else {\n        var printedLeft;\n\n        if (n.computed) {\n          printedLeft = concat([\"[\", path.call(print, \"key\"), \"]\"]);\n        } else {\n          printedLeft = printPropertyKey(path, options, print);\n        }\n\n        parts.push(printAssignment(n.key, printedLeft, \":\", n.value, path.call(print, \"value\"), options));\n      }\n\n      return concat(parts);\n    // Babel 6\n\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      if (n.decorators && n.decorators.length !== 0) {\n        parts.push(printDecorators(path, options, print));\n      }\n\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      parts = parts.concat(printObjectMethod(path, options, print));\n      return concat(parts);\n    // Babel 6\n\n    case \"ObjectMethod\":\n      return printObjectMethod(path, options, print);\n\n    case \"Decorator\":\n      return concat([\"@\", path.call(print, \"expression\"), path.call(print, \"callee\")]);\n\n    case \"ArrayExpression\":\n    case \"ArrayPattern\":\n      if (n.elements.length === 0) {\n        if (!hasDanglingComments(n)) {\n          parts.push(\"[]\");\n        } else {\n          parts.push(group(concat([\"[\", comments.printDanglingComments(path, options), softline, \"]\"])));\n        }\n      } else {\n        var _lastElem = getLast(n.elements);\n\n        var canHaveTrailingComma = !(_lastElem && _lastElem.type === \"RestElement\"); // JavaScript allows you to have empty elements in an array which\n        // changes its length based on the number of commas. The algorithm\n        // is that if the last argument is null, we need to force insert\n        // a comma to ensure JavaScript recognizes it.\n        //   [,].length === 1\n        //   [1,].length === 1\n        //   [1,,].length === 2\n        //\n        // Note that getLast returns null if the array is empty, but\n        // we already check for an empty array just above so we are safe\n\n        var needsForcedTrailingComma = canHaveTrailingComma && _lastElem === null;\n        parts.push(group(concat([\"[\", indent(concat([softline, printArrayItems(path, options, \"elements\", print)])), needsForcedTrailingComma ? \",\" : \"\", ifBreak(canHaveTrailingComma && !needsForcedTrailingComma && shouldPrintComma(options) ? \",\" : \"\"), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), softline, \"]\"])));\n      }\n\n      parts.push(printOptionalToken(path), printTypeAnnotation(path, options, print));\n      return concat(parts);\n\n    case \"SequenceExpression\":\n      {\n        var _parent5 = path.getParentNode(0);\n\n        if (_parent5.type === \"ExpressionStatement\" || _parent5.type === \"ForStatement\") {\n          // For ExpressionStatements and for-loop heads, which are among\n          // the few places a SequenceExpression appears unparenthesized, we want\n          // to indent expressions after the first.\n          var _parts2 = [];\n          path.each(function (p) {\n            if (p.getName() === 0) {\n              _parts2.push(print(p));\n            } else {\n              _parts2.push(\",\", indent(concat([line, print(p)])));\n            }\n          }, \"expressions\");\n          return group(concat(_parts2));\n        }\n\n        return group(concat([join(concat([\",\", line]), path.map(print, \"expressions\"))]));\n      }\n\n    case \"ThisExpression\":\n      return \"this\";\n\n    case \"Super\":\n      return \"super\";\n\n    case \"NullLiteral\":\n      // Babel 6 Literal split\n      return \"null\";\n\n    case \"RegExpLiteral\":\n      // Babel 6 Literal split\n      return printRegex(n);\n\n    case \"NumericLiteral\":\n      // Babel 6 Literal split\n      return printNumber(n.extra.raw);\n\n    case \"BigIntLiteral\":\n      return concat([printNumber(n.extra ? n.extra.rawValue : // TypeScript\n      n.value), \"n\"]);\n\n    case \"BooleanLiteral\": // Babel 6 Literal split\n\n    case \"StringLiteral\": // Babel 6 Literal split\n\n    case \"Literal\":\n      {\n        if (n.regex) {\n          return printRegex(n.regex);\n        }\n\n        if (typeof n.value === \"number\") {\n          return printNumber(n.raw);\n        }\n\n        if (typeof n.value !== \"string\") {\n          return \"\" + n.value;\n        } // TypeScript workaround for https://github.com/JamesHenry/typescript-estree/issues/2\n        // See corresponding workaround in needs-parens.js\n\n\n        var grandParent = path.getParentNode(1);\n        var isTypeScriptDirective = options.parser === \"typescript\" && typeof n.value === \"string\" && grandParent && (grandParent.type === \"Program\" || grandParent.type === \"BlockStatement\");\n        return nodeStr(n, options, isTypeScriptDirective);\n      }\n\n    case \"Directive\":\n      return path.call(print, \"value\");\n    // Babel 6\n\n    case \"DirectiveLiteral\":\n      return nodeStr(n, options);\n\n    case \"UnaryExpression\":\n      parts.push(n.operator);\n\n      if (/[a-z]$/.test(n.operator)) {\n        parts.push(\" \");\n      }\n\n      if (n.argument.comments && n.argument.comments.length > 0) {\n        parts.push(group(concat([\"(\", indent(concat([softline, path.call(print, \"argument\")])), softline, \")\"])));\n      } else {\n        parts.push(path.call(print, \"argument\"));\n      }\n\n      return concat(parts);\n\n    case \"UpdateExpression\":\n      parts.push(path.call(print, \"argument\"), n.operator);\n\n      if (n.prefix) {\n        parts.reverse();\n      }\n\n      return concat(parts);\n\n    case \"ConditionalExpression\":\n      return printTernaryOperator(path, options, print, {\n        beforeParts: function beforeParts() {\n          return [path.call(print, \"test\")];\n        },\n        afterParts: function afterParts(breakClosingParen) {\n          return [breakClosingParen ? softline : \"\"];\n        },\n        shouldCheckJsx: true,\n        conditionalNodeType: \"ConditionalExpression\",\n        consequentNodePropertyName: \"consequent\",\n        alternateNodePropertyName: \"alternate\",\n        testNodePropertyName: \"test\",\n        breakNested: true\n      });\n\n    case \"VariableDeclaration\":\n      {\n        var printed = path.map(function (childPath) {\n          return print(childPath);\n        }, \"declarations\"); // We generally want to terminate all variable declarations with a\n        // semicolon, except when they in the () part of for loops.\n\n        var parentNode = path.getParentNode();\n        var isParentForLoop = parentNode.type === \"ForStatement\" || parentNode.type === \"ForInStatement\" || parentNode.type === \"ForOfStatement\" || parentNode.type === \"ForAwaitStatement\";\n        var hasValue = n.declarations.some(function (decl) {\n          return decl.init;\n        });\n        var firstVariable;\n\n        if (printed.length === 1 && !n.declarations[0].comments) {\n          firstVariable = printed[0];\n        } else if (printed.length > 0) {\n          // Indent first var to comply with eslint one-var rule\n          firstVariable = indent(printed[0]);\n        }\n\n        parts = [isNodeStartingWithDeclare(n, options) ? \"declare \" : \"\", n.kind, firstVariable ? concat([\" \", firstVariable]) : \"\", indent(concat(printed.slice(1).map(function (p) {\n          return concat([\",\", hasValue && !isParentForLoop ? hardline : line, p]);\n        })))];\n\n        if (!(isParentForLoop && parentNode.body !== n)) {\n          parts.push(semi);\n        }\n\n        return group(concat(parts));\n      }\n\n    case \"TSTypeAliasDeclaration\":\n      {\n        if (n.declare) {\n          parts.push(\"declare \");\n        }\n\n        var _printed = printAssignmentRight(n.id, n.typeAnnotation, n.typeAnnotation && path.call(print, \"typeAnnotation\"), options);\n\n        parts.push(\"type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" =\", _printed, semi);\n        return group(concat(parts));\n      }\n\n    case \"VariableDeclarator\":\n      return printAssignment(n.id, path.call(print, \"id\"), \" =\", n.init, n.init && path.call(print, \"init\"), options);\n\n    case \"WithStatement\":\n      return group(concat([\"with (\", path.call(print, \"object\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n    case \"IfStatement\":\n      {\n        var con = adjustClause(n.consequent, path.call(print, \"consequent\"));\n        var opening = group(concat([\"if (\", group(concat([indent(concat([softline, path.call(print, \"test\")])), softline])), \")\", con]));\n        parts.push(opening);\n\n        if (n.alternate) {\n          var commentOnOwnLine = hasTrailingComment(n.consequent) && n.consequent.comments.some(function (comment) {\n            return comment.trailing && !handleComments.isBlockComment(comment);\n          }) || needsHardlineAfterDanglingComment(n);\n          var elseOnSameLine = n.consequent.type === \"BlockStatement\" && !commentOnOwnLine;\n          parts.push(elseOnSameLine ? \" \" : hardline);\n\n          if (hasDanglingComments(n)) {\n            parts.push(comments.printDanglingComments(path, options, true), commentOnOwnLine ? hardline : \" \");\n          }\n\n          parts.push(\"else\", group(adjustClause(n.alternate, path.call(print, \"alternate\"), n.alternate.type === \"IfStatement\")));\n        }\n\n        return concat(parts);\n      }\n\n    case \"ForStatement\":\n      {\n        var _body = adjustClause(n.body, path.call(print, \"body\")); // We want to keep dangling comments above the loop to stay consistent.\n        // Any comment positioned between the for statement and the parentheses\n        // is going to be printed before the statement.\n\n\n        var _dangling = comments.printDanglingComments(path, options,\n        /* sameLine */\n        true);\n\n        var printedComments = _dangling ? concat([_dangling, softline]) : \"\";\n\n        if (!n.init && !n.test && !n.update) {\n          return concat([printedComments, group(concat([\"for (;;)\", _body]))]);\n        }\n\n        return concat([printedComments, group(concat([\"for (\", group(concat([indent(concat([softline, path.call(print, \"init\"), \";\", line, path.call(print, \"test\"), \";\", line, path.call(print, \"update\")])), softline])), \")\", _body]))]);\n      }\n\n    case \"WhileStatement\":\n      return group(concat([\"while (\", group(concat([indent(concat([softline, path.call(print, \"test\")])), softline])), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n    case \"ForInStatement\":\n      // Note: esprima can't actually parse \"for each (\".\n      return group(concat([n.each ? \"for each (\" : \"for (\", path.call(print, \"left\"), \" in \", path.call(print, \"right\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n    case \"ForOfStatement\":\n    case \"ForAwaitStatement\":\n      {\n        // Babel 7 removed ForAwaitStatement in favor of ForOfStatement\n        // with `\"await\": true`:\n        // https://github.com/estree/estree/pull/138\n        var isAwait = n.type === \"ForAwaitStatement\" || n[\"await\"];\n        return group(concat([\"for\", isAwait ? \" await\" : \"\", \" (\", path.call(print, \"left\"), \" of \", path.call(print, \"right\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n      }\n\n    case \"DoWhileStatement\":\n      {\n        var clause = adjustClause(n.body, path.call(print, \"body\"));\n        var doBody = group(concat([\"do\", clause]));\n        parts = [doBody];\n\n        if (n.body.type === \"BlockStatement\") {\n          parts.push(\" \");\n        } else {\n          parts.push(hardline);\n        }\n\n        parts.push(\"while (\");\n        parts.push(group(concat([indent(concat([softline, path.call(print, \"test\")])), softline])), \")\", semi);\n        return concat(parts);\n      }\n\n    case \"DoExpression\":\n      return concat([\"do \", path.call(print, \"body\")]);\n\n    case \"BreakStatement\":\n      parts.push(\"break\");\n\n      if (n.label) {\n        parts.push(\" \", path.call(print, \"label\"));\n      }\n\n      parts.push(semi);\n      return concat(parts);\n\n    case \"ContinueStatement\":\n      parts.push(\"continue\");\n\n      if (n.label) {\n        parts.push(\" \", path.call(print, \"label\"));\n      }\n\n      parts.push(semi);\n      return concat(parts);\n\n    case \"LabeledStatement\":\n      if (n.body.type === \"EmptyStatement\") {\n        return concat([path.call(print, \"label\"), \":;\"]);\n      }\n\n      return concat([path.call(print, \"label\"), \": \", path.call(print, \"body\")]);\n\n    case \"TryStatement\":\n      return concat([\"try \", path.call(print, \"block\"), n.handler ? concat([\" \", path.call(print, \"handler\")]) : \"\", n.finalizer ? concat([\" finally \", path.call(print, \"finalizer\")]) : \"\"]);\n\n    case \"CatchClause\":\n      if (n.param) {\n        var hasComments = n.param.comments && n.param.comments.some(function (comment) {\n          return !handleComments.isBlockComment(comment) || comment.leading && hasNewline(options.originalText, options.locEnd(comment)) || comment.trailing && hasNewline(options.originalText, options.locStart(comment), {\n            backwards: true\n          });\n        });\n        var param = path.call(print, \"param\");\n        return concat([\"catch \", hasComments ? concat([\"(\", indent(concat([softline, param])), softline, \") \"]) : concat([\"(\", param, \") \"]), path.call(print, \"body\")]);\n      }\n\n      return concat([\"catch \", path.call(print, \"body\")]);\n\n    case \"ThrowStatement\":\n      return concat([\"throw \", path.call(print, \"argument\"), semi]);\n    // Note: ignoring n.lexical because it has no printing consequences.\n\n    case \"SwitchStatement\":\n      return concat([group(concat([\"switch (\", indent(concat([softline, path.call(print, \"discriminant\")])), softline, \")\"])), \" {\", n.cases.length > 0 ? indent(concat([hardline, join(hardline, path.map(function (casePath) {\n        var caseNode = casePath.getValue();\n        return concat([casePath.call(print), n.cases.indexOf(caseNode) !== n.cases.length - 1 && isNextLineEmpty(options.originalText, caseNode, options) ? hardline : \"\"]);\n      }, \"cases\"))])) : \"\", hardline, \"}\"]);\n\n    case \"SwitchCase\":\n      {\n        if (n.test) {\n          parts.push(\"case \", path.call(print, \"test\"), \":\");\n        } else {\n          parts.push(\"default:\");\n        }\n\n        var consequent = n.consequent.filter(function (node) {\n          return node.type !== \"EmptyStatement\";\n        });\n\n        if (consequent.length > 0) {\n          var cons = path.call(function (consequentPath) {\n            return printStatementSequence(consequentPath, options, print);\n          }, \"consequent\");\n          parts.push(consequent.length === 1 && consequent[0].type === \"BlockStatement\" ? concat([\" \", cons]) : indent(concat([hardline, cons])));\n        }\n\n        return concat(parts);\n      }\n    // JSX extensions below.\n\n    case \"DebuggerStatement\":\n      return concat([\"debugger\", semi]);\n\n    case \"JSXAttribute\":\n      parts.push(path.call(print, \"name\"));\n\n      if (n.value) {\n        var res;\n\n        if (isStringLiteral(n.value)) {\n          var raw = rawText(n.value); // Unescape all quotes so we get an accurate preferred quote\n\n          var _final = raw.replace(/&apos;/g, \"'\").replace(/&quot;/g, '\"');\n\n          var quote = getPreferredQuote(_final, options.jsxSingleQuote ? \"'\" : '\"');\n\n          var _escape = quote === \"'\" ? \"&apos;\" : \"&quot;\";\n\n          _final = _final.replace(new RegExp(quote, \"g\"), _escape);\n          res = concat([quote, _final, quote]);\n        } else {\n          res = path.call(print, \"value\");\n        }\n\n        parts.push(\"=\", res);\n      }\n\n      return concat(parts);\n\n    case \"JSXIdentifier\":\n      return \"\" + n.name;\n\n    case \"JSXNamespacedName\":\n      return join(\":\", [path.call(print, \"namespace\"), path.call(print, \"name\")]);\n\n    case \"JSXMemberExpression\":\n      return join(\".\", [path.call(print, \"object\"), path.call(print, \"property\")]);\n\n    case \"TSQualifiedName\":\n      return join(\".\", [path.call(print, \"left\"), path.call(print, \"right\")]);\n\n    case \"JSXSpreadAttribute\":\n    case \"JSXSpreadChild\":\n      {\n        return concat([\"{\", path.call(function (p) {\n          var printed = concat([\"...\", print(p)]);\n          var n = p.getValue();\n\n          if (!n.comments || !n.comments.length) {\n            return printed;\n          }\n\n          return concat([indent(concat([softline, comments.printComments(p, function () {\n            return printed;\n          }, options)])), softline]);\n        }, n.type === \"JSXSpreadAttribute\" ? \"argument\" : \"expression\"), \"}\"]);\n      }\n\n    case \"JSXExpressionContainer\":\n      {\n        var _parent6 = path.getParentNode(0);\n\n        var preventInline = _parent6.type === \"JSXAttribute\" && n.expression.comments && n.expression.comments.length > 0;\n\n        var _shouldInline = !preventInline && (n.expression.type === \"ArrayExpression\" || n.expression.type === \"ObjectExpression\" || n.expression.type === \"ArrowFunctionExpression\" || n.expression.type === \"CallExpression\" || n.expression.type === \"OptionalCallExpression\" || n.expression.type === \"FunctionExpression\" || n.expression.type === \"JSXEmptyExpression\" || n.expression.type === \"TemplateLiteral\" || n.expression.type === \"TaggedTemplateExpression\" || n.expression.type === \"DoExpression\" || isJSXNode(_parent6) && (n.expression.type === \"ConditionalExpression\" || isBinaryish(n.expression)));\n\n        if (_shouldInline) {\n          return group(concat([\"{\", path.call(print, \"expression\"), lineSuffixBoundary, \"}\"]));\n        }\n\n        return group(concat([\"{\", indent(concat([softline, path.call(print, \"expression\")])), softline, lineSuffixBoundary, \"}\"]));\n      }\n\n    case \"JSXFragment\":\n    case \"JSXElement\":\n      {\n        var elem = comments.printComments(path, function () {\n          return printJSXElement(path, options, print);\n        }, options);\n        return maybeWrapJSXElementInParens(path, elem);\n      }\n\n    case \"JSXOpeningElement\":\n      {\n        var _n = path.getValue();\n\n        var nameHasComments = _n.name && _n.name.comments && _n.name.comments.length > 0 || _n.typeParameters && _n.typeParameters.comments && _n.typeParameters.comments.length > 0; // Don't break self-closing elements with no attributes and no comments\n\n        if (_n.selfClosing && !_n.attributes.length && !nameHasComments) {\n          return concat([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), \" />\"]);\n        } // don't break up opening elements with a single long text attribute\n\n\n        if (_n.attributes && _n.attributes.length === 1 && _n.attributes[0].value && isStringLiteral(_n.attributes[0].value) && !_n.attributes[0].value.value.includes(\"\\n\") && // We should break for the following cases:\n        // <div\n        //   // comment\n        //   attr=\"value\"\n        // >\n        // <div\n        //   attr=\"value\"\n        //   // comment\n        // >\n        !nameHasComments && (!_n.attributes[0].comments || !_n.attributes[0].comments.length)) {\n          return group(concat([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), \" \", concat(path.map(print, \"attributes\")), _n.selfClosing ? \" />\" : \">\"]));\n        }\n\n        var lastAttrHasTrailingComments = _n.attributes.length && hasTrailingComment(getLast(_n.attributes));\n        var bracketSameLine = // Simple tags (no attributes and no comment in tag name) should be\n        // kept unbroken regardless of `jsxBracketSameLine`\n        !_n.attributes.length && !nameHasComments || options.jsxBracketSameLine && ( // We should print the bracket in a new line for the following cases:\n        // <div\n        //   // comment\n        // >\n        // <div\n        //   attr // comment\n        // >\n        !nameHasComments || _n.attributes.length) && !lastAttrHasTrailingComments; // We should print the opening element expanded if any prop value is a\n        // string literal with newlines\n\n        var _shouldBreak = _n.attributes && _n.attributes.some(function (attr) {\n          return attr.value && isStringLiteral(attr.value) && attr.value.value.includes(\"\\n\");\n        });\n\n        return group(concat([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), concat([indent(concat(path.map(function (attr) {\n          return concat([line, print(attr)]);\n        }, \"attributes\"))), _n.selfClosing ? line : bracketSameLine ? \">\" : softline]), _n.selfClosing ? \"/>\" : bracketSameLine ? \"\" : \">\"]), {\n          shouldBreak: _shouldBreak\n        });\n      }\n\n    case \"JSXClosingElement\":\n      return concat([\"</\", path.call(print, \"name\"), \">\"]);\n\n    case \"JSXOpeningFragment\":\n    case \"JSXClosingFragment\":\n      {\n        var hasComment = n.comments && n.comments.length;\n        var hasOwnLineComment = hasComment && !n.comments.every(handleComments.isBlockComment);\n        var isOpeningFragment = n.type === \"JSXOpeningFragment\";\n        return concat([isOpeningFragment ? \"<\" : \"</\", indent(concat([hasOwnLineComment ? hardline : hasComment && !isOpeningFragment ? \" \" : \"\", comments.printDanglingComments(path, options, true)])), hasOwnLineComment ? hardline : \"\", \">\"]);\n      }\n\n    case \"JSXText\":\n      /* istanbul ignore next */\n      throw new Error(\"JSXTest should be handled by JSXElement\");\n\n    case \"JSXEmptyExpression\":\n      {\n        var requiresHardline = n.comments && !n.comments.every(handleComments.isBlockComment);\n        return concat([comments.printDanglingComments(path, options,\n        /* sameIndent */\n        !requiresHardline), requiresHardline ? hardline : \"\"]);\n      }\n\n    case \"ClassBody\":\n      if (!n.comments && n.body.length === 0) {\n        return \"{}\";\n      }\n\n      return concat([\"{\", n.body.length > 0 ? indent(concat([hardline, path.call(function (bodyPath) {\n        return printStatementSequence(bodyPath, options, print);\n      }, \"body\")])) : comments.printDanglingComments(path, options), hardline, \"}\"]);\n\n    case \"ClassProperty\":\n    case \"TSAbstractClassProperty\":\n    case \"ClassPrivateProperty\":\n      {\n        if (n.decorators && n.decorators.length !== 0) {\n          parts.push(printDecorators(path, options, print));\n        }\n\n        if (n.accessibility) {\n          parts.push(n.accessibility + \" \");\n        }\n\n        if (n[\"static\"]) {\n          parts.push(\"static \");\n        }\n\n        if (n.type === \"TSAbstractClassProperty\") {\n          parts.push(\"abstract \");\n        }\n\n        if (n.readonly) {\n          parts.push(\"readonly \");\n        }\n\n        var variance = getFlowVariance(n);\n\n        if (variance) {\n          parts.push(variance);\n        }\n\n        if (n.computed) {\n          parts.push(\"[\", path.call(print, \"key\"), \"]\");\n        } else {\n          parts.push(printPropertyKey(path, options, print));\n        }\n\n        parts.push(printOptionalToken(path));\n        parts.push(printTypeAnnotation(path, options, print));\n\n        if (n.value) {\n          parts.push(\" =\", printAssignmentRight(n.key, n.value, path.call(print, \"value\"), options));\n        }\n\n        parts.push(semi);\n        return group(concat(parts));\n      }\n\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      if (isNodeStartingWithDeclare(n, options)) {\n        parts.push(\"declare \");\n      }\n\n      parts.push(concat(printClass(path, options, print)));\n      return concat(parts);\n\n    case \"TSInterfaceHeritage\":\n      parts.push(path.call(print, \"expression\"));\n\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n\n      return concat(parts);\n\n    case \"TemplateElement\":\n      return join(literalline, n.value.raw.split(/\\r?\\n/g));\n\n    case \"TemplateLiteral\":\n      {\n        var expressions = path.map(print, \"expressions\");\n\n        var _parentNode = path.getParentNode();\n\n        if (isJestEachTemplateLiteral(n, _parentNode)) {\n          var _printed2 = printJestEachTemplateLiteral(n, expressions, options);\n\n          if (_printed2) {\n            return _printed2;\n          }\n        }\n\n        var isSimple = isSimpleTemplateLiteral(n);\n\n        if (isSimple) {\n          expressions = expressions.map(function (doc) {\n            return printDocToString(doc, Object.assign({}, options, {\n              printWidth: Infinity\n            })).formatted;\n          });\n        }\n\n        parts.push(lineSuffixBoundary, \"`\");\n        path.each(function (childPath) {\n          var i = childPath.getName();\n          parts.push(print(childPath));\n\n          if (i < expressions.length) {\n            // For a template literal of the following form:\n            //   `someQuery {\n            //     ${call({\n            //       a,\n            //       b,\n            //     })}\n            //   }`\n            // the expression is on its own line (there is a \\n in the previous\n            // quasi literal), therefore we want to indent the JavaScript\n            // expression inside at the beginning of ${ instead of the beginning\n            // of the `.\n            var tabWidth = options.tabWidth;\n            var quasi = childPath.getValue();\n            var indentSize = getIndentSize(quasi.value.raw, tabWidth);\n            var _printed3 = expressions[i];\n\n            if (!isSimple) {\n              // Breaks at the template element boundaries (${ and }) are preferred to breaking\n              // in the middle of a MemberExpression\n              if (n.expressions[i].comments && n.expressions[i].comments.length || n.expressions[i].type === \"MemberExpression\" || n.expressions[i].type === \"OptionalMemberExpression\" || n.expressions[i].type === \"ConditionalExpression\") {\n                _printed3 = concat([indent(concat([softline, _printed3])), softline]);\n              }\n            }\n\n            var aligned = indentSize === 0 && quasi.value.raw.endsWith(\"\\n\") ? align(-Infinity, _printed3) : addAlignmentToDoc(_printed3, indentSize, tabWidth);\n            parts.push(group(concat([\"${\", aligned, lineSuffixBoundary, \"}\"])));\n          }\n        }, \"quasis\");\n        parts.push(\"`\");\n        return concat(parts);\n      }\n    // These types are unprintable because they serve as abstract\n    // supertypes for other (printable) types.\n\n    case \"TaggedTemplateExpression\":\n      return concat([path.call(print, \"tag\"), path.call(print, \"typeParameters\"), path.call(print, \"quasi\")]);\n\n    case \"Node\":\n    case \"Printable\":\n    case \"SourceLocation\":\n    case \"Position\":\n    case \"Statement\":\n    case \"Function\":\n    case \"Pattern\":\n    case \"Expression\":\n    case \"Declaration\":\n    case \"Specifier\":\n    case \"NamedSpecifier\":\n    case \"Comment\":\n    case \"MemberTypeAnnotation\": // Flow\n\n    case \"Type\":\n      /* istanbul ignore next */\n      throw new Error(\"unprintable type: \" + JSON.stringify(n.type));\n    // Type Annotations for Facebook Flow, typically stripped out or\n    // transformed away before printing.\n\n    case \"TypeAnnotation\":\n    case \"TSTypeAnnotation\":\n      if (n.typeAnnotation) {\n        return path.call(print, \"typeAnnotation\");\n      }\n      /* istanbul ignore next */\n\n\n      return \"\";\n\n    case \"TSTupleType\":\n    case \"TupleTypeAnnotation\":\n      {\n        var typesField = n.type === \"TSTupleType\" ? \"elementTypes\" : \"types\";\n        return group(concat([\"[\", indent(concat([softline, printArrayItems(path, options, typesField, print)])), ifBreak(shouldPrintComma(options, \"all\") ? \",\" : \"\"), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), softline, \"]\"]));\n      }\n\n    case \"ExistsTypeAnnotation\":\n      return \"*\";\n\n    case \"EmptyTypeAnnotation\":\n      return \"empty\";\n\n    case \"AnyTypeAnnotation\":\n      return \"any\";\n\n    case \"MixedTypeAnnotation\":\n      return \"mixed\";\n\n    case \"ArrayTypeAnnotation\":\n      return concat([path.call(print, \"elementType\"), \"[]\"]);\n\n    case \"BooleanTypeAnnotation\":\n      return \"boolean\";\n\n    case \"BooleanLiteralTypeAnnotation\":\n      return \"\" + n.value;\n\n    case \"DeclareClass\":\n      return printFlowDeclaration(path, printClass(path, options, print));\n\n    case \"TSDeclareFunction\":\n      // For TypeScript the TSDeclareFunction node shares the AST\n      // structure with FunctionDeclaration\n      return concat([n.declare ? \"declare \" : \"\", printFunctionDeclaration(path, print, options), semi]);\n\n    case \"DeclareFunction\":\n      return printFlowDeclaration(path, [\"function \", path.call(print, \"id\"), n.predicate ? \" \" : \"\", path.call(print, \"predicate\"), semi]);\n\n    case \"DeclareModule\":\n      return printFlowDeclaration(path, [\"module \", path.call(print, \"id\"), \" \", path.call(print, \"body\")]);\n\n    case \"DeclareModuleExports\":\n      return printFlowDeclaration(path, [\"module.exports\", \": \", path.call(print, \"typeAnnotation\"), semi]);\n\n    case \"DeclareVariable\":\n      return printFlowDeclaration(path, [\"var \", path.call(print, \"id\"), semi]);\n\n    case \"DeclareExportAllDeclaration\":\n      return concat([\"declare export * from \", path.call(print, \"source\")]);\n\n    case \"DeclareExportDeclaration\":\n      return concat([\"declare \", printExportDeclaration(path, options, print)]);\n\n    case \"DeclareOpaqueType\":\n    case \"OpaqueType\":\n      {\n        parts.push(\"opaque type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n\n        if (n.supertype) {\n          parts.push(\": \", path.call(print, \"supertype\"));\n        }\n\n        if (n.impltype) {\n          parts.push(\" = \", path.call(print, \"impltype\"));\n        }\n\n        parts.push(semi);\n\n        if (n.type === \"DeclareOpaqueType\") {\n          return printFlowDeclaration(path, parts);\n        }\n\n        return concat(parts);\n      }\n\n    case \"FunctionTypeAnnotation\":\n    case \"TSFunctionType\":\n      {\n        // FunctionTypeAnnotation is ambiguous:\n        // declare function foo(a: B): void; OR\n        // var A: (a: B) => void;\n        var _parent7 = path.getParentNode(0);\n\n        var _parentParent2 = path.getParentNode(1);\n\n        var _parentParentParent = path.getParentNode(2);\n\n        var isArrowFunctionTypeAnnotation = n.type === \"TSFunctionType\" || !((_parent7.type === \"ObjectTypeProperty\" || _parent7.type === \"ObjectTypeInternalSlot\") && !getFlowVariance(_parent7) && !_parent7.optional && options.locStart(_parent7) === options.locStart(n) || _parent7.type === \"ObjectTypeCallProperty\" || _parentParentParent && _parentParentParent.type === \"DeclareFunction\");\n        var needsColon = isArrowFunctionTypeAnnotation && (_parent7.type === \"TypeAnnotation\" || _parent7.type === \"TSTypeAnnotation\"); // Sadly we can't put it inside of FastPath::needsColon because we are\n        // printing \":\" as part of the expression and it would put parenthesis\n        // around :(\n\n        var needsParens = needsColon && isArrowFunctionTypeAnnotation && (_parent7.type === \"TypeAnnotation\" || _parent7.type === \"TSTypeAnnotation\") && _parentParent2.type === \"ArrowFunctionExpression\";\n\n        if (isObjectTypePropertyAFunction(_parent7, options)) {\n          isArrowFunctionTypeAnnotation = true;\n          needsColon = true;\n        }\n\n        if (needsParens) {\n          parts.push(\"(\");\n        }\n\n        parts.push(printFunctionParams(path, print, options,\n        /* expandArg */\n        false,\n        /* printTypeParams */\n        true)); // The returnType is not wrapped in a TypeAnnotation, so the colon\n        // needs to be added separately.\n\n        if (n.returnType || n.predicate || n.typeAnnotation) {\n          parts.push(isArrowFunctionTypeAnnotation ? \" => \" : \": \", path.call(print, \"returnType\"), path.call(print, \"predicate\"), path.call(print, \"typeAnnotation\"));\n        }\n\n        if (needsParens) {\n          parts.push(\")\");\n        }\n\n        return group(concat(parts));\n      }\n\n    case \"TSRestType\":\n      return concat([\"...\", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSOptionalType\":\n      return concat([path.call(print, \"typeAnnotation\"), \"?\"]);\n\n    case \"FunctionTypeParam\":\n      return concat([path.call(print, \"name\"), printOptionalToken(path), n.name ? \": \" : \"\", path.call(print, \"typeAnnotation\")]);\n\n    case \"GenericTypeAnnotation\":\n      return concat([path.call(print, \"id\"), path.call(print, \"typeParameters\")]);\n\n    case \"DeclareInterface\":\n    case \"InterfaceDeclaration\":\n    case \"InterfaceTypeAnnotation\":\n      {\n        if (n.type === \"DeclareInterface\" || isNodeStartingWithDeclare(n, options)) {\n          parts.push(\"declare \");\n        }\n\n        parts.push(\"interface\");\n\n        if (n.type === \"DeclareInterface\" || n.type === \"InterfaceDeclaration\") {\n          parts.push(\" \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n        }\n\n        if (n[\"extends\"].length > 0) {\n          parts.push(group(indent(concat([line, \"extends \", (n[\"extends\"].length === 1 ? identity : indent)(join(concat([\",\", line]), path.map(print, \"extends\")))]))));\n        }\n\n        parts.push(\" \", path.call(print, \"body\"));\n        return group(concat(parts));\n      }\n\n    case \"ClassImplements\":\n    case \"InterfaceExtends\":\n      return concat([path.call(print, \"id\"), path.call(print, \"typeParameters\")]);\n\n    case \"TSClassImplements\":\n      return concat([path.call(print, \"expression\"), path.call(print, \"typeParameters\")]);\n\n    case \"TSIntersectionType\":\n    case \"IntersectionTypeAnnotation\":\n      {\n        var types = path.map(print, \"types\");\n        var result = [];\n        var wasIndented = false;\n\n        for (var _i = 0; _i < types.length; ++_i) {\n          if (_i === 0) {\n            result.push(types[_i]);\n          } else if (isObjectType(n.types[_i - 1]) && isObjectType(n.types[_i])) {\n            // If both are objects, don't indent\n            result.push(concat([\" & \", wasIndented ? indent(types[_i]) : types[_i]]));\n          } else if (!isObjectType(n.types[_i - 1]) && !isObjectType(n.types[_i])) {\n            // If no object is involved, go to the next line if it breaks\n            result.push(indent(concat([\" &\", line, types[_i]])));\n          } else {\n            // If you go from object to non-object or vis-versa, then inline it\n            if (_i > 1) {\n              wasIndented = true;\n            }\n\n            result.push(\" & \", _i > 1 ? indent(types[_i]) : types[_i]);\n          }\n        }\n\n        return group(concat(result));\n      }\n\n    case \"TSUnionType\":\n    case \"UnionTypeAnnotation\":\n      {\n        // single-line variation\n        // A | B | C\n        // multi-line variation\n        // | A\n        // | B\n        // | C\n        var _parent8 = path.getParentNode(); // If there's a leading comment, the parent is doing the indentation\n\n\n        var shouldIndent = _parent8.type !== \"TypeParameterInstantiation\" && _parent8.type !== \"TSTypeParameterInstantiation\" && _parent8.type !== \"GenericTypeAnnotation\" && _parent8.type !== \"TSTypeReference\" && _parent8.type !== \"TSTypeAssertion\" && !(_parent8.type === \"FunctionTypeParam\" && !_parent8.name) && !((_parent8.type === \"TypeAlias\" || _parent8.type === \"VariableDeclarator\" || _parent8.type === \"TSTypeAliasDeclaration\") && hasLeadingOwnLineComment(options.originalText, n, options)); // {\n        //   a: string\n        // } | null | void\n        // should be inlined and not be printed in the multi-line variant\n\n        var shouldHug = shouldHugType(n); // We want to align the children but without its comment, so it looks like\n        // | child1\n        // // comment\n        // | child2\n\n        var _printed4 = path.map(function (typePath) {\n          var printedType = typePath.call(print);\n\n          if (!shouldHug) {\n            printedType = align(2, printedType);\n          }\n\n          return comments.printComments(typePath, function () {\n            return printedType;\n          }, options);\n        }, \"types\");\n\n        if (shouldHug) {\n          return join(\" | \", _printed4);\n        }\n\n        var shouldAddStartLine = shouldIndent && !hasLeadingOwnLineComment(options.originalText, n, options);\n        var code = concat([ifBreak(concat([shouldAddStartLine ? line : \"\", \"| \"])), join(concat([line, \"| \"]), _printed4)]);\n        var hasParens;\n\n        if (n.type === \"TSUnionType\") {\n          var _grandParent = path.getNode(2);\n\n          var greatGrandParent = path.getParentNode(2);\n          var greatGreatGrandParent = path.getParentNode(3);\n          hasParens = _parent8.type === \"TSParenthesizedType\" && (_grandParent.type === \"TSAsExpression\" || _grandParent.type === \"TSUnionType\" || _grandParent.type === \"TSIntersectionType\" || _grandParent.type === \"TSTypeOperator\" || _grandParent.type === \"TSArrayType\") || greatGrandParent && greatGrandParent.type === \"TSParenthesizedType\" && greatGreatGrandParent && (greatGreatGrandParent.type === \"TSUnionType\" || greatGreatGrandParent.type === \"TSIntersectionType\");\n        } else {\n          hasParens = pathNeedsParens(path, options);\n        }\n\n        if (hasParens) {\n          return group(concat([indent(code), softline]));\n        }\n\n        return group(shouldIndent ? indent(code) : code);\n      }\n\n    case \"NullableTypeAnnotation\":\n      return concat([\"?\", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSNullKeyword\":\n    case \"NullLiteralTypeAnnotation\":\n      return \"null\";\n\n    case \"ThisTypeAnnotation\":\n      return \"this\";\n\n    case \"NumberTypeAnnotation\":\n      return \"number\";\n\n    case \"ObjectTypeCallProperty\":\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      parts.push(path.call(print, \"value\"));\n      return concat(parts);\n\n    case \"ObjectTypeIndexer\":\n      {\n        var _variance = getFlowVariance(n);\n\n        return concat([_variance || \"\", \"[\", path.call(print, \"id\"), n.id ? \": \" : \"\", path.call(print, \"key\"), \"]: \", path.call(print, \"value\")]);\n      }\n\n    case \"ObjectTypeProperty\":\n      {\n        var _variance2 = getFlowVariance(n);\n\n        var modifier = \"\";\n\n        if (n.proto) {\n          modifier = \"proto \";\n        } else if (n[\"static\"]) {\n          modifier = \"static \";\n        }\n\n        return concat([modifier, isGetterOrSetter(n) ? n.kind + \" \" : \"\", _variance2 || \"\", printPropertyKey(path, options, print), printOptionalToken(path), isFunctionNotation(n, options) ? \"\" : \": \", path.call(print, \"value\")]);\n      }\n\n    case \"QualifiedTypeIdentifier\":\n      return concat([path.call(print, \"qualification\"), \".\", path.call(print, \"id\")]);\n\n    case \"StringLiteralTypeAnnotation\":\n      return nodeStr(n, options);\n\n    case \"NumberLiteralTypeAnnotation\":\n      assert.strictEqual(_typeof(n.value), \"number\");\n\n      if (n.extra != null) {\n        return printNumber(n.extra.raw);\n      }\n\n      return printNumber(n.raw);\n\n    case \"StringTypeAnnotation\":\n      return \"string\";\n\n    case \"DeclareTypeAlias\":\n    case \"TypeAlias\":\n      {\n        if (n.type === \"DeclareTypeAlias\" || isNodeStartingWithDeclare(n, options)) {\n          parts.push(\"declare \");\n        }\n\n        var _printed5 = printAssignmentRight(n.id, n.right, path.call(print, \"right\"), options);\n\n        parts.push(\"type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" =\", _printed5, semi);\n        return group(concat(parts));\n      }\n\n    case \"TypeCastExpression\":\n      {\n        var value = path.getValue(); // Flow supports a comment syntax for specifying type annotations: https://flow.org/en/docs/types/comments/.\n        // Unfortunately, its parser doesn't differentiate between comment annotations and regular\n        // annotations when producing an AST. So to preserve parentheses around type casts that use\n        // the comment syntax, we need to hackily read the source itself to see if the code contains\n        // a type annotation comment.\n        //\n        // Note that we're able to use the normal whitespace regex here because the Flow parser has\n        // already deemed this AST node to be a type cast. Only the Babel parser needs the\n        // non-line-break whitespace regex, which is why hasFlowShorthandAnnotationComment() is\n        // implemented differently.\n\n        var commentSyntax = value && value.typeAnnotation && value.typeAnnotation.range && options.originalText.substring(value.typeAnnotation.range[0]).match(/^\\/\\*\\s*:/);\n        return concat([\"(\", path.call(print, \"expression\"), commentSyntax ? \" /*\" : \"\", \": \", path.call(print, \"typeAnnotation\"), commentSyntax ? \" */\" : \"\", \")\"]);\n      }\n\n    case \"TypeParameterDeclaration\":\n    case \"TypeParameterInstantiation\":\n      {\n        var _value = path.getValue();\n\n        var commentStart = _value.range ? options.originalText.substring(0, _value.range[0]).lastIndexOf(\"/*\") : -1; // As noted in the TypeCastExpression comments above, we're able to use a normal whitespace regex here\n        // because we know for sure that this is a type definition.\n\n        var _commentSyntax = commentStart >= 0 && options.originalText.substring(commentStart).match(/^\\/\\*\\s*::/);\n\n        if (_commentSyntax) {\n          return concat([\"/*:: \", printTypeParameters(path, options, print, \"params\"), \" */\"]);\n        }\n\n        return printTypeParameters(path, options, print, \"params\");\n      }\n\n    case \"TSTypeParameterDeclaration\":\n    case \"TSTypeParameterInstantiation\":\n      return printTypeParameters(path, options, print, \"params\");\n\n    case \"TSTypeParameter\":\n    case \"TypeParameter\":\n      {\n        var _parent9 = path.getParentNode();\n\n        if (_parent9.type === \"TSMappedType\") {\n          parts.push(\"[\", path.call(print, \"name\"));\n\n          if (n.constraint) {\n            parts.push(\" in \", path.call(print, \"constraint\"));\n          }\n\n          parts.push(\"]\");\n          return concat(parts);\n        }\n\n        var _variance3 = getFlowVariance(n);\n\n        if (_variance3) {\n          parts.push(_variance3);\n        }\n\n        parts.push(path.call(print, \"name\"));\n\n        if (n.bound) {\n          parts.push(\": \");\n          parts.push(path.call(print, \"bound\"));\n        }\n\n        if (n.constraint) {\n          parts.push(\" extends \", path.call(print, \"constraint\"));\n        }\n\n        if (n[\"default\"]) {\n          parts.push(\" = \", path.call(print, \"default\"));\n        } // Keep comma if the file extension is .tsx and\n        // has one type parameter that isn't extend with any types.\n        // Because, otherwise formatted result will be invalid as tsx.\n\n\n        var _grandParent2 = path.getNode(2);\n\n        if (_parent9.params && _parent9.params.length === 1 && options.filepath && /\\.tsx$/i.test(options.filepath) && !n.constraint && _grandParent2.type === \"ArrowFunctionExpression\") {\n          parts.push(\",\");\n        }\n\n        return concat(parts);\n      }\n\n    case \"TypeofTypeAnnotation\":\n      return concat([\"typeof \", path.call(print, \"argument\")]);\n\n    case \"VoidTypeAnnotation\":\n      return \"void\";\n\n    case \"InferredPredicate\":\n      return \"%checks\";\n    // Unhandled types below. If encountered, nodes of these types should\n    // be either left alone or desugared into AST types that are fully\n    // supported by the pretty-printer.\n\n    case \"DeclaredPredicate\":\n      return concat([\"%checks(\", path.call(print, \"value\"), \")\"]);\n\n    case \"TSAbstractKeyword\":\n      return \"abstract\";\n\n    case \"TSAnyKeyword\":\n      return \"any\";\n\n    case \"TSAsyncKeyword\":\n      return \"async\";\n\n    case \"TSBooleanKeyword\":\n      return \"boolean\";\n\n    case \"TSBigIntKeyword\":\n      return \"bigint\";\n\n    case \"TSConstKeyword\":\n      return \"const\";\n\n    case \"TSDeclareKeyword\":\n      return \"declare\";\n\n    case \"TSExportKeyword\":\n      return \"export\";\n\n    case \"TSNeverKeyword\":\n      return \"never\";\n\n    case \"TSNumberKeyword\":\n      return \"number\";\n\n    case \"TSObjectKeyword\":\n      return \"object\";\n\n    case \"TSProtectedKeyword\":\n      return \"protected\";\n\n    case \"TSPrivateKeyword\":\n      return \"private\";\n\n    case \"TSPublicKeyword\":\n      return \"public\";\n\n    case \"TSReadonlyKeyword\":\n      return \"readonly\";\n\n    case \"TSSymbolKeyword\":\n      return \"symbol\";\n\n    case \"TSStaticKeyword\":\n      return \"static\";\n\n    case \"TSStringKeyword\":\n      return \"string\";\n\n    case \"TSUndefinedKeyword\":\n      return \"undefined\";\n\n    case \"TSUnknownKeyword\":\n      return \"unknown\";\n\n    case \"TSVoidKeyword\":\n      return \"void\";\n\n    case \"TSAsExpression\":\n      return concat([path.call(print, \"expression\"), \" as \", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSArrayType\":\n      return concat([path.call(print, \"elementType\"), \"[]\"]);\n\n    case \"TSPropertySignature\":\n      {\n        if (n[\"export\"]) {\n          parts.push(\"export \");\n        }\n\n        if (n.accessibility) {\n          parts.push(n.accessibility + \" \");\n        }\n\n        if (n[\"static\"]) {\n          parts.push(\"static \");\n        }\n\n        if (n.readonly) {\n          parts.push(\"readonly \");\n        }\n\n        if (n.computed) {\n          parts.push(\"[\");\n        }\n\n        parts.push(printPropertyKey(path, options, print));\n\n        if (n.computed) {\n          parts.push(\"]\");\n        }\n\n        parts.push(printOptionalToken(path));\n\n        if (n.typeAnnotation) {\n          parts.push(\": \");\n          parts.push(path.call(print, \"typeAnnotation\"));\n        } // This isn't valid semantically, but it's in the AST so we can print it.\n\n\n        if (n.initializer) {\n          parts.push(\" = \", path.call(print, \"initializer\"));\n        }\n\n        return concat(parts);\n      }\n\n    case \"TSParameterProperty\":\n      if (n.accessibility) {\n        parts.push(n.accessibility + \" \");\n      }\n\n      if (n[\"export\"]) {\n        parts.push(\"export \");\n      }\n\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      if (n.readonly) {\n        parts.push(\"readonly \");\n      }\n\n      parts.push(path.call(print, \"parameter\"));\n      return concat(parts);\n\n    case \"TSTypeReference\":\n      return concat([path.call(print, \"typeName\"), printTypeParameters(path, options, print, \"typeParameters\")]);\n\n    case \"TSTypeQuery\":\n      return concat([\"typeof \", path.call(print, \"exprName\")]);\n\n    case \"TSParenthesizedType\":\n      {\n        return path.call(print, \"typeAnnotation\");\n      }\n\n    case \"TSIndexSignature\":\n      {\n        var _parent10 = path.getParentNode();\n\n        return concat([n[\"export\"] ? \"export \" : \"\", n.accessibility ? concat([n.accessibility, \" \"]) : \"\", n[\"static\"] ? \"static \" : \"\", n.readonly ? \"readonly \" : \"\", \"[\", n.parameters ? concat(path.map(print, \"parameters\")) : \"\", \"]: \", path.call(print, \"typeAnnotation\"), _parent10.type === \"ClassBody\" ? semi : \"\"]);\n      }\n\n    case \"TSTypePredicate\":\n      return concat([path.call(print, \"parameterName\"), \" is \", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSNonNullExpression\":\n      return concat([path.call(print, \"expression\"), \"!\"]);\n\n    case \"TSThisType\":\n      return \"this\";\n\n    case \"TSImportType\":\n      return concat([!n.isTypeOf ? \"\" : \"typeof \", \"import(\", path.call(print, \"parameter\"), \")\", !n.qualifier ? \"\" : concat([\".\", path.call(print, \"qualifier\")]), printTypeParameters(path, options, print, \"typeParameters\")]);\n\n    case \"TSLiteralType\":\n      return path.call(print, \"literal\");\n\n    case \"TSIndexedAccessType\":\n      return concat([path.call(print, \"objectType\"), \"[\", path.call(print, \"indexType\"), \"]\"]);\n\n    case \"TSConstructSignatureDeclaration\":\n    case \"TSCallSignatureDeclaration\":\n    case \"TSConstructorType\":\n      {\n        if (n.type !== \"TSCallSignatureDeclaration\") {\n          parts.push(\"new \");\n        }\n\n        parts.push(group(printFunctionParams(path, print, options,\n        /* expandArg */\n        false,\n        /* printTypeParams */\n        true)));\n\n        if (n.returnType) {\n          var isType = n.type === \"TSConstructorType\";\n          parts.push(isType ? \" => \" : \": \", path.call(print, \"returnType\"));\n        }\n\n        return concat(parts);\n      }\n\n    case \"TSTypeOperator\":\n      return concat([n.operator, \" \", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSMappedType\":\n      {\n        var _shouldBreak2 = hasNewlineInRange(options.originalText, options.locStart(n), options.locEnd(n));\n\n        return group(concat([\"{\", indent(concat([options.bracketSpacing ? line : softline, n.readonly ? concat([getTypeScriptMappedTypeModifier(n.readonly, \"readonly\"), \" \"]) : \"\", printTypeScriptModifiers(path, options, print), path.call(print, \"typeParameter\"), n.optional ? getTypeScriptMappedTypeModifier(n.optional, \"?\") : \"\", \": \", path.call(print, \"typeAnnotation\"), ifBreak(semi, \"\")])), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), options.bracketSpacing ? line : softline, \"}\"]), {\n          shouldBreak: _shouldBreak2\n        });\n      }\n\n    case \"TSMethodSignature\":\n      parts.push(n.accessibility ? concat([n.accessibility, \" \"]) : \"\", n[\"export\"] ? \"export \" : \"\", n[\"static\"] ? \"static \" : \"\", n.readonly ? \"readonly \" : \"\", n.computed ? \"[\" : \"\", path.call(print, \"key\"), n.computed ? \"]\" : \"\", printOptionalToken(path), printFunctionParams(path, print, options,\n      /* expandArg */\n      false,\n      /* printTypeParams */\n      true));\n\n      if (n.returnType) {\n        parts.push(\": \", path.call(print, \"returnType\"));\n      }\n\n      return group(concat(parts));\n\n    case \"TSNamespaceExportDeclaration\":\n      parts.push(\"export as namespace \", path.call(print, \"id\"));\n\n      if (options.semi) {\n        parts.push(\";\");\n      }\n\n      return group(concat(parts));\n\n    case \"TSEnumDeclaration\":\n      if (isNodeStartingWithDeclare(n, options)) {\n        parts.push(\"declare \");\n      }\n\n      if (n.modifiers) {\n        parts.push(printTypeScriptModifiers(path, options, print));\n      }\n\n      if (n[\"const\"]) {\n        parts.push(\"const \");\n      }\n\n      parts.push(\"enum \", path.call(print, \"id\"), \" \");\n\n      if (n.members.length === 0) {\n        parts.push(group(concat([\"{\", comments.printDanglingComments(path, options), softline, \"}\"])));\n      } else {\n        parts.push(group(concat([\"{\", indent(concat([hardline, printArrayItems(path, options, \"members\", print), shouldPrintComma(options, \"es5\") ? \",\" : \"\"])), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), hardline, \"}\"])));\n      }\n\n      return concat(parts);\n\n    case \"TSEnumMember\":\n      parts.push(path.call(print, \"id\"));\n\n      if (n.initializer) {\n        parts.push(\" = \", path.call(print, \"initializer\"));\n      }\n\n      return concat(parts);\n\n    case \"TSImportEqualsDeclaration\":\n      if (n.isExport) {\n        parts.push(\"export \");\n      }\n\n      parts.push(\"import \", path.call(print, \"id\"), \" = \", path.call(print, \"moduleReference\"));\n\n      if (options.semi) {\n        parts.push(\";\");\n      }\n\n      return group(concat(parts));\n\n    case \"TSExternalModuleReference\":\n      return concat([\"require(\", path.call(print, \"expression\"), \")\"]);\n\n    case \"TSModuleDeclaration\":\n      {\n        var _parent11 = path.getParentNode();\n\n        var isExternalModule = isLiteral(n.id);\n        var parentIsDeclaration = _parent11.type === \"TSModuleDeclaration\";\n        var bodyIsDeclaration = n.body && n.body.type === \"TSModuleDeclaration\";\n\n        if (parentIsDeclaration) {\n          parts.push(\".\");\n        } else {\n          if (n.declare === true) {\n            parts.push(\"declare \");\n          }\n\n          parts.push(printTypeScriptModifiers(path, options, print));\n          var textBetweenNodeAndItsId = options.originalText.slice(options.locStart(n), options.locStart(n.id)); // Global declaration looks like this:\n          // (declare)? global { ... }\n\n          var isGlobalDeclaration = n.id.type === \"Identifier\" && n.id.name === \"global\" && !/namespace|module/.test(textBetweenNodeAndItsId);\n\n          if (!isGlobalDeclaration) {\n            parts.push(isExternalModule || /(^|\\s)module(\\s|$)/.test(textBetweenNodeAndItsId) ? \"module \" : \"namespace \");\n          }\n        }\n\n        parts.push(path.call(print, \"id\"));\n\n        if (bodyIsDeclaration) {\n          parts.push(path.call(print, \"body\"));\n        } else if (n.body) {\n          parts.push(\" \", group(path.call(print, \"body\")));\n        } else {\n          parts.push(semi);\n        }\n\n        return concat(parts);\n      }\n\n    case \"PrivateName\":\n      return concat([\"#\", path.call(print, \"id\")]);\n\n    case \"TSConditionalType\":\n      return printTernaryOperator(path, options, print, {\n        beforeParts: function beforeParts() {\n          return [path.call(print, \"checkType\"), \" \", \"extends\", \" \", path.call(print, \"extendsType\")];\n        },\n        afterParts: function afterParts() {\n          return [];\n        },\n        shouldCheckJsx: false,\n        conditionalNodeType: \"TSConditionalType\",\n        consequentNodePropertyName: \"trueType\",\n        alternateNodePropertyName: \"falseType\",\n        testNodePropertyName: \"checkType\",\n        breakNested: true\n      });\n\n    case \"TSInferType\":\n      return concat([\"infer\", \" \", path.call(print, \"typeParameter\")]);\n\n    case \"InterpreterDirective\":\n      parts.push(\"#!\", n.value, hardline);\n\n      if (isNextLineEmpty(options.originalText, n, options)) {\n        parts.push(hardline);\n      }\n\n      return concat(parts);\n\n    case \"NGRoot\":\n      return concat([].concat(path.call(print, \"node\"), !n.node.comments || n.node.comments.length === 0 ? [] : concat([\" //\", n.node.comments[0].value.trimRight()])));\n\n    case \"NGChainedExpression\":\n      return group(join(concat([\";\", line]), path.map(function (childPath) {\n        return hasNgSideEffect(childPath) ? print(childPath) : concat([\"(\", print(childPath), \")\"]);\n      }, \"expressions\")));\n\n    case \"NGEmptyExpression\":\n      return \"\";\n\n    case \"NGQuotedExpression\":\n      return concat([n.prefix, \":\", n.value]);\n\n    case \"NGMicrosyntax\":\n      return concat(path.map(function (childPath, index) {\n        return concat([index === 0 ? \"\" : isNgForOf(childPath.getValue(), index, n) ? \" \" : concat([\";\", line]), print(childPath)]);\n      }, \"body\"));\n\n    case \"NGMicrosyntaxKey\":\n      return /^[a-z_$][a-z0-9_$]*(-[a-z_$][a-z0-9_$])*$/i.test(n.name) ? n.name : JSON.stringify(n.name);\n\n    case \"NGMicrosyntaxExpression\":\n      return concat([path.call(print, \"expression\"), n.alias === null ? \"\" : concat([\" as \", path.call(print, \"alias\")])]);\n\n    case \"NGMicrosyntaxKeyedExpression\":\n      {\n        var index = path.getName();\n\n        var _parentNode2 = path.getParentNode();\n\n        var shouldNotPrintColon = isNgForOf(n, index, _parentNode2) || (index === 1 && (n.key.name === \"then\" || n.key.name === \"else\") || index === 2 && n.key.name === \"else\" && _parentNode2.body[index - 1].type === \"NGMicrosyntaxKeyedExpression\" && _parentNode2.body[index - 1].key.name === \"then\") && _parentNode2.body[0].type === \"NGMicrosyntaxExpression\";\n        return concat([path.call(print, \"key\"), shouldNotPrintColon ? \" \" : \": \", path.call(print, \"expression\")]);\n      }\n\n    case \"NGMicrosyntaxLet\":\n      return concat([\"let \", path.call(print, \"key\"), n.value === null ? \"\" : concat([\" = \", path.call(print, \"value\")])]);\n\n    case \"NGMicrosyntaxAs\":\n      return concat([path.call(print, \"key\"), \" as \", path.call(print, \"alias\")]);\n\n    default:\n      /* istanbul ignore next */\n      throw new Error(\"unknown type: \" + JSON.stringify(n.type));\n  }\n}\n\nfunction isNgForOf(node, index, parentNode) {\n  return node.type === \"NGMicrosyntaxKeyedExpression\" && node.key.name === \"of\" && index === 1 && parentNode.body[0].type === \"NGMicrosyntaxLet\" && parentNode.body[0].value === null;\n}\n/** identify if an angular expression seems to have side effects */\n\n\nfunction hasNgSideEffect(path) {\n  return hasNode(path.getValue(), function (node) {\n    switch (node.type) {\n      case undefined:\n        return false;\n\n      case \"CallExpression\":\n      case \"OptionalCallExpression\":\n      case \"AssignmentExpression\":\n        return true;\n    }\n  });\n}\n\nfunction printStatementSequence(path, options, print) {\n  var printed = [];\n  var bodyNode = path.getNode();\n  var isClass = bodyNode.type === \"ClassBody\";\n  path.map(function (stmtPath, i) {\n    var stmt = stmtPath.getValue(); // Just in case the AST has been modified to contain falsy\n    // \"statements,\" it's safer simply to skip them.\n\n    /* istanbul ignore if */\n\n    if (!stmt) {\n      return;\n    } // Skip printing EmptyStatement nodes to avoid leaving stray\n    // semicolons lying around.\n\n\n    if (stmt.type === \"EmptyStatement\") {\n      return;\n    }\n\n    var stmtPrinted = print(stmtPath);\n    var text = options.originalText;\n    var parts = []; // in no-semi mode, prepend statement with semicolon if it might break ASI\n    // don't prepend the only JSX element in a program with semicolon\n\n    if (!options.semi && !isClass && !isTheOnlyJSXElementInMarkdown(options, stmtPath) && stmtNeedsASIProtection(stmtPath, options)) {\n      if (stmt.comments && stmt.comments.some(function (comment) {\n        return comment.leading;\n      })) {\n        parts.push(print(stmtPath, {\n          needsSemi: true\n        }));\n      } else {\n        parts.push(\";\", stmtPrinted);\n      }\n    } else {\n      parts.push(stmtPrinted);\n    }\n\n    if (!options.semi && isClass) {\n      if (classPropMayCauseASIProblems(stmtPath)) {\n        parts.push(\";\");\n      } else if (stmt.type === \"ClassProperty\") {\n        var nextChild = bodyNode.body[i + 1];\n\n        if (classChildNeedsASIProtection(nextChild)) {\n          parts.push(\";\");\n        }\n      }\n    }\n\n    if (isNextLineEmpty(text, stmt, options) && !isLastStatement(stmtPath)) {\n      parts.push(hardline);\n    }\n\n    printed.push(concat(parts));\n  });\n  return join(hardline, printed);\n}\n\nfunction printPropertyKey(path, options, print) {\n  var node = path.getNode();\n  var parent = path.getParentNode();\n  var key = node.key;\n\n  if (options.quoteProps === \"consistent\" && !needsQuoteProps.has(parent)) {\n    var objectHasStringProp = (parent.properties || parent.body || parent.members).some(function (prop) {\n      return !prop.computed && prop.key && isStringLiteral(prop.key) && !isStringPropSafeToCoerceToIdentifier(prop, options);\n    });\n    needsQuoteProps.set(parent, objectHasStringProp);\n  }\n\n  if (key.type === \"Identifier\" && !node.computed && (options.parser === \"json\" || options.quoteProps === \"consistent\" && needsQuoteProps.get(parent))) {\n    // a -> \"a\"\n    var prop = printString(JSON.stringify(key.name), options);\n    return path.call(function (keyPath) {\n      return comments.printComments(keyPath, function () {\n        return prop;\n      }, options);\n    }, \"key\");\n  }\n\n  if (!node.computed && isStringPropSafeToCoerceToIdentifier(node, options) && (options.quoteProps === \"as-needed\" || options.quoteProps === \"consistent\" && !needsQuoteProps.get(parent))) {\n    // 'a' -> a\n    return path.call(function (keyPath) {\n      return comments.printComments(keyPath, function () {\n        return key.value;\n      }, options);\n    }, \"key\");\n  }\n\n  return path.call(print, \"key\");\n}\n\nfunction printMethod(path, options, print) {\n  var node = path.getNode();\n  var semi = options.semi ? \";\" : \"\";\n  var kind = node.kind;\n  var parts = [];\n\n  if (node.type === \"ObjectMethod\" || node.type === \"ClassMethod\" || node.type === \"ClassPrivateMethod\") {\n    node.value = node;\n  }\n\n  if (node.value.async) {\n    parts.push(\"async \");\n  }\n\n  if (!kind || kind === \"init\" || kind === \"method\" || kind === \"constructor\") {\n    if (node.value.generator) {\n      parts.push(\"*\");\n    }\n  } else {\n    assert.ok(kind === \"get\" || kind === \"set\");\n    parts.push(kind, \" \");\n  }\n\n  var key = printPropertyKey(path, options, print);\n\n  if (node.computed) {\n    key = concat([\"[\", key, \"]\"]);\n  }\n\n  parts.push(key, concat(path.call(function (valuePath) {\n    return [printFunctionTypeParameters(valuePath, options, print), group(concat([printFunctionParams(valuePath, print, options), printReturnType(valuePath, print, options)]))];\n  }, \"value\")));\n\n  if (!node.value.body || node.value.body.length === 0) {\n    parts.push(semi);\n  } else {\n    parts.push(\" \", path.call(print, \"value\", \"body\"));\n  }\n\n  return concat(parts);\n}\n\nfunction couldGroupArg(arg) {\n  return arg.type === \"ObjectExpression\" && (arg.properties.length > 0 || arg.comments) || arg.type === \"ArrayExpression\" && (arg.elements.length > 0 || arg.comments) || arg.type === \"TSTypeAssertion\" || arg.type === \"TSAsExpression\" || arg.type === \"FunctionExpression\" || arg.type === \"ArrowFunctionExpression\" && ( // we want to avoid breaking inside composite return types but not simple keywords\n  // https://github.com/prettier/prettier/issues/4070\n  // export class Thing implements OtherThing {\n  //   do: (type: Type) => Provider<Prop> = memoize(\n  //     (type: ObjectType): Provider<Opts> => {}\n  //   );\n  // }\n  // https://github.com/prettier/prettier/issues/6099\n  // app.get(\"/\", (req, res): void => {\n  //   res.send(\"Hello World!\");\n  // });\n  !arg.returnType || !arg.returnType.typeAnnotation || arg.returnType.typeAnnotation.type !== \"TSTypeReference\") && (arg.body.type === \"BlockStatement\" || arg.body.type === \"ArrowFunctionExpression\" || arg.body.type === \"ObjectExpression\" || arg.body.type === \"ArrayExpression\" || arg.body.type === \"CallExpression\" || arg.body.type === \"OptionalCallExpression\" || arg.body.type === \"ConditionalExpression\" || isJSXNode(arg.body));\n}\n\nfunction shouldGroupLastArg(args) {\n  var lastArg = getLast(args);\n  var penultimateArg = getPenultimate(args);\n  return !hasLeadingComment(lastArg) && !hasTrailingComment(lastArg) && couldGroupArg(lastArg) && ( // If the last two arguments are of the same type,\n  // disable last element expansion.\n  !penultimateArg || penultimateArg.type !== lastArg.type);\n}\n\nfunction shouldGroupFirstArg(args) {\n  if (args.length !== 2) {\n    return false;\n  }\n\n  var firstArg = args[0];\n  var secondArg = args[1];\n  return (!firstArg.comments || !firstArg.comments.length) && (firstArg.type === \"FunctionExpression\" || firstArg.type === \"ArrowFunctionExpression\" && firstArg.body.type === \"BlockStatement\") && secondArg.type !== \"FunctionExpression\" && secondArg.type !== \"ArrowFunctionExpression\" && secondArg.type !== \"ConditionalExpression\" && !couldGroupArg(secondArg);\n}\n\nfunction isSimpleFlowType(node) {\n  var flowTypeAnnotations = [\"AnyTypeAnnotation\", \"NullLiteralTypeAnnotation\", \"GenericTypeAnnotation\", \"ThisTypeAnnotation\", \"NumberTypeAnnotation\", \"VoidTypeAnnotation\", \"EmptyTypeAnnotation\", \"MixedTypeAnnotation\", \"BooleanTypeAnnotation\", \"BooleanLiteralTypeAnnotation\", \"StringTypeAnnotation\"];\n  return node && flowTypeAnnotations.indexOf(node.type) !== -1 && !(node.type === \"GenericTypeAnnotation\" && node.typeParameters);\n}\n\nfunction isJestEachTemplateLiteral(node, parentNode) {\n  /**\n   * describe.each`table`(name, fn)\n   * describe.only.each`table`(name, fn)\n   * describe.skip.each`table`(name, fn)\n   * test.each`table`(name, fn)\n   * test.only.each`table`(name, fn)\n   * test.skip.each`table`(name, fn)\n   *\n   * Ref: https://github.com/facebook/jest/pull/6102\n   */\n  var jestEachTriggerRegex = /^[xf]?(describe|it|test)$/;\n  return parentNode.type === \"TaggedTemplateExpression\" && parentNode.quasi === node && parentNode.tag.type === \"MemberExpression\" && parentNode.tag.property.type === \"Identifier\" && parentNode.tag.property.name === \"each\" && (parentNode.tag.object.type === \"Identifier\" && jestEachTriggerRegex.test(parentNode.tag.object.name) || parentNode.tag.object.type === \"MemberExpression\" && parentNode.tag.object.property.type === \"Identifier\" && (parentNode.tag.object.property.name === \"only\" || parentNode.tag.object.property.name === \"skip\") && parentNode.tag.object.object.type === \"Identifier\" && jestEachTriggerRegex.test(parentNode.tag.object.object.name));\n}\n\nfunction printJestEachTemplateLiteral(node, expressions, options) {\n  /**\n   * a    | b    | expected\n   * ${1} | ${1} | ${2}\n   * ${1} | ${2} | ${3}\n   * ${2} | ${1} | ${3}\n   */\n  var headerNames = node.quasis[0].value.raw.trim().split(/\\s*\\|\\s*/);\n\n  if (headerNames.length > 1 || headerNames.some(function (headerName) {\n    return headerName.length !== 0;\n  })) {\n    var parts = [];\n    var stringifiedExpressions = expressions.map(function (doc) {\n      return \"${\" + printDocToString(doc, Object.assign({}, options, {\n        printWidth: Infinity,\n        endOfLine: \"lf\"\n      })).formatted + \"}\";\n    });\n    var tableBody = [{\n      hasLineBreak: false,\n      cells: []\n    }];\n\n    for (var i = 1; i < node.quasis.length; i++) {\n      var row = tableBody[tableBody.length - 1];\n      var correspondingExpression = stringifiedExpressions[i - 1];\n      row.cells.push(correspondingExpression);\n\n      if (correspondingExpression.indexOf(\"\\n\") !== -1) {\n        row.hasLineBreak = true;\n      }\n\n      if (node.quasis[i].value.raw.indexOf(\"\\n\") !== -1) {\n        tableBody.push({\n          hasLineBreak: false,\n          cells: []\n        });\n      }\n    }\n\n    var maxColumnCount = tableBody.reduce(function (maxColumnCount, row) {\n      return Math.max(maxColumnCount, row.cells.length);\n    }, headerNames.length);\n    var maxColumnWidths = Array.from(new Array(maxColumnCount), function () {\n      return 0;\n    });\n    var table = [{\n      cells: headerNames\n    }].concat(tableBody.filter(function (row) {\n      return row.cells.length !== 0;\n    }));\n    table.filter(function (row) {\n      return !row.hasLineBreak;\n    }).forEach(function (row) {\n      row.cells.forEach(function (cell, index) {\n        maxColumnWidths[index] = Math.max(maxColumnWidths[index], getStringWidth(cell));\n      });\n    });\n    parts.push(lineSuffixBoundary, \"`\", indent(concat([hardline, join(hardline, table.map(function (row) {\n      return join(\" | \", row.cells.map(function (cell, index) {\n        return row.hasLineBreak ? cell : cell + \" \".repeat(maxColumnWidths[index] - getStringWidth(cell));\n      }));\n    }))])), hardline, \"`\");\n    return concat(parts);\n  }\n}\n/** @param node {import(\"estree\").TemplateLiteral} */\n\n\nfunction isSimpleTemplateLiteral(node) {\n  if (node.expressions.length === 0) {\n    return false;\n  }\n\n  return node.expressions.every(function (expr) {\n    // Disallow comments since printDocToString can't print them here\n    if (expr.comments) {\n      return false;\n    } // Allow `x` and `this`\n\n\n    if (expr.type === \"Identifier\" || expr.type === \"ThisExpression\") {\n      return true;\n    } // Allow `a.b.c`, `a.b[c]`, and `this.x.y`\n\n\n    if ((expr.type === \"MemberExpression\" || expr.type === \"OptionalMemberExpression\") && (expr.property.type === \"Identifier\" || expr.property.type === \"Literal\")) {\n      var ancestor = expr;\n\n      while (ancestor.type === \"MemberExpression\" || ancestor.type === \"OptionalMemberExpression\") {\n        ancestor = ancestor.object;\n\n        if (ancestor.comments) {\n          return false;\n        }\n      }\n\n      if (ancestor.type === \"Identifier\" || ancestor.type === \"ThisExpression\") {\n        return true;\n      }\n\n      return false;\n    }\n\n    return false;\n  });\n}\n\nvar functionCompositionFunctionNames = new Set([\"pipe\", // RxJS, Ramda\n\"pipeP\", // Ramda\n\"pipeK\", // Ramda\n\"compose\", // Ramda, Redux\n\"composeFlipped\", // Not from any library, but common in Haskell, so supported\n\"composeP\", // Ramda\n\"composeK\", // Ramda\n\"flow\", // Lodash\n\"flowRight\", // Lodash\n\"connect\", // Redux\n\"createSelector\" // Reselect\n]);\nvar ordinaryMethodNames = new Set([\"connect\" // GObject, MongoDB\n]);\n\nfunction isFunctionCompositionFunction(node) {\n  switch (node.type) {\n    case \"OptionalMemberExpression\":\n    case \"MemberExpression\":\n      {\n        return isFunctionCompositionFunction(node.property) && !ordinaryMethodNames.has(node.property.name);\n      }\n\n    case \"Identifier\":\n      {\n        return functionCompositionFunctionNames.has(node.name);\n      }\n\n    case \"StringLiteral\":\n    case \"Literal\":\n      {\n        return functionCompositionFunctionNames.has(node.value);\n      }\n  }\n}\n\nfunction printArgumentsList(path, options, print) {\n  var node = path.getValue();\n  var args = node.arguments;\n\n  if (args.length === 0) {\n    return concat([\"(\", comments.printDanglingComments(path, options,\n    /* sameIndent */\n    true), \")\"]);\n  } // useEffect(() => { ... }, [foo, bar, baz])\n\n\n  if (args.length === 2 && args[0].type === \"ArrowFunctionExpression\" && args[0].params.length === 0 && args[0].body.type === \"BlockStatement\" && args[1].type === \"ArrayExpression\" && !args.find(function (arg) {\n    return arg.comments;\n  })) {\n    return concat([\"(\", path.call(print, \"arguments\", 0), \", \", path.call(print, \"arguments\", 1), \")\"]);\n  } // func(\n  //   ({\n  //     a,\n  //     b\n  //   }) => {}\n  // );\n\n\n  function hasEmptyLineInObjectArgInArrowFunction(arg) {\n    return arg && arg.type === \"ArrowFunctionExpression\" && arg.params && arg.params.some(function (param) {\n      return param.type && param.type === \"ObjectPattern\" && param.properties && param.properties.some(function (property, i, properties) {\n        return i < properties.length - 1 && isNextLineEmpty(options.originalText, property, options);\n      });\n    });\n  }\n\n  var anyArgEmptyLine = false;\n  var hasEmptyLineFollowingFirstArg = false;\n  var lastArgIndex = args.length - 1;\n  var printedArguments = path.map(function (argPath, index) {\n    var arg = argPath.getNode();\n    var parts = [print(argPath)];\n\n    if (index === lastArgIndex) {// do nothing\n    } else if (isNextLineEmpty(options.originalText, arg, options)) {\n      if (index === 0) {\n        hasEmptyLineFollowingFirstArg = true;\n      }\n\n      anyArgEmptyLine = true;\n      parts.push(\",\", hardline, hardline);\n    } else {\n      parts.push(\",\", line);\n    }\n\n    anyArgEmptyLine = hasEmptyLineInObjectArgInArrowFunction(arg);\n    return concat(parts);\n  }, \"arguments\");\n  var maybeTrailingComma = // Dynamic imports cannot have trailing commas\n  !(node.callee && node.callee.type === \"Import\") && shouldPrintComma(options, \"all\") ? \",\" : \"\";\n\n  function allArgsBrokenOut() {\n    return group(concat([\"(\", indent(concat([line, concat(printedArguments)])), maybeTrailingComma, line, \")\"]), {\n      shouldBreak: true\n    });\n  } // We want to get\n  //    pipe(\n  //      x => x + 1,\n  //      x => x - 1\n  //    )\n  // here, but not\n  //    process.stdout.pipe(socket)\n\n\n  if (isFunctionCompositionFunction(node.callee) && args.length > 1) {\n    return allArgsBrokenOut();\n  }\n\n  var shouldGroupFirst = shouldGroupFirstArg(args);\n  var shouldGroupLast = shouldGroupLastArg(args);\n\n  if (shouldGroupFirst || shouldGroupLast) {\n    var shouldBreak = (shouldGroupFirst ? printedArguments.slice(1).some(willBreak) : printedArguments.slice(0, -1).some(willBreak)) || anyArgEmptyLine; // We want to print the last argument with a special flag\n\n    var printedExpanded;\n    var i = 0;\n    path.each(function (argPath) {\n      if (shouldGroupFirst && i === 0) {\n        printedExpanded = [concat([argPath.call(function (p) {\n          return print(p, {\n            expandFirstArg: true\n          });\n        }), printedArguments.length > 1 ? \",\" : \"\", hasEmptyLineFollowingFirstArg ? hardline : line, hasEmptyLineFollowingFirstArg ? hardline : \"\"])].concat(printedArguments.slice(1));\n      }\n\n      if (shouldGroupLast && i === args.length - 1) {\n        printedExpanded = printedArguments.slice(0, -1).concat(argPath.call(function (p) {\n          return print(p, {\n            expandLastArg: true\n          });\n        }));\n      }\n\n      i++;\n    }, \"arguments\");\n    var somePrintedArgumentsWillBreak = printedArguments.some(willBreak);\n    var simpleConcat = concat([\"(\", concat(printedExpanded), \")\"]);\n    return concat([somePrintedArgumentsWillBreak ? breakParent : \"\", conditionalGroup([!somePrintedArgumentsWillBreak ? simpleConcat : ifBreak(allArgsBrokenOut(), simpleConcat), shouldGroupFirst ? concat([\"(\", group(printedExpanded[0], {\n      shouldBreak: true\n    }), concat(printedExpanded.slice(1)), \")\"]) : concat([\"(\", concat(printedArguments.slice(0, -1)), group(getLast(printedExpanded), {\n      shouldBreak: true\n    }), \")\"]), allArgsBrokenOut()], {\n      shouldBreak: shouldBreak\n    })]);\n  }\n\n  return group(concat([\"(\", indent(concat([softline, concat(printedArguments)])), ifBreak(maybeTrailingComma), softline, \")\"]), {\n    shouldBreak: printedArguments.some(willBreak) || anyArgEmptyLine\n  });\n}\n\nfunction printTypeAnnotation(path, options, print) {\n  var node = path.getValue();\n\n  if (!node.typeAnnotation) {\n    return \"\";\n  }\n\n  var parentNode = path.getParentNode();\n  var isDefinite = node.definite || parentNode && parentNode.type === \"VariableDeclarator\" && parentNode.definite;\n  var isFunctionDeclarationIdentifier = parentNode.type === \"DeclareFunction\" && parentNode.id === node;\n\n  if (isFlowAnnotationComment(options.originalText, node.typeAnnotation, options)) {\n    return concat([\" /*: \", path.call(print, \"typeAnnotation\"), \" */\"]);\n  }\n\n  return concat([isFunctionDeclarationIdentifier ? \"\" : isDefinite ? \"!: \" : \": \", path.call(print, \"typeAnnotation\")]);\n}\n\nfunction printFunctionTypeParameters(path, options, print) {\n  var fun = path.getValue();\n\n  if (fun.typeArguments) {\n    return path.call(print, \"typeArguments\");\n  }\n\n  if (fun.typeParameters) {\n    return path.call(print, \"typeParameters\");\n  }\n\n  return \"\";\n}\n\nfunction printFunctionParams(path, print, options, expandArg, printTypeParams) {\n  var fun = path.getValue();\n  var parent = path.getParentNode();\n  var paramsField = fun.parameters ? \"parameters\" : \"params\";\n  var isParametersInTestCall = isTestCall(parent);\n  var shouldHugParameters = shouldHugArguments(fun);\n  var shouldExpandParameters = expandArg && !(fun[paramsField] && fun[paramsField].some(function (n) {\n    return n.comments;\n  }));\n  var typeParams = printTypeParams ? printFunctionTypeParameters(path, options, print) : \"\";\n  var printed = [];\n\n  if (fun[paramsField]) {\n    var lastArgIndex = fun[paramsField].length - 1;\n    printed = path.map(function (childPath, index) {\n      var parts = [];\n      var param = childPath.getValue();\n      parts.push(print(childPath));\n\n      if (index === lastArgIndex) {\n        if (fun.rest) {\n          parts.push(\",\", line);\n        }\n      } else if (isParametersInTestCall || shouldHugParameters || shouldExpandParameters) {\n        parts.push(\", \");\n      } else if (isNextLineEmpty(options.originalText, param, options)) {\n        parts.push(\",\", hardline, hardline);\n      } else {\n        parts.push(\",\", line);\n      }\n\n      return concat(parts);\n    }, paramsField);\n  }\n\n  if (fun.rest) {\n    printed.push(concat([\"...\", path.call(print, \"rest\")]));\n  }\n\n  if (printed.length === 0) {\n    return concat([typeParams, \"(\", comments.printDanglingComments(path, options,\n    /* sameIndent */\n    true, function (comment) {\n      return getNextNonSpaceNonCommentCharacter(options.originalText, comment, options.locEnd) === \")\";\n    }), \")\"]);\n  }\n\n  var lastParam = getLast(fun[paramsField]); // If the parent is a call with the first/last argument expansion and this is the\n  // params of the first/last argument, we dont want the arguments to break and instead\n  // want the whole expression to be on a new line.\n  //\n  // Good:                 Bad:\n  //   verylongcall(         verylongcall((\n  //     (a, b) => {           a,\n  //     }                     b,\n  //   })                    ) => {\n  //                         })\n\n  if (shouldExpandParameters) {\n    return group(concat([removeLines(typeParams), \"(\", concat(printed.map(removeLines)), \")\"]));\n  } // Single object destructuring should hug\n  //\n  // function({\n  //   a,\n  //   b,\n  //   c\n  // }) {}\n\n\n  var hasNotParameterDecorator = fun[paramsField].every(function (param) {\n    return !param.decorators;\n  });\n\n  if (shouldHugParameters && hasNotParameterDecorator) {\n    return concat([typeParams, \"(\", concat(printed), \")\"]);\n  } // don't break in specs, eg; `it(\"should maintain parens around done even when long\", (done) => {})`\n\n\n  if (isParametersInTestCall) {\n    return concat([typeParams, \"(\", concat(printed), \")\"]);\n  }\n\n  var isFlowShorthandWithOneArg = (isObjectTypePropertyAFunction(parent, options) || isTypeAnnotationAFunction(parent, options) || parent.type === \"TypeAlias\" || parent.type === \"UnionTypeAnnotation\" || parent.type === \"TSUnionType\" || parent.type === \"IntersectionTypeAnnotation\" || parent.type === \"FunctionTypeAnnotation\" && parent.returnType === fun) && fun[paramsField].length === 1 && fun[paramsField][0].name === null && fun[paramsField][0].typeAnnotation && fun.typeParameters === null && isSimpleFlowType(fun[paramsField][0].typeAnnotation) && !fun.rest;\n\n  if (isFlowShorthandWithOneArg) {\n    if (options.arrowParens === \"always\") {\n      return concat([\"(\", concat(printed), \")\"]);\n    }\n\n    return concat(printed);\n  }\n\n  var canHaveTrailingComma = !(lastParam && lastParam.type === \"RestElement\") && !fun.rest;\n  return concat([typeParams, \"(\", indent(concat([softline, concat(printed)])), ifBreak(canHaveTrailingComma && shouldPrintComma(options, \"all\") ? \",\" : \"\"), softline, \")\"]);\n}\n\nfunction shouldPrintParamsWithoutParens(path, options) {\n  if (options.arrowParens === \"always\") {\n    return false;\n  }\n\n  if (options.arrowParens === \"avoid\") {\n    var node = path.getValue();\n    return canPrintParamsWithoutParens(node);\n  } // Fallback default; should be unreachable\n\n\n  return false;\n}\n\nfunction canPrintParamsWithoutParens(node) {\n  return node.params.length === 1 && !node.rest && !node.typeParameters && !hasDanglingComments(node) && node.params[0].type === \"Identifier\" && !node.params[0].typeAnnotation && !node.params[0].comments && !node.params[0].optional && !node.predicate && !node.returnType;\n}\n\nfunction printFunctionDeclaration(path, print, options) {\n  var n = path.getValue();\n  var parts = [];\n\n  if (n.async) {\n    parts.push(\"async \");\n  }\n\n  parts.push(\"function\");\n\n  if (n.generator) {\n    parts.push(\"*\");\n  }\n\n  if (n.id) {\n    parts.push(\" \", path.call(print, \"id\"));\n  }\n\n  parts.push(printFunctionTypeParameters(path, options, print), group(concat([printFunctionParams(path, print, options), printReturnType(path, print, options)])), n.body ? \" \" : \"\", path.call(print, \"body\"));\n  return concat(parts);\n}\n\nfunction printObjectMethod(path, options, print) {\n  var objMethod = path.getValue();\n  var parts = [];\n\n  if (objMethod.async) {\n    parts.push(\"async \");\n  }\n\n  if (objMethod.generator) {\n    parts.push(\"*\");\n  }\n\n  if (objMethod.method || objMethod.kind === \"get\" || objMethod.kind === \"set\") {\n    return printMethod(path, options, print);\n  }\n\n  var key = printPropertyKey(path, options, print);\n\n  if (objMethod.computed) {\n    parts.push(\"[\", key, \"]\");\n  } else {\n    parts.push(key);\n  }\n\n  parts.push(printFunctionTypeParameters(path, options, print), group(concat([printFunctionParams(path, print, options), printReturnType(path, print, options)])), \" \", path.call(print, \"body\"));\n  return concat(parts);\n}\n\nfunction printReturnType(path, print, options) {\n  var n = path.getValue();\n  var returnType = path.call(print, \"returnType\");\n\n  if (n.returnType && isFlowAnnotationComment(options.originalText, n.returnType, options)) {\n    return concat([\" /*: \", returnType, \" */\"]);\n  }\n\n  var parts = [returnType]; // prepend colon to TypeScript type annotation\n\n  if (n.returnType && n.returnType.typeAnnotation) {\n    parts.unshift(\": \");\n  }\n\n  if (n.predicate) {\n    // The return type will already add the colon, but otherwise we\n    // need to do it ourselves\n    parts.push(n.returnType ? \" \" : \": \", path.call(print, \"predicate\"));\n  }\n\n  return concat(parts);\n}\n\nfunction printExportDeclaration(path, options, print) {\n  var decl = path.getValue();\n  var semi = options.semi ? \";\" : \"\";\n  var parts = [\"export \"];\n  var isDefault = decl[\"default\"] || decl.type === \"ExportDefaultDeclaration\";\n\n  if (isDefault) {\n    parts.push(\"default \");\n  }\n\n  parts.push(comments.printDanglingComments(path, options,\n  /* sameIndent */\n  true));\n\n  if (needsHardlineAfterDanglingComment(decl)) {\n    parts.push(hardline);\n  }\n\n  if (decl.declaration) {\n    parts.push(path.call(print, \"declaration\"));\n\n    if (isDefault && decl.declaration.type !== \"ClassDeclaration\" && decl.declaration.type !== \"FunctionDeclaration\" && decl.declaration.type !== \"TSInterfaceDeclaration\" && decl.declaration.type !== \"DeclareClass\" && decl.declaration.type !== \"DeclareFunction\" && decl.declaration.type !== \"TSDeclareFunction\") {\n      parts.push(semi);\n    }\n  } else {\n    if (decl.specifiers && decl.specifiers.length > 0) {\n      var specifiers = [];\n      var defaultSpecifiers = [];\n      var namespaceSpecifiers = [];\n      path.each(function (specifierPath) {\n        var specifierType = path.getValue().type;\n\n        if (specifierType === \"ExportSpecifier\") {\n          specifiers.push(print(specifierPath));\n        } else if (specifierType === \"ExportDefaultSpecifier\") {\n          defaultSpecifiers.push(print(specifierPath));\n        } else if (specifierType === \"ExportNamespaceSpecifier\") {\n          namespaceSpecifiers.push(concat([\"* as \", print(specifierPath)]));\n        }\n      }, \"specifiers\");\n      var isNamespaceFollowed = namespaceSpecifiers.length !== 0 && specifiers.length !== 0;\n      var isDefaultFollowed = defaultSpecifiers.length !== 0 && (namespaceSpecifiers.length !== 0 || specifiers.length !== 0);\n      var canBreak = specifiers.length > 1 || defaultSpecifiers.length > 0 || decl.specifiers && decl.specifiers.some(function (node) {\n        return node.comments;\n      });\n      var printed = \"\";\n\n      if (specifiers.length !== 0) {\n        if (canBreak) {\n          printed = group(concat([\"{\", indent(concat([options.bracketSpacing ? line : softline, join(concat([\",\", line]), specifiers)])), ifBreak(shouldPrintComma(options) ? \",\" : \"\"), options.bracketSpacing ? line : softline, \"}\"]));\n        } else {\n          printed = concat([\"{\", options.bracketSpacing ? \" \" : \"\", concat(specifiers), options.bracketSpacing ? \" \" : \"\", \"}\"]);\n        }\n      }\n\n      parts.push(decl.exportKind === \"type\" ? \"type \" : \"\", concat(defaultSpecifiers), concat([isDefaultFollowed ? \", \" : \"\"]), concat(namespaceSpecifiers), concat([isNamespaceFollowed ? \", \" : \"\"]), printed);\n    } else {\n      parts.push(\"{}\");\n    }\n\n    if (decl.source) {\n      parts.push(\" from \", path.call(print, \"source\"));\n    }\n\n    parts.push(semi);\n  }\n\n  return concat(parts);\n}\n\nfunction printFlowDeclaration(path, parts) {\n  var parentExportDecl = getParentExportDeclaration(path);\n\n  if (parentExportDecl) {\n    assert.strictEqual(parentExportDecl.type, \"DeclareExportDeclaration\");\n  } else {\n    // If the parent node has type DeclareExportDeclaration, then it\n    // will be responsible for printing the \"declare\" token. Otherwise\n    // it needs to be printed with this non-exported declaration node.\n    parts.unshift(\"declare \");\n  }\n\n  return concat(parts);\n}\n\nfunction getFlowVariance(path) {\n  if (!path.variance) {\n    return null;\n  } // Babel 7.0 currently uses variance node type, and flow should\n  // follow suit soon:\n  // https://github.com/babel/babel/issues/4722\n\n\n  var variance = path.variance.kind || path.variance;\n\n  switch (variance) {\n    case \"plus\":\n      return \"+\";\n\n    case \"minus\":\n      return \"-\";\n\n    default:\n      /* istanbul ignore next */\n      return variance;\n  }\n}\n\nfunction printTypeScriptModifiers(path, options, print) {\n  var n = path.getValue();\n\n  if (!n.modifiers || !n.modifiers.length) {\n    return \"\";\n  }\n\n  return concat([join(\" \", path.map(print, \"modifiers\")), \" \"]);\n}\n\nfunction printTypeParameters(path, options, print, paramsKey) {\n  var n = path.getValue();\n\n  if (!n[paramsKey]) {\n    return \"\";\n  } // for TypeParameterDeclaration typeParameters is a single node\n\n\n  if (!Array.isArray(n[paramsKey])) {\n    return path.call(print, paramsKey);\n  }\n\n  var grandparent = path.getNode(2);\n  var isParameterInTestCall = grandparent != null && isTestCall(grandparent);\n  var shouldInline = isParameterInTestCall || n[paramsKey].length === 0 || n[paramsKey].length === 1 && (shouldHugType(n[paramsKey][0]) || n[paramsKey][0].type === \"GenericTypeAnnotation\" && shouldHugType(n[paramsKey][0].id) || n[paramsKey][0].type === \"TSTypeReference\" && shouldHugType(n[paramsKey][0].typeName) || n[paramsKey][0].type === \"NullableTypeAnnotation\");\n\n  if (shouldInline) {\n    return concat([\"<\", join(\", \", path.map(print, paramsKey)), \">\"]);\n  }\n\n  return group(concat([\"<\", indent(concat([softline, join(concat([\",\", line]), path.map(print, paramsKey))])), ifBreak(options.parser !== \"typescript\" && shouldPrintComma(options, \"all\") ? \",\" : \"\"), softline, \">\"]));\n}\n\nfunction printClass(path, options, print) {\n  var n = path.getValue();\n  var parts = [];\n\n  if (n[\"abstract\"]) {\n    parts.push(\"abstract \");\n  }\n\n  parts.push(\"class\");\n\n  if (n.id) {\n    parts.push(\" \", path.call(print, \"id\"));\n  }\n\n  parts.push(path.call(print, \"typeParameters\"));\n  var partsGroup = [];\n\n  if (n.superClass) {\n    var printed = concat([\"extends \", path.call(print, \"superClass\"), path.call(print, \"superTypeParameters\")]); // Keep old behaviour of extends in same line\n    // If there is only on extends and there are not comments\n\n    if ((!n[\"implements\"] || n[\"implements\"].length === 0) && (!n.superClass.comments || n.superClass.comments.length === 0)) {\n      parts.push(concat([\" \", path.call(function (superClass) {\n        return comments.printComments(superClass, function () {\n          return printed;\n        }, options);\n      }, \"superClass\")]));\n    } else {\n      partsGroup.push(group(concat([line, path.call(function (superClass) {\n        return comments.printComments(superClass, function () {\n          return printed;\n        }, options);\n      }, \"superClass\")])));\n    }\n  } else if (n[\"extends\"] && n[\"extends\"].length > 0) {\n    parts.push(\" extends \", join(\", \", path.map(print, \"extends\")));\n  }\n\n  if (n[\"mixins\"] && n[\"mixins\"].length > 0) {\n    partsGroup.push(line, \"mixins \", group(indent(join(concat([\",\", line]), path.map(print, \"mixins\")))));\n  }\n\n  if (n[\"implements\"] && n[\"implements\"].length > 0) {\n    partsGroup.push(line, \"implements\", group(indent(concat([line, join(concat([\",\", line]), path.map(print, \"implements\"))]))));\n  }\n\n  if (partsGroup.length > 0) {\n    parts.push(group(indent(concat(partsGroup))));\n  }\n\n  if (n.body && n.body.comments && hasLeadingOwnLineComment(options.originalText, n.body, options)) {\n    parts.push(hardline);\n  } else {\n    parts.push(\" \");\n  }\n\n  parts.push(path.call(print, \"body\"));\n  return parts;\n}\n\nfunction printOptionalToken(path) {\n  var node = path.getValue();\n\n  if (!node.optional) {\n    return \"\";\n  }\n\n  if (node.type === \"OptionalCallExpression\" || node.type === \"OptionalMemberExpression\" && node.computed) {\n    return \"?.\";\n  }\n\n  return \"?\";\n}\n\nfunction printMemberLookup(path, options, print) {\n  var property = path.call(print, \"property\");\n  var n = path.getValue();\n  var optional = printOptionalToken(path);\n\n  if (!n.computed) {\n    return concat([optional, \".\", property]);\n  }\n\n  if (!n.property || isNumericLiteral(n.property)) {\n    return concat([optional, \"[\", property, \"]\"]);\n  }\n\n  return group(concat([optional, \"[\", indent(concat([softline, property])), softline, \"]\"]));\n}\n\nfunction printBindExpressionCallee(path, options, print) {\n  return concat([\"::\", path.call(print, \"callee\")]);\n} // We detect calls on member expressions specially to format a\n// common pattern better. The pattern we are looking for is this:\n//\n// arr\n//   .map(x => x + 1)\n//   .filter(x => x > 10)\n//   .some(x => x % 2)\n//\n// The way it is structured in the AST is via a nested sequence of\n// MemberExpression and CallExpression. We need to traverse the AST\n// and make groups out of it to print it in the desired way.\n\n\nfunction printMemberChain(path, options, print) {\n  // The first phase is to linearize the AST by traversing it down.\n  //\n  //   a().b()\n  // has the following AST structure:\n  //   CallExpression(MemberExpression(CallExpression(Identifier)))\n  // and we transform it into\n  //   [Identifier, CallExpression, MemberExpression, CallExpression]\n  var printedNodes = []; // Here we try to retain one typed empty line after each call expression or\n  // the first group whether it is in parentheses or not\n\n  function shouldInsertEmptyLineAfter(node) {\n    var originalText = options.originalText;\n    var nextCharIndex = getNextNonSpaceNonCommentCharacterIndex(originalText, node, options);\n    var nextChar = originalText.charAt(nextCharIndex); // if it is cut off by a parenthesis, we only account for one typed empty\n    // line after that parenthesis\n\n    if (nextChar == \")\") {\n      return isNextLineEmptyAfterIndex(originalText, nextCharIndex + 1, options);\n    }\n\n    return isNextLineEmpty(originalText, node, options);\n  }\n\n  function rec(path) {\n    var node = path.getValue();\n\n    if ((node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\") && (isMemberish(node.callee) || node.callee.type === \"CallExpression\" || node.callee.type === \"OptionalCallExpression\")) {\n      printedNodes.unshift({\n        node: node,\n        printed: concat([comments.printComments(path, function () {\n          return concat([printOptionalToken(path), printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]);\n        }, options), shouldInsertEmptyLineAfter(node) ? hardline : \"\"])\n      });\n      path.call(function (callee) {\n        return rec(callee);\n      }, \"callee\");\n    } else if (isMemberish(node)) {\n      printedNodes.unshift({\n        node: node,\n        needsParens: pathNeedsParens(path, options),\n        printed: comments.printComments(path, function () {\n          return node.type === \"OptionalMemberExpression\" || node.type === \"MemberExpression\" ? printMemberLookup(path, options, print) : printBindExpressionCallee(path, options, print);\n        }, options)\n      });\n      path.call(function (object) {\n        return rec(object);\n      }, \"object\");\n    } else if (node.type === \"TSNonNullExpression\") {\n      printedNodes.unshift({\n        node: node,\n        printed: comments.printComments(path, function () {\n          return \"!\";\n        }, options)\n      });\n      path.call(function (expression) {\n        return rec(expression);\n      }, \"expression\");\n    } else {\n      printedNodes.unshift({\n        node: node,\n        printed: path.call(print)\n      });\n    }\n  } // Note: the comments of the root node have already been printed, so we\n  // need to extract this first call without printing them as they would\n  // if handled inside of the recursive call.\n\n\n  var node = path.getValue();\n  printedNodes.unshift({\n    node: node,\n    printed: concat([printOptionalToken(path), printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)])\n  });\n  path.call(function (callee) {\n    return rec(callee);\n  }, \"callee\"); // Once we have a linear list of printed nodes, we want to create groups out\n  // of it.\n  //\n  //   a().b.c().d().e\n  // will be grouped as\n  //   [\n  //     [Identifier, CallExpression],\n  //     [MemberExpression, MemberExpression, CallExpression],\n  //     [MemberExpression, CallExpression],\n  //     [MemberExpression],\n  //   ]\n  // so that we can print it as\n  //   a()\n  //     .b.c()\n  //     .d()\n  //     .e\n  // The first group is the first node followed by\n  //   - as many CallExpression as possible\n  //       < fn()()() >.something()\n  //   - as many array acessors as possible\n  //       < fn()[0][1][2] >.something()\n  //   - then, as many MemberExpression as possible but the last one\n  //       < this.items >.something()\n\n  var groups = [];\n  var currentGroup = [printedNodes[0]];\n  var i = 1;\n\n  for (; i < printedNodes.length; ++i) {\n    if (printedNodes[i].node.type === \"TSNonNullExpression\" || printedNodes[i].node.type === \"OptionalCallExpression\" || printedNodes[i].node.type === \"CallExpression\" || (printedNodes[i].node.type === \"MemberExpression\" || printedNodes[i].node.type === \"OptionalMemberExpression\") && printedNodes[i].node.computed && isNumericLiteral(printedNodes[i].node.property)) {\n      currentGroup.push(printedNodes[i]);\n    } else {\n      break;\n    }\n  }\n\n  if (printedNodes[0].node.type !== \"CallExpression\" && printedNodes[0].node.type !== \"OptionalCallExpression\") {\n    for (; i + 1 < printedNodes.length; ++i) {\n      if (isMemberish(printedNodes[i].node) && isMemberish(printedNodes[i + 1].node)) {\n        currentGroup.push(printedNodes[i]);\n      } else {\n        break;\n      }\n    }\n  }\n\n  groups.push(currentGroup);\n  currentGroup = []; // Then, each following group is a sequence of MemberExpression followed by\n  // a sequence of CallExpression. To compute it, we keep adding things to the\n  // group until we has seen a CallExpression in the past and reach a\n  // MemberExpression\n\n  var hasSeenCallExpression = false;\n\n  for (; i < printedNodes.length; ++i) {\n    if (hasSeenCallExpression && isMemberish(printedNodes[i].node)) {\n      // [0] should be appended at the end of the group instead of the\n      // beginning of the next one\n      if (printedNodes[i].node.computed && isNumericLiteral(printedNodes[i].node.property)) {\n        currentGroup.push(printedNodes[i]);\n        continue;\n      }\n\n      groups.push(currentGroup);\n      currentGroup = [];\n      hasSeenCallExpression = false;\n    }\n\n    if (printedNodes[i].node.type === \"CallExpression\" || printedNodes[i].node.type === \"OptionalCallExpression\") {\n      hasSeenCallExpression = true;\n    }\n\n    currentGroup.push(printedNodes[i]);\n\n    if (printedNodes[i].node.comments && printedNodes[i].node.comments.some(function (comment) {\n      return comment.trailing;\n    })) {\n      groups.push(currentGroup);\n      currentGroup = [];\n      hasSeenCallExpression = false;\n    }\n  }\n\n  if (currentGroup.length > 0) {\n    groups.push(currentGroup);\n  } // There are cases like Object.keys(), Observable.of(), _.values() where\n  // they are the subject of all the chained calls and therefore should\n  // be kept on the same line:\n  //\n  //   Object.keys(items)\n  //     .filter(x => x)\n  //     .map(x => x)\n  //\n  // In order to detect those cases, we use an heuristic: if the first\n  // node is an identifier with the name starting with a capital\n  // letter or just a sequence of _$. The rationale is that they are\n  // likely to be factories.\n\n\n  function isFactory(name) {\n    return /^[A-Z]|^[_$]+$/.test(name);\n  } // In case the Identifier is shorter than tab width, we can keep the\n  // first call in a single line, if it's an ExpressionStatement.\n  //\n  //   d3.scaleLinear()\n  //     .domain([0, 100])\n  //     .range([0, width]);\n  //\n\n\n  function isShort(name) {\n    return name.length <= options.tabWidth;\n  }\n\n  function shouldNotWrap(groups) {\n    var parent = path.getParentNode();\n    var isExpression = parent && parent.type === \"ExpressionStatement\";\n    var hasComputed = groups[1].length && groups[1][0].node.computed;\n\n    if (groups[0].length === 1) {\n      var firstNode = groups[0][0].node;\n      return firstNode.type === \"ThisExpression\" || firstNode.type === \"Identifier\" && (isFactory(firstNode.name) || isExpression && isShort(firstNode.name) || hasComputed);\n    }\n\n    var lastNode = getLast(groups[0]).node;\n    return (lastNode.type === \"MemberExpression\" || lastNode.type === \"OptionalMemberExpression\") && lastNode.property.type === \"Identifier\" && (isFactory(lastNode.property.name) || hasComputed);\n  }\n\n  var shouldMerge = groups.length >= 2 && !groups[1][0].node.comments && shouldNotWrap(groups);\n\n  function printGroup(printedGroup) {\n    var printed = printedGroup.map(function (tuple) {\n      return tuple.printed;\n    }); // Checks if the last node (i.e. the parent node) needs parens and print\n    // accordingly\n\n    if (printedGroup.length > 0 && printedGroup[printedGroup.length - 1].needsParens) {\n      return concat([\"(\"].concat(_toConsumableArray(printed), [\")\"]));\n    }\n\n    return concat(printed);\n  }\n\n  function printIndentedGroup(groups) {\n    if (groups.length === 0) {\n      return \"\";\n    }\n\n    return indent(group(concat([hardline, join(hardline, groups.map(printGroup))])));\n  }\n\n  var printedGroups = groups.map(printGroup);\n  var oneLine = concat(printedGroups);\n  var cutoff = shouldMerge ? 3 : 2;\n  var flatGroups = groups.slice(0, cutoff).reduce(function (res, group) {\n    return res.concat(group);\n  }, []);\n  var hasComment = flatGroups.slice(1, -1).some(function (node) {\n    return hasLeadingComment(node.node);\n  }) || flatGroups.slice(0, -1).some(function (node) {\n    return hasTrailingComment(node.node);\n  }) || groups[cutoff] && hasLeadingComment(groups[cutoff][0].node); // If we only have a single `.`, we shouldn't do anything fancy and just\n  // render everything concatenated together.\n\n  if (groups.length <= cutoff && !hasComment) {\n    return group(oneLine);\n  } // Find out the last node in the first group and check if it has an\n  // empty line after\n\n\n  var lastNodeBeforeIndent = getLast(shouldMerge ? groups.slice(1, 2)[0] : groups[0]).node;\n  var shouldHaveEmptyLineBeforeIndent = lastNodeBeforeIndent.type !== \"CallExpression\" && lastNodeBeforeIndent.type !== \"OptionalCallExpression\" && shouldInsertEmptyLineAfter(lastNodeBeforeIndent);\n  var expanded = concat([printGroup(groups[0]), shouldMerge ? concat(groups.slice(1, 2).map(printGroup)) : \"\", shouldHaveEmptyLineBeforeIndent ? hardline : \"\", printIndentedGroup(groups.slice(shouldMerge ? 2 : 1))]);\n  var callExpressions = printedNodes.map(function (_ref) {\n    var node = _ref.node;\n    return node;\n  }).filter(isCallOrOptionalCallExpression); // We don't want to print in one line if there's:\n  //  * A comment.\n  //  * 3 or more chained calls.\n  //  * Any group but the last one has a hard line.\n  // If the last group is a function it's okay to inline if it fits.\n\n  if (hasComment || callExpressions.length >= 3 || printedGroups.slice(0, -1).some(willBreak) ||\n  /**\n   *     scopes.filter(scope => scope.value !== '').map((scope, i) => {\n   *       // multi line content\n   *     })\n   */\n  function (lastGroupDoc, lastGroupNode) {\n    return isCallOrOptionalCallExpression(lastGroupNode) && willBreak(lastGroupDoc);\n  }(getLast(printedGroups), getLast(getLast(groups)).node) && callExpressions.slice(0, -1).some(function (n) {\n    return n.arguments.some(isFunctionOrArrowExpression);\n  })) {\n    return group(expanded);\n  }\n\n  return concat([// We only need to check `oneLine` because if `expanded` is chosen\n  // that means that the parent group has already been broken\n  // naturally\n  willBreak(oneLine) || shouldHaveEmptyLineBeforeIndent ? breakParent : \"\", conditionalGroup([oneLine, expanded])]);\n}\n\nfunction isCallOrOptionalCallExpression(node) {\n  return node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\";\n}\n\nfunction isJSXNode(node) {\n  return node.type === \"JSXElement\" || node.type === \"JSXFragment\";\n}\n\nfunction isEmptyJSXElement(node) {\n  if (node.children.length === 0) {\n    return true;\n  }\n\n  if (node.children.length > 1) {\n    return false;\n  } // if there is one text child and does not contain any meaningful text\n  // we can treat the element as empty.\n\n\n  var child = node.children[0];\n  return isLiteral(child) && !isMeaningfulJSXText(child);\n} // Only space, newline, carriage return, and tab are treated as whitespace\n// inside JSX.\n\n\nvar jsxWhitespaceChars = \" \\n\\r\\t\";\nvar containsNonJsxWhitespaceRegex = new RegExp(\"[^\" + jsxWhitespaceChars + \"]\");\nvar matchJsxWhitespaceRegex = new RegExp(\"([\" + jsxWhitespaceChars + \"]+)\"); // Meaningful if it contains non-whitespace characters,\n// or it contains whitespace without a new line.\n\nfunction isMeaningfulJSXText(node) {\n  return isLiteral(node) && (containsNonJsxWhitespaceRegex.test(rawText(node)) || !/\\n/.test(rawText(node)));\n}\n\nfunction conditionalExpressionChainContainsJSX(node) {\n  return Boolean(getConditionalChainContents(node).find(isJSXNode));\n} // If we have nested conditional expressions, we want to print them in JSX mode\n// if there's at least one JSXElement somewhere in the tree.\n//\n// A conditional expression chain like this should be printed in normal mode,\n// because there aren't JSXElements anywhere in it:\n//\n// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : \"Unknown\";\n//\n// But a conditional expression chain like this should be printed in JSX mode,\n// because there is a JSXElement in the last ConditionalExpression:\n//\n// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : <span className=\"warning\">Unknown</span>;\n//\n// This type of ConditionalExpression chain is structured like this in the AST:\n//\n// ConditionalExpression {\n//   test: ...,\n//   consequent: ...,\n//   alternate: ConditionalExpression {\n//     test: ...,\n//     consequent: ...,\n//     alternate: ConditionalExpression {\n//       test: ...,\n//       consequent: ...,\n//       alternate: ...,\n//     }\n//   }\n// }\n//\n// We want to traverse over that shape and convert it into a flat structure so\n// that we can find if there's a JSXElement somewhere inside.\n\n\nfunction getConditionalChainContents(node) {\n  // Given this code:\n  //\n  // // Using a ConditionalExpression as the consequent is uncommon, but should\n  // // be handled.\n  // A ? B : C ? D : E ? F ? G : H : I\n  //\n  // which has this AST:\n  //\n  // ConditionalExpression {\n  //   test: Identifier(A),\n  //   consequent: Identifier(B),\n  //   alternate: ConditionalExpression {\n  //     test: Identifier(C),\n  //     consequent: Identifier(D),\n  //     alternate: ConditionalExpression {\n  //       test: Identifier(E),\n  //       consequent: ConditionalExpression {\n  //         test: Identifier(F),\n  //         consequent: Identifier(G),\n  //         alternate: Identifier(H),\n  //       },\n  //       alternate: Identifier(I),\n  //     }\n  //   }\n  // }\n  //\n  // we should return this Array:\n  //\n  // [\n  //   Identifier(A),\n  //   Identifier(B),\n  //   Identifier(C),\n  //   Identifier(D),\n  //   Identifier(E),\n  //   Identifier(F),\n  //   Identifier(G),\n  //   Identifier(H),\n  //   Identifier(I)\n  // ];\n  //\n  // This loses the information about whether each node was the test,\n  // consequent, or alternate, but we don't care about that here- we are only\n  // flattening this structure to find if there's any JSXElements inside.\n  var nonConditionalExpressions = [];\n\n  function recurse(node) {\n    if (node.type === \"ConditionalExpression\") {\n      recurse(node.test);\n      recurse(node.consequent);\n      recurse(node.alternate);\n    } else {\n      nonConditionalExpressions.push(node);\n    }\n  }\n\n  recurse(node);\n  return nonConditionalExpressions;\n} // Detect an expression node representing `{\" \"}`\n\n\nfunction isJSXWhitespaceExpression(node) {\n  return node.type === \"JSXExpressionContainer\" && isLiteral(node.expression) && node.expression.value === \" \" && !node.expression.comments;\n}\n\nfunction separatorNoWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {\n  if (isFacebookTranslationTag) {\n    return \"\";\n  }\n\n  if (childNode.type === \"JSXElement\" && !childNode.closingElement || nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement) {\n    return child.length === 1 ? softline : hardline;\n  }\n\n  return softline;\n}\n\nfunction separatorWithWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {\n  if (isFacebookTranslationTag) {\n    return hardline;\n  }\n\n  if (child.length === 1) {\n    return childNode.type === \"JSXElement\" && !childNode.closingElement || nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement ? hardline : softline;\n  }\n\n  return hardline;\n} // JSX Children are strange, mostly for two reasons:\n// 1. JSX reads newlines into string values, instead of skipping them like JS\n// 2. up to one whitespace between elements within a line is significant,\n//    but not between lines.\n//\n// Leading, trailing, and lone whitespace all need to\n// turn themselves into the rather ugly `{' '}` when breaking.\n//\n// We print JSX using the `fill` doc primitive.\n// This requires that we give it an array of alternating\n// content and whitespace elements.\n// To ensure this we add dummy `\"\"` content elements as needed.\n\n\nfunction printJSXChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag) {\n  var n = path.getValue();\n  var children = []; // using `map` instead of `each` because it provides `i`\n\n  path.map(function (childPath, i) {\n    var child = childPath.getValue();\n\n    if (isLiteral(child)) {\n      var text = rawText(child); // Contains a non-whitespace character\n\n      if (isMeaningfulJSXText(child)) {\n        var words = text.split(matchJsxWhitespaceRegex); // Starts with whitespace\n\n        if (words[0] === \"\") {\n          children.push(\"\");\n          words.shift();\n\n          if (/\\n/.test(words[0])) {\n            var next = n.children[i + 1];\n            children.push(separatorWithWhitespace(isFacebookTranslationTag, words[1], child, next));\n          } else {\n            children.push(jsxWhitespace);\n          }\n\n          words.shift();\n        }\n\n        var endWhitespace; // Ends with whitespace\n\n        if (getLast(words) === \"\") {\n          words.pop();\n          endWhitespace = words.pop();\n        } // This was whitespace only without a new line.\n\n\n        if (words.length === 0) {\n          return;\n        }\n\n        words.forEach(function (word, i) {\n          if (i % 2 === 1) {\n            children.push(line);\n          } else {\n            children.push(word);\n          }\n        });\n\n        if (endWhitespace !== undefined) {\n          if (/\\n/.test(endWhitespace)) {\n            var _next = n.children[i + 1];\n            children.push(separatorWithWhitespace(isFacebookTranslationTag, getLast(children), child, _next));\n          } else {\n            children.push(jsxWhitespace);\n          }\n        } else {\n          var _next2 = n.children[i + 1];\n          children.push(separatorNoWhitespace(isFacebookTranslationTag, getLast(children), child, _next2));\n        }\n      } else if (/\\n/.test(text)) {\n        // Keep (up to one) blank line between tags/expressions/text.\n        // Note: We don't keep blank lines between text elements.\n        if (text.match(/\\n/g).length > 1) {\n          children.push(\"\");\n          children.push(hardline);\n        }\n      } else {\n        children.push(\"\");\n        children.push(jsxWhitespace);\n      }\n    } else {\n      var printedChild = print(childPath);\n      children.push(printedChild);\n      var _next3 = n.children[i + 1];\n\n      var directlyFollowedByMeaningfulText = _next3 && isMeaningfulJSXText(_next3);\n\n      if (directlyFollowedByMeaningfulText) {\n        var firstWord = rawText(_next3).trim().split(matchJsxWhitespaceRegex)[0];\n        children.push(separatorNoWhitespace(isFacebookTranslationTag, firstWord, child, _next3));\n      } else {\n        children.push(hardline);\n      }\n    }\n  }, \"children\");\n  return children;\n} // JSX expands children from the inside-out, instead of the outside-in.\n// This is both to break children before attributes,\n// and to ensure that when children break, their parents do as well.\n//\n// Any element that is written without any newlines and fits on a single line\n// is left that way.\n// Not only that, any user-written-line containing multiple JSX siblings\n// should also be kept on one line if possible,\n// so each user-written-line is wrapped in its own group.\n//\n// Elements that contain newlines or don't fit on a single line (recursively)\n// are fully-split, using hardline and shouldBreak: true.\n//\n// To support that case properly, all leading and trailing spaces\n// are stripped from the list of children, and replaced with a single hardline.\n\n\nfunction printJSXElement(path, options, print) {\n  var n = path.getValue();\n\n  if (n.type === \"JSXElement\" && isEmptyJSXElement(n)) {\n    return concat([path.call(print, \"openingElement\"), path.call(print, \"closingElement\")]);\n  }\n\n  var openingLines = n.type === \"JSXElement\" ? path.call(print, \"openingElement\") : path.call(print, \"openingFragment\");\n  var closingLines = n.type === \"JSXElement\" ? path.call(print, \"closingElement\") : path.call(print, \"closingFragment\");\n\n  if (n.children.length === 1 && n.children[0].type === \"JSXExpressionContainer\" && (n.children[0].expression.type === \"TemplateLiteral\" || n.children[0].expression.type === \"TaggedTemplateExpression\")) {\n    return concat([openingLines, concat(path.map(print, \"children\")), closingLines]);\n  } // Convert `{\" \"}` to text nodes containing a space.\n  // This makes it easy to turn them into `jsxWhitespace` which\n  // can then print as either a space or `{\" \"}` when breaking.\n\n\n  n.children = n.children.map(function (child) {\n    if (isJSXWhitespaceExpression(child)) {\n      return {\n        type: \"JSXText\",\n        value: \" \",\n        raw: \" \"\n      };\n    }\n\n    return child;\n  });\n  var containsTag = n.children.filter(isJSXNode).length > 0;\n  var containsMultipleExpressions = n.children.filter(function (child) {\n    return child.type === \"JSXExpressionContainer\";\n  }).length > 1;\n  var containsMultipleAttributes = n.type === \"JSXElement\" && n.openingElement.attributes.length > 1; // Record any breaks. Should never go from true to false, only false to true.\n\n  var forcedBreak = willBreak(openingLines) || containsTag || containsMultipleAttributes || containsMultipleExpressions;\n  var rawJsxWhitespace = options.singleQuote ? \"{' '}\" : '{\" \"}';\n  var jsxWhitespace = ifBreak(concat([rawJsxWhitespace, softline]), \" \");\n  var isFacebookTranslationTag = n.openingElement && n.openingElement.name && n.openingElement.name.name === \"fbt\";\n  var children = printJSXChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag);\n  var containsText = n.children.filter(function (child) {\n    return isMeaningfulJSXText(child);\n  }).length > 0; // We can end up we multiple whitespace elements with empty string\n  // content between them.\n  // We need to remove empty whitespace and softlines before JSX whitespace\n  // to get the correct output.\n\n  for (var i = children.length - 2; i >= 0; i--) {\n    var isPairOfEmptyStrings = children[i] === \"\" && children[i + 1] === \"\";\n    var isPairOfHardlines = children[i] === hardline && children[i + 1] === \"\" && children[i + 2] === hardline;\n    var isLineFollowedByJSXWhitespace = (children[i] === softline || children[i] === hardline) && children[i + 1] === \"\" && children[i + 2] === jsxWhitespace;\n    var isJSXWhitespaceFollowedByLine = children[i] === jsxWhitespace && children[i + 1] === \"\" && (children[i + 2] === softline || children[i + 2] === hardline);\n    var isDoubleJSXWhitespace = children[i] === jsxWhitespace && children[i + 1] === \"\" && children[i + 2] === jsxWhitespace;\n    var isPairOfHardOrSoftLines = children[i] === softline && children[i + 1] === \"\" && children[i + 2] === hardline || children[i] === hardline && children[i + 1] === \"\" && children[i + 2] === softline;\n\n    if (isPairOfHardlines && containsText || isPairOfEmptyStrings || isLineFollowedByJSXWhitespace || isDoubleJSXWhitespace || isPairOfHardOrSoftLines) {\n      children.splice(i, 2);\n    } else if (isJSXWhitespaceFollowedByLine) {\n      children.splice(i + 1, 2);\n    }\n  } // Trim trailing lines (or empty strings)\n\n\n  while (children.length && (isLineNext(getLast(children)) || isEmpty(getLast(children)))) {\n    children.pop();\n  } // Trim leading lines (or empty strings)\n\n\n  while (children.length && (isLineNext(children[0]) || isEmpty(children[0])) && (isLineNext(children[1]) || isEmpty(children[1]))) {\n    children.shift();\n    children.shift();\n  } // Tweak how we format children if outputting this element over multiple lines.\n  // Also detect whether we will force this element to output over multiple lines.\n\n\n  var multilineChildren = [];\n  children.forEach(function (child, i) {\n    // There are a number of situations where we need to ensure we display\n    // whitespace as `{\" \"}` when outputting this element over multiple lines.\n    if (child === jsxWhitespace) {\n      if (i === 1 && children[i - 1] === \"\") {\n        if (children.length === 2) {\n          // Solitary whitespace\n          multilineChildren.push(rawJsxWhitespace);\n          return;\n        } // Leading whitespace\n\n\n        multilineChildren.push(concat([rawJsxWhitespace, hardline]));\n        return;\n      } else if (i === children.length - 1) {\n        // Trailing whitespace\n        multilineChildren.push(rawJsxWhitespace);\n        return;\n      } else if (children[i - 1] === \"\" && children[i - 2] === hardline) {\n        // Whitespace after line break\n        multilineChildren.push(rawJsxWhitespace);\n        return;\n      }\n    }\n\n    multilineChildren.push(child);\n\n    if (willBreak(child)) {\n      forcedBreak = true;\n    }\n  }); // If there is text we use `fill` to fit as much onto each line as possible.\n  // When there is no text (just tags and expressions) we use `group`\n  // to output each on a separate line.\n\n  var content = containsText ? fill(multilineChildren) : group(concat(multilineChildren), {\n    shouldBreak: true\n  });\n  var multiLineElem = group(concat([openingLines, indent(concat([hardline, content])), hardline, closingLines]));\n\n  if (forcedBreak) {\n    return multiLineElem;\n  }\n\n  return conditionalGroup([group(concat([openingLines, concat(children), closingLines])), multiLineElem]);\n}\n\nfunction maybeWrapJSXElementInParens(path, elem) {\n  var parent = path.getParentNode();\n\n  if (!parent) {\n    return elem;\n  }\n\n  var NO_WRAP_PARENTS = {\n    ArrayExpression: true,\n    JSXAttribute: true,\n    JSXElement: true,\n    JSXExpressionContainer: true,\n    JSXFragment: true,\n    ExpressionStatement: true,\n    CallExpression: true,\n    OptionalCallExpression: true,\n    ConditionalExpression: true,\n    JsExpressionRoot: true\n  };\n\n  if (NO_WRAP_PARENTS[parent.type]) {\n    return elem;\n  }\n\n  var shouldBreak = matchAncestorTypes(path, [\"ArrowFunctionExpression\", \"CallExpression\", \"JSXExpressionContainer\"]);\n  return group(concat([ifBreak(\"(\"), indent(concat([softline, elem])), softline, ifBreak(\")\")]), {\n    shouldBreak: shouldBreak\n  });\n}\n\nfunction isBinaryish(node) {\n  return node.type === \"BinaryExpression\" || node.type === \"LogicalExpression\" || node.type === \"NGPipeExpression\";\n}\n\nfunction isMemberish(node) {\n  return node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\" || node.type === \"BindExpression\" && node.object;\n}\n\nfunction shouldInlineLogicalExpression(node) {\n  if (node.type !== \"LogicalExpression\") {\n    return false;\n  }\n\n  if (node.right.type === \"ObjectExpression\" && node.right.properties.length !== 0) {\n    return true;\n  }\n\n  if (node.right.type === \"ArrayExpression\" && node.right.elements.length !== 0) {\n    return true;\n  }\n\n  if (isJSXNode(node.right)) {\n    return true;\n  }\n\n  return false;\n} // For binary expressions to be consistent, we need to group\n// subsequent operators with the same precedence level under a single\n// group. Otherwise they will be nested such that some of them break\n// onto new lines but not all. Operators with the same precedence\n// level should either all break or not. Because we group them by\n// precedence level and the AST is structured based on precedence\n// level, things are naturally broken up correctly, i.e. `&&` is\n// broken before `+`.\n\n\nfunction printBinaryishExpressions(path, print, options, isNested, isInsideParenthesis) {\n  var parts = [];\n  var node = path.getValue(); // We treat BinaryExpression and LogicalExpression nodes the same.\n\n  if (isBinaryish(node)) {\n    // Put all operators with the same precedence level in the same\n    // group. The reason we only need to do this with the `left`\n    // expression is because given an expression like `1 + 2 - 3`, it\n    // is always parsed like `((1 + 2) - 3)`, meaning the `left` side\n    // is where the rest of the expression will exist. Binary\n    // expressions on the right side mean they have a difference\n    // precedence level and should be treated as a separate group, so\n    // print them normally. (This doesn't hold for the `**` operator,\n    // which is unique in that it is right-associative.)\n    if (shouldFlatten(node.operator, node.left.operator)) {\n      // Flatten them out by recursively calling this function.\n      parts = parts.concat(path.call(function (left) {\n        return printBinaryishExpressions(left, print, options,\n        /* isNested */\n        true, isInsideParenthesis);\n      }, \"left\"));\n    } else {\n      parts.push(path.call(print, \"left\"));\n    }\n\n    var shouldInline = shouldInlineLogicalExpression(node);\n    var lineBeforeOperator = (node.operator === \"|>\" || node.type === \"NGPipeExpression\" || node.operator === \"|\" && options.parser === \"__vue_expression\") && !hasLeadingOwnLineComment(options.originalText, node.right, options);\n    var operator = node.type === \"NGPipeExpression\" ? \"|\" : node.operator;\n    var rightSuffix = node.type === \"NGPipeExpression\" && node.arguments.length !== 0 ? group(indent(concat([softline, \": \", join(concat([softline, \":\", ifBreak(\" \")]), path.map(print, \"arguments\").map(function (arg) {\n      return align(2, group(arg));\n    }))]))) : \"\";\n    var right = shouldInline ? concat([operator, \" \", path.call(print, \"right\"), rightSuffix]) : concat([lineBeforeOperator ? softline : \"\", operator, lineBeforeOperator ? \" \" : line, path.call(print, \"right\"), rightSuffix]); // If there's only a single binary expression, we want to create a group\n    // in order to avoid having a small right part like -1 be on its own line.\n\n    var parent = path.getParentNode();\n    var shouldGroup = !(isInsideParenthesis && node.type === \"LogicalExpression\") && parent.type !== node.type && node.left.type !== node.type && node.right.type !== node.type;\n    parts.push(\" \", shouldGroup ? group(right) : right); // The root comments are already printed, but we need to manually print\n    // the other ones since we don't call the normal print on BinaryExpression,\n    // only for the left and right parts\n\n    if (isNested && node.comments) {\n      parts = comments.printComments(path, function () {\n        return concat(parts);\n      }, options);\n    }\n  } else {\n    // Our stopping case. Simply print the node normally.\n    parts.push(path.call(print));\n  }\n\n  return parts;\n}\n\nfunction printAssignmentRight(leftNode, rightNode, printedRight, options) {\n  if (hasLeadingOwnLineComment(options.originalText, rightNode, options)) {\n    return indent(concat([hardline, printedRight]));\n  }\n\n  var canBreak = isBinaryish(rightNode) && !shouldInlineLogicalExpression(rightNode) || rightNode.type === \"ConditionalExpression\" && isBinaryish(rightNode.test) && !shouldInlineLogicalExpression(rightNode.test) || rightNode.type === \"StringLiteralTypeAnnotation\" || rightNode.type === \"ClassExpression\" && rightNode.decorators && rightNode.decorators.length || (leftNode.type === \"Identifier\" || isStringLiteral(leftNode) || leftNode.type === \"MemberExpression\") && (isStringLiteral(rightNode) || isMemberExpressionChain(rightNode)) && // do not put values on a separate line from the key in json\n  options.parser !== \"json\" && options.parser !== \"json5\" || rightNode.type === \"SequenceExpression\";\n\n  if (canBreak) {\n    return group(indent(concat([line, printedRight])));\n  }\n\n  return concat([\" \", printedRight]);\n}\n\nfunction printAssignment(leftNode, printedLeft, operator, rightNode, printedRight, options) {\n  if (!rightNode) {\n    return printedLeft;\n  }\n\n  var printed = printAssignmentRight(leftNode, rightNode, printedRight, options);\n  return group(concat([printedLeft, operator, printed]));\n}\n\nfunction adjustClause(node, clause, forceSpace) {\n  if (node.type === \"EmptyStatement\") {\n    return \";\";\n  }\n\n  if (node.type === \"BlockStatement\" || forceSpace) {\n    return concat([\" \", clause]);\n  }\n\n  return indent(concat([line, clause]));\n}\n\nfunction nodeStr(node, options, isFlowOrTypeScriptDirectiveLiteral) {\n  var raw = rawText(node);\n  var isDirectiveLiteral = isFlowOrTypeScriptDirectiveLiteral || node.type === \"DirectiveLiteral\";\n  return printString(raw, options, isDirectiveLiteral);\n}\n\nfunction printRegex(node) {\n  var flags = node.flags.split(\"\").sort().join(\"\");\n  return \"/\".concat(node.pattern, \"/\").concat(flags);\n}\n\nfunction isLastStatement(path) {\n  var parent = path.getParentNode();\n\n  if (!parent) {\n    return true;\n  }\n\n  var node = path.getValue();\n  var body = (parent.body || parent.consequent).filter(function (stmt) {\n    return stmt.type !== \"EmptyStatement\";\n  });\n  return body && body[body.length - 1] === node;\n}\n\nfunction hasLeadingComment(node) {\n  return node.comments && node.comments.some(function (comment) {\n    return comment.leading;\n  });\n}\n\nfunction hasTrailingComment(node) {\n  return node.comments && node.comments.some(function (comment) {\n    return comment.trailing;\n  });\n}\n\nfunction hasLeadingOwnLineComment(text, node, options) {\n  if (isJSXNode(node)) {\n    return hasNodeIgnoreComment(node);\n  }\n\n  var res = node.comments && node.comments.some(function (comment) {\n    return comment.leading && hasNewline(text, options.locEnd(comment));\n  });\n  return res;\n}\n\nfunction isFlowAnnotationComment(text, typeAnnotation, options) {\n  var start = options.locStart(typeAnnotation);\n  var end = skipWhitespace(text, options.locEnd(typeAnnotation));\n  return text.substr(start, 2) === \"/*\" && text.substr(end, 2) === \"*/\";\n}\n\nfunction exprNeedsASIProtection(path, options) {\n  var node = path.getValue();\n  var maybeASIProblem = pathNeedsParens(path, options) || node.type === \"ParenthesizedExpression\" || node.type === \"TypeCastExpression\" || node.type === \"ArrowFunctionExpression\" && !shouldPrintParamsWithoutParens(path, options) || node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\" || node.type === \"UnaryExpression\" && node.prefix && (node.operator === \"+\" || node.operator === \"-\") || node.type === \"TemplateLiteral\" || node.type === \"TemplateElement\" || isJSXNode(node) || node.type === \"BindExpression\" && !node.object || node.type === \"RegExpLiteral\" || node.type === \"Literal\" && node.pattern || node.type === \"Literal\" && node.regex;\n\n  if (maybeASIProblem) {\n    return true;\n  }\n\n  if (!hasNakedLeftSide(node)) {\n    return false;\n  }\n\n  return path.call.apply(path, [function (childPath) {\n    return exprNeedsASIProtection(childPath, options);\n  }].concat(getLeftSidePathName(path, node)));\n}\n\nfunction stmtNeedsASIProtection(path, options) {\n  var node = path.getNode();\n\n  if (node.type !== \"ExpressionStatement\") {\n    return false;\n  }\n\n  return path.call(function (childPath) {\n    return exprNeedsASIProtection(childPath, options);\n  }, \"expression\");\n}\n\nfunction classPropMayCauseASIProblems(path) {\n  var node = path.getNode();\n\n  if (node.type !== \"ClassProperty\") {\n    return false;\n  }\n\n  var name = node.key && node.key.name; // this isn't actually possible yet with most parsers available today\n  // so isn't properly tested yet.\n\n  if ((name === \"static\" || name === \"get\" || name === \"set\") && !node.value && !node.typeAnnotation) {\n    return true;\n  }\n}\n\nfunction classChildNeedsASIProtection(node) {\n  if (!node) {\n    return;\n  }\n\n  if (node[\"static\"] || node.accessibility // TypeScript\n  ) {\n      return false;\n    }\n\n  if (!node.computed) {\n    var name = node.key && node.key.name;\n\n    if (name === \"in\" || name === \"instanceof\") {\n      return true;\n    }\n  }\n\n  switch (node.type) {\n    case \"ClassProperty\":\n    case \"TSAbstractClassProperty\":\n      return node.computed;\n\n    case \"MethodDefinition\": // Flow\n\n    case \"TSAbstractMethodDefinition\": // TypeScript\n\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      {\n        // Babel\n        var isAsync = node.value ? node.value.async : node.async;\n        var isGenerator = node.value ? node.value.generator : node.generator;\n\n        if (isAsync || node.kind === \"get\" || node.kind === \"set\") {\n          return false;\n        }\n\n        if (node.computed || isGenerator) {\n          return true;\n        }\n\n        return false;\n      }\n\n    default:\n      /* istanbul ignore next */\n      return false;\n  }\n} // This recurses the return argument, looking for the first token\n// (the leftmost leaf node) and, if it (or its parents) has any\n// leadingComments, returns true (so it can be wrapped in parens).\n\n\nfunction returnArgumentHasLeadingComment(options, argument) {\n  if (hasLeadingOwnLineComment(options.originalText, argument, options)) {\n    return true;\n  }\n\n  if (hasNakedLeftSide(argument)) {\n    var leftMost = argument;\n    var newLeftMost;\n\n    while (newLeftMost = getLeftSide(leftMost)) {\n      leftMost = newLeftMost;\n\n      if (hasLeadingOwnLineComment(options.originalText, leftMost, options)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction isMemberExpressionChain(node) {\n  if (node.type !== \"MemberExpression\" && node.type !== \"OptionalMemberExpression\") {\n    return false;\n  }\n\n  if (node.object.type === \"Identifier\") {\n    return true;\n  }\n\n  return isMemberExpressionChain(node.object);\n} // Hack to differentiate between the following two which have the same ast\n// type T = { method: () => void };\n// type T = { method(): void };\n\n\nfunction isObjectTypePropertyAFunction(node, options) {\n  return (node.type === \"ObjectTypeProperty\" || node.type === \"ObjectTypeInternalSlot\") && node.value.type === \"FunctionTypeAnnotation\" && !node[\"static\"] && !isFunctionNotation(node, options);\n} // TODO: This is a bad hack and we need a better way to distinguish between\n// arrow functions and otherwise\n\n\nfunction isFunctionNotation(node, options) {\n  return isGetterOrSetter(node) || sameLocStart(node, node.value, options);\n}\n\nfunction isGetterOrSetter(node) {\n  return node.kind === \"get\" || node.kind === \"set\";\n}\n\nfunction sameLocStart(nodeA, nodeB, options) {\n  return options.locStart(nodeA) === options.locStart(nodeB);\n} // Hack to differentiate between the following two which have the same ast\n// declare function f(a): void;\n// var f: (a) => void;\n\n\nfunction isTypeAnnotationAFunction(node, options) {\n  return (node.type === \"TypeAnnotation\" || node.type === \"TSTypeAnnotation\") && node.typeAnnotation.type === \"FunctionTypeAnnotation\" && !node[\"static\"] && !sameLocStart(node, node.typeAnnotation, options);\n}\n\nfunction isNodeStartingWithDeclare(node, options) {\n  if (!(options.parser === \"flow\" || options.parser === \"typescript\")) {\n    return false;\n  }\n\n  return options.originalText.slice(0, options.locStart(node)).match(/declare[ \\t]*$/) || options.originalText.slice(node.range[0], node.range[1]).startsWith(\"declare \");\n}\n\nfunction shouldHugType(node) {\n  if (isSimpleFlowType(node) || isObjectType(node)) {\n    return true;\n  }\n\n  if (node.type === \"UnionTypeAnnotation\" || node.type === \"TSUnionType\") {\n    var voidCount = node.types.filter(function (n) {\n      return n.type === \"VoidTypeAnnotation\" || n.type === \"TSVoidKeyword\" || n.type === \"NullLiteralTypeAnnotation\" || n.type === \"TSNullKeyword\";\n    }).length;\n    var objectCount = node.types.filter(function (n) {\n      return n.type === \"ObjectTypeAnnotation\" || n.type === \"TSTypeLiteral\" || // This is a bit aggressive but captures Array<{x}>\n      n.type === \"GenericTypeAnnotation\" || n.type === \"TSTypeReference\";\n    }).length;\n\n    if (node.types.length - 1 === voidCount && objectCount > 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldHugArguments(fun) {\n  return fun && fun.params && fun.params.length === 1 && !fun.params[0].comments && (fun.params[0].type === \"ObjectPattern\" || fun.params[0].type === \"ArrayPattern\" || fun.params[0].type === \"Identifier\" && fun.params[0].typeAnnotation && (fun.params[0].typeAnnotation.type === \"TypeAnnotation\" || fun.params[0].typeAnnotation.type === \"TSTypeAnnotation\") && isObjectType(fun.params[0].typeAnnotation.typeAnnotation) || fun.params[0].type === \"FunctionTypeParam\" && isObjectType(fun.params[0].typeAnnotation) || fun.params[0].type === \"AssignmentPattern\" && (fun.params[0].left.type === \"ObjectPattern\" || fun.params[0].left.type === \"ArrayPattern\") && (fun.params[0].right.type === \"Identifier\" || fun.params[0].right.type === \"ObjectExpression\" && fun.params[0].right.properties.length === 0 || fun.params[0].right.type === \"ArrayExpression\" && fun.params[0].right.elements.length === 0)) && !fun.rest;\n}\n\nfunction templateLiteralHasNewLines(template) {\n  return template.quasis.some(function (quasi) {\n    return quasi.value.raw.includes(\"\\n\");\n  });\n}\n\nfunction isTemplateOnItsOwnLine(n, text, options) {\n  return (n.type === \"TemplateLiteral\" && templateLiteralHasNewLines(n) || n.type === \"TaggedTemplateExpression\" && templateLiteralHasNewLines(n.quasi)) && !hasNewline(text, options.locStart(n), {\n    backwards: true\n  });\n}\n\nfunction printArrayItems(path, options, printPath, print) {\n  var printedElements = [];\n  var separatorParts = [];\n  path.each(function (childPath) {\n    printedElements.push(concat(separatorParts));\n    printedElements.push(group(print(childPath)));\n    separatorParts = [\",\", line];\n\n    if (childPath.getValue() && isNextLineEmpty(options.originalText, childPath.getValue(), options)) {\n      separatorParts.push(softline);\n    }\n  }, printPath);\n  return concat(printedElements);\n}\n\nfunction hasDanglingComments(node) {\n  return node.comments && node.comments.some(function (comment) {\n    return !comment.leading && !comment.trailing;\n  });\n}\n\nfunction needsHardlineAfterDanglingComment(node) {\n  if (!node.comments) {\n    return false;\n  }\n\n  var lastDanglingComment = getLast(node.comments.filter(function (comment) {\n    return !comment.leading && !comment.trailing;\n  }));\n  return lastDanglingComment && !handleComments.isBlockComment(lastDanglingComment);\n}\n\nfunction isLiteral(node) {\n  return node.type === \"BooleanLiteral\" || node.type === \"DirectiveLiteral\" || node.type === \"Literal\" || node.type === \"NullLiteral\" || node.type === \"NumericLiteral\" || node.type === \"RegExpLiteral\" || node.type === \"StringLiteral\" || node.type === \"TemplateLiteral\" || node.type === \"TSTypeLiteral\" || node.type === \"JSXText\";\n}\n\nfunction isStringPropSafeToCoerceToIdentifier(node, options) {\n  return isStringLiteral(node.key) && isIdentifierName(node.key.value) && options.parser !== \"json\" && !(options.parser === \"typescript\" && node.type === \"ClassProperty\");\n}\n\nfunction isNumericLiteral(node) {\n  return node.type === \"NumericLiteral\" || node.type === \"Literal\" && typeof node.value === \"number\";\n}\n\nfunction isStringLiteral(node) {\n  return node.type === \"StringLiteral\" || node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\nfunction isObjectType(n) {\n  return n.type === \"ObjectTypeAnnotation\" || n.type === \"TSTypeLiteral\";\n}\n\nvar unitTestRe = /^(skip|[fx]?(it|describe|test))$/; // eg; `describe(\"some string\", (done) => {})`\n\nfunction isTestCall(n, parent) {\n  if (n.type !== \"CallExpression\") {\n    return false;\n  }\n\n  if (n.arguments.length === 1) {\n    if (isAngularTestWrapper(n) && parent && isTestCall(parent)) {\n      return isFunctionOrArrowExpression(n.arguments[0]);\n    }\n\n    if (isUnitTestSetUp(n)) {\n      return isAngularTestWrapper(n.arguments[0]);\n    }\n  } else if (n.arguments.length === 2 || n.arguments.length === 3) {\n    if ((n.callee.type === \"Identifier\" && unitTestRe.test(n.callee.name) || isSkipOrOnlyBlock(n)) && (isTemplateLiteral(n.arguments[0]) || isStringLiteral(n.arguments[0]))) {\n      // it(\"name\", () => { ... }, 2500)\n      if (n.arguments[2] && !isNumericLiteral(n.arguments[2])) {\n        return false;\n      }\n\n      return (n.arguments.length === 2 ? isFunctionOrArrowExpression(n.arguments[1]) : isFunctionOrArrowExpressionWithBody(n.arguments[1]) && n.arguments[1].params.length <= 1) || isAngularTestWrapper(n.arguments[1]);\n    }\n  }\n\n  return false;\n}\n\nfunction isSkipOrOnlyBlock(node) {\n  return (node.callee.type === \"MemberExpression\" || node.callee.type === \"OptionalMemberExpression\") && node.callee.object.type === \"Identifier\" && node.callee.property.type === \"Identifier\" && unitTestRe.test(node.callee.object.name) && (node.callee.property.name === \"only\" || node.callee.property.name === \"skip\");\n}\n\nfunction isTemplateLiteral(node) {\n  return node.type === \"TemplateLiteral\";\n} // `inject` is used in AngularJS 1.x, `async` in Angular 2+\n// example: https://docs.angularjs.org/guide/unit-testing#using-beforeall-\n\n\nfunction isAngularTestWrapper(node) {\n  return (node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\") && node.callee.type === \"Identifier\" && (node.callee.name === \"async\" || node.callee.name === \"inject\" || node.callee.name === \"fakeAsync\");\n}\n\nfunction isFunctionOrArrowExpression(node) {\n  return node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\n}\n\nfunction isFunctionOrArrowExpressionWithBody(node) {\n  return node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\" && node.body.type === \"BlockStatement\";\n}\n\nfunction isUnitTestSetUp(n) {\n  var unitTestSetUpRe = /^(before|after)(Each|All)$/;\n  return n.callee.type === \"Identifier\" && unitTestSetUpRe.test(n.callee.name) && n.arguments.length === 1;\n}\n\nfunction isTheOnlyJSXElementInMarkdown(options, path) {\n  if (options.parentParser !== \"markdown\" && options.parentParser !== \"mdx\") {\n    return false;\n  }\n\n  var node = path.getNode();\n\n  if (!node.expression || !isJSXNode(node.expression)) {\n    return false;\n  }\n\n  var parent = path.getParentNode();\n  return parent.type === \"Program\" && parent.body.length == 1;\n}\n\nfunction willPrintOwnComments(path\n/*, options */\n) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  return (node && (isJSXNode(node) || hasFlowShorthandAnnotationComment(node) || parent && parent.type === \"CallExpression\" && (hasFlowAnnotationComment(node.leadingComments) || hasFlowAnnotationComment(node.trailingComments))) || parent && (parent.type === \"JSXSpreadAttribute\" || parent.type === \"JSXSpreadChild\" || parent.type === \"UnionTypeAnnotation\" || parent.type === \"TSUnionType\" || (parent.type === \"ClassDeclaration\" || parent.type === \"ClassExpression\") && parent.superClass === node)) && !hasIgnoreComment(path);\n}\n\nfunction canAttachComment(node) {\n  return node.type && node.type !== \"CommentBlock\" && node.type !== \"CommentLine\" && node.type !== \"Line\" && node.type !== \"Block\" && node.type !== \"EmptyStatement\" && node.type !== \"TemplateElement\" && node.type !== \"Import\";\n}\n\nfunction printComment(commentPath, options) {\n  var comment = commentPath.getValue();\n\n  switch (comment.type) {\n    case \"CommentBlock\":\n    case \"Block\":\n      {\n        if (isIndentableBlockComment(comment)) {\n          var printed = printIndentableBlockComment(comment); // We need to prevent an edge case of a previous trailing comment\n          // printed as a `lineSuffix` which causes the comments to be\n          // interleaved. See https://github.com/prettier/prettier/issues/4412\n\n          if (comment.trailing && !hasNewline(options.originalText, options.locStart(comment), {\n            backwards: true\n          })) {\n            return concat([hardline, printed]);\n          }\n\n          return printed;\n        }\n\n        var isInsideFlowComment = options.originalText.substr(options.locEnd(comment) - 3, 3) === \"*-/\";\n        return \"/*\" + comment.value + (isInsideFlowComment ? \"*-/\" : \"*/\");\n      }\n\n    case \"CommentLine\":\n    case \"Line\":\n      // Print shebangs with the proper comment characters\n      if (options.originalText.slice(options.locStart(comment)).startsWith(\"#!\")) {\n        return \"#!\" + comment.value.trimRight();\n      }\n\n      return \"//\" + comment.value.trimRight();\n\n    default:\n      throw new Error(\"Not a comment: \" + JSON.stringify(comment));\n  }\n}\n\nfunction isIndentableBlockComment(comment) {\n  // If the comment has multiple lines and every line starts with a star\n  // we can fix the indentation of each line. The stars in the `/*` and\n  // `*/` delimiters are not included in the comment value, so add them\n  // back first.\n  var lines = \"*\".concat(comment.value, \"*\").split(\"\\n\");\n  return lines.length > 1 && lines.every(function (line) {\n    return line.trim()[0] === \"*\";\n  });\n}\n\nfunction printIndentableBlockComment(comment) {\n  var lines = comment.value.split(\"\\n\");\n  return concat([\"/*\", join(hardline, lines.map(function (line, index) {\n    return index === 0 ? line.trimRight() : \" \" + (index < lines.length - 1 ? line.trim() : line.trimLeft());\n  })), \"*/\"]);\n}\n\nfunction rawText(node) {\n  // our artifically created AST doesn't have extra property\n  //return node.extra ? node.extra.raw : node.raw;\n  return node.value;\n}\n\nfunction identity(x) {\n  return x;\n}\n\nmodule.exports = {\n  preprocess: preprocess,\n  print: genericPrint,\n  embed: embed,\n  insertPragma: insertPragma,\n  massageAstNode: clean,\n  hasPrettierIgnore: hasPrettierIgnore,\n  willPrintOwnComments: willPrintOwnComments,\n  canAttachComment: canAttachComment,\n  printComment: printComment,\n  isBlockComment: handleComments.isBlockComment,\n  handleComments: {\n    ownLine: handleComments.handleOwnLineComment,\n    endOfLine: handleComments.handleEndOfLineComment,\n    remaining: handleComments.handleRemainingComment\n  }\n};","map":{"version":3,"sources":["/Users/pranamyavadlamani/Desktop/Research/PortFolio/portfolio-site/node_modules/@miksu/prettier/lib/language-js/printer-estree.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","_typeof","obj","constructor","assert","require","comments","_require","getParentExportDeclaration","isExportDeclaration","shouldFlatten","getNextNonSpaceNonCommentCharacter","hasNewline","hasNewlineInRange","getLast","getStringWidth","printString","printNumber","hasIgnoreComment","skipWhitespace","hasNodeIgnoreComment","getPenultimate","startsWithNoLookaheadToken","getIndentSize","matchAncestorTypes","getPreferredQuote","_require2","isNextLineEmpty","isNextLineEmptyAfterIndex","getNextNonSpaceNonCommentCharacterIndex","isIdentifierName","keyword","isIdentifierNameES5","embed","clean","insertPragma","handleComments","pathNeedsParens","_require3","printHtmlBinding","isVueEventBindingExpression","preprocess","_require4","getLeftSide","getLeftSidePathName","hasNakedLeftSide","hasNode","hasFlowAnnotationComment","hasFlowShorthandAnnotationComment","needsQuoteProps","WeakMap","_require5","_require5$builders","builders","concat","join","line","hardline","softline","literalline","group","indent","align","conditionalGroup","fill","ifBreak","breakParent","lineSuffixBoundary","addAlignmentToDoc","dedent","_require5$utils","utils","willBreak","isLineNext","isEmpty","removeLines","printDocToString","printer","uid","shouldPrintComma","options","level","trailingComma","genericPrint","path","printPath","args","node","getValue","needsParens","linesWithoutParens","printPathNoParens","parentExportDecl","decorators","type","locStart","ignoreDecorators","shouldBreak","hasNewlineBetweenOrAfterDecorators","separator","each","decoratorPath","decorator","expression","callee","push","unshift","declaration","prefix","parts","_node","trailingComments","value","trimLeft","printed","originalText","locEnd","printDecorators","print","map","hasPrettierIgnore","hasJsxIgnoreComment","parent","getParentNode","isJSXNode","index","children","indexOf","prevSibling","candidate","isMeaningfulJSXText","find","comment","trim","printTernaryOperator","operatorOptions","testNode","testNodePropertyName","consequentNode","consequentNodePropertyName","alternateNode","alternateNodePropertyName","jsxMode","forceNoIndent","conditionalNodeType","currentParent","previousParent","firstNonConditionalParent","lastConditionalParent","shouldCheckJsx","conditionalExpressionChainContainsJSX","wrap","doc","isNull","part","useTabs","Math","max","tabWidth","maybeGroup","breakNested","breakClosingParen","computed","testDoc","beforeParts","afterParts","getTypeScriptMappedTypeModifier","tokenNode","n","semi","htmlBinding","program","interpreter","programPath","directives","childPath","bodyPath","printStatementSequence","printDanglingComments","body","directive","nodeStr","parser","isTheOnlyJSXElementInMarkdown","printAssignment","left","operator","right","_parent","parentParent","isInsideParenthesis","_parts","printBinaryishExpressions","shouldNotIndent","shouldIndentIfInlining","samePrecedenceSubExpression","isBinaryish","shouldInlineLogicalExpression","hasJSX","rest","slice","groupId","chain","id","jsxPart","shouldBreakAfterCast","castGroup","exprContents","_parent2","firstNonMemberParent","shouldInline","object","property","printMemberLookup","printBindExpressionCallee","name","printOptionalToken","printTypeAnnotation","printFunctionDeclaration","async","shouldPrintParamsWithoutParens","printFunctionParams","expandLastArg","expandFirstArg","printReturnType","dangling","nextCharacter","substr","hasLeadingOwnLineComment","isTemplateOnItsOwnLine","shouldAddSoftLine","printTrailingComma","shouldAddParens","accessibility","printMethod","delegate","argument","importKind","local","imported","exported","printExportDeclaration","exportKind","standalones","grouped","specifiers","specifierPath","some","bracketSpacing","test","source","naked","hasContent","hasDirectives","_parent3","_parentParent","hasDanglingComments","finalizer","returnArgumentHasLeadingComment","isNew","optional","arguments","isTestCall","printFunctionTypeParameters","isIdentifierWithFlowAnnotation","isMemberish","printMemberChain","substring","printArgumentsList","isNodeStartingWithDeclare","printTypeScriptModifiers","typeParameters","identity","method","propertiesField","isTypeAnnotation","fields","firstProperty","field","sort","a","b","_parent4","isFlowInterfaceLikeBody","getName","properties","leftBrace","exact","rightBrace","propsAndLoc","forEach","loc","separatorParts","props","prop","result","shift","inexact","lastElem","canHaveTrailingSeparator","content","parentParentParent","shouldHugArguments","params","shouldHugType","typeAnnotation","kind","shorthand","printedLeft","printPropertyKey","key","printObjectMethod","elements","_lastElem","canHaveTrailingComma","needsForcedTrailingComma","printArrayItems","_parent5","_parts2","p","printRegex","extra","raw","rawValue","regex","grandParent","isTypeScriptDirective","reverse","parentNode","isParentForLoop","hasValue","declarations","decl","init","firstVariable","declare","_printed","printAssignmentRight","adjustClause","con","consequent","opening","alternate","commentOnOwnLine","hasTrailingComment","trailing","isBlockComment","needsHardlineAfterDanglingComment","elseOnSameLine","_body","_dangling","printedComments","update","isAwait","clause","doBody","label","handler","param","hasComments","leading","backwards","cases","casePath","caseNode","filter","cons","consequentPath","res","isStringLiteral","rawText","_final","replace","quote","jsxSingleQuote","_escape","RegExp","printComments","_parent6","preventInline","_shouldInline","elem","printJSXElement","maybeWrapJSXElementInParens","_n","nameHasComments","selfClosing","attributes","includes","lastAttrHasTrailingComments","bracketSameLine","jsxBracketSameLine","_shouldBreak","attr","hasComment","hasOwnLineComment","every","isOpeningFragment","Error","requiresHardline","readonly","variance","getFlowVariance","printClass","split","expressions","_parentNode","isJestEachTemplateLiteral","_printed2","printJestEachTemplateLiteral","isSimple","isSimpleTemplateLiteral","assign","printWidth","Infinity","formatted","quasi","indentSize","_printed3","aligned","endsWith","JSON","stringify","typesField","printFlowDeclaration","predicate","supertype","impltype","_parent7","_parentParent2","_parentParentParent","isArrowFunctionTypeAnnotation","needsColon","isObjectTypePropertyAFunction","returnType","types","wasIndented","_i","isObjectType","_parent8","shouldIndent","shouldHug","_printed4","typePath","printedType","shouldAddStartLine","code","hasParens","_grandParent","getNode","greatGrandParent","greatGreatGrandParent","_variance","_variance2","modifier","proto","isGetterOrSetter","isFunctionNotation","strictEqual","_printed5","commentSyntax","range","match","_value","commentStart","lastIndexOf","_commentSyntax","printTypeParameters","_parent9","constraint","_variance3","bound","_grandParent2","filepath","initializer","_parent10","parameters","isTypeOf","qualifier","isType","_shouldBreak2","modifiers","members","isExport","_parent11","isExternalModule","isLiteral","parentIsDeclaration","bodyIsDeclaration","textBetweenNodeAndItsId","isGlobalDeclaration","trimRight","hasNgSideEffect","isNgForOf","alias","_parentNode2","shouldNotPrintColon","undefined","bodyNode","isClass","stmtPath","stmt","stmtPrinted","text","stmtNeedsASIProtection","needsSemi","classPropMayCauseASIProblems","nextChild","classChildNeedsASIProtection","isLastStatement","quoteProps","has","objectHasStringProp","isStringPropSafeToCoerceToIdentifier","set","get","keyPath","generator","ok","valuePath","couldGroupArg","arg","shouldGroupLastArg","lastArg","penultimateArg","hasLeadingComment","shouldGroupFirstArg","firstArg","secondArg","isSimpleFlowType","flowTypeAnnotations","jestEachTriggerRegex","tag","headerNames","quasis","headerName","stringifiedExpressions","endOfLine","tableBody","hasLineBreak","cells","row","correspondingExpression","maxColumnCount","reduce","maxColumnWidths","table","cell","repeat","expr","ancestor","functionCompositionFunctionNames","Set","ordinaryMethodNames","isFunctionCompositionFunction","hasEmptyLineInObjectArgInArrowFunction","anyArgEmptyLine","hasEmptyLineFollowingFirstArg","lastArgIndex","printedArguments","argPath","maybeTrailingComma","allArgsBrokenOut","shouldGroupFirst","shouldGroupLast","printedExpanded","somePrintedArgumentsWillBreak","simpleConcat","isDefinite","definite","isFunctionDeclarationIdentifier","isFlowAnnotationComment","fun","typeArguments","expandArg","printTypeParams","paramsField","isParametersInTestCall","shouldHugParameters","shouldExpandParameters","typeParams","lastParam","hasNotParameterDecorator","isFlowShorthandWithOneArg","isTypeAnnotationAFunction","arrowParens","canPrintParamsWithoutParens","objMethod","isDefault","defaultSpecifiers","namespaceSpecifiers","specifierType","isNamespaceFollowed","isDefaultFollowed","canBreak","paramsKey","grandparent","isParameterInTestCall","typeName","partsGroup","superClass","isNumericLiteral","printedNodes","shouldInsertEmptyLineAfter","nextCharIndex","nextChar","charAt","rec","groups","currentGroup","hasSeenCallExpression","isFactory","isShort","shouldNotWrap","isExpression","hasComputed","firstNode","lastNode","shouldMerge","printGroup","printedGroup","tuple","printIndentedGroup","printedGroups","oneLine","cutoff","flatGroups","lastNodeBeforeIndent","shouldHaveEmptyLineBeforeIndent","expanded","callExpressions","_ref","isCallOrOptionalCallExpression","lastGroupDoc","lastGroupNode","isFunctionOrArrowExpression","isEmptyJSXElement","child","jsxWhitespaceChars","containsNonJsxWhitespaceRegex","matchJsxWhitespaceRegex","Boolean","getConditionalChainContents","nonConditionalExpressions","recurse","isJSXWhitespaceExpression","separatorNoWhitespace","isFacebookTranslationTag","childNode","nextNode","closingElement","separatorWithWhitespace","printJSXChildren","jsxWhitespace","words","next","endWhitespace","pop","word","_next","_next2","printedChild","_next3","directlyFollowedByMeaningfulText","firstWord","openingLines","closingLines","containsTag","containsMultipleExpressions","containsMultipleAttributes","openingElement","forcedBreak","rawJsxWhitespace","singleQuote","containsText","isPairOfEmptyStrings","isPairOfHardlines","isLineFollowedByJSXWhitespace","isJSXWhitespaceFollowedByLine","isDoubleJSXWhitespace","isPairOfHardOrSoftLines","splice","multilineChildren","multiLineElem","NO_WRAP_PARENTS","ArrayExpression","JSXAttribute","JSXElement","JSXExpressionContainer","JSXFragment","ExpressionStatement","CallExpression","OptionalCallExpression","ConditionalExpression","JsExpressionRoot","isNested","lineBeforeOperator","rightSuffix","shouldGroup","leftNode","rightNode","printedRight","isMemberExpressionChain","forceSpace","isFlowOrTypeScriptDirectiveLiteral","isDirectiveLiteral","flags","pattern","start","end","exprNeedsASIProtection","maybeASIProblem","apply","isAsync","isGenerator","leftMost","newLeftMost","sameLocStart","nodeA","nodeB","startsWith","voidCount","objectCount","templateLiteralHasNewLines","template","printedElements","lastDanglingComment","unitTestRe","isAngularTestWrapper","isUnitTestSetUp","isSkipOrOnlyBlock","isTemplateLiteral","isFunctionOrArrowExpressionWithBody","unitTestSetUpRe","parentParser","willPrintOwnComments","leadingComments","canAttachComment","printComment","commentPath","isIndentableBlockComment","printIndentableBlockComment","isInsideFlowComment","lines","x","module","exports","massageAstNode","ownLine","handleOwnLineComment","handleEndOfLineComment","remaining","handleRemainingComment"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar assert = require(\"assert\"); // TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.\n\n\nvar comments = require(\"../main/comments\");\n\nvar _require = require(\"../common/util\"),\n    getParentExportDeclaration = _require.getParentExportDeclaration,\n    isExportDeclaration = _require.isExportDeclaration,\n    shouldFlatten = _require.shouldFlatten,\n    getNextNonSpaceNonCommentCharacter = _require.getNextNonSpaceNonCommentCharacter,\n    hasNewline = _require.hasNewline,\n    hasNewlineInRange = _require.hasNewlineInRange,\n    getLast = _require.getLast,\n    getStringWidth = _require.getStringWidth,\n    printString = _require.printString,\n    printNumber = _require.printNumber,\n    hasIgnoreComment = _require.hasIgnoreComment,\n    skipWhitespace = _require.skipWhitespace,\n    hasNodeIgnoreComment = _require.hasNodeIgnoreComment,\n    getPenultimate = _require.getPenultimate,\n    startsWithNoLookaheadToken = _require.startsWithNoLookaheadToken,\n    getIndentSize = _require.getIndentSize,\n    matchAncestorTypes = _require.matchAncestorTypes,\n    getPreferredQuote = _require.getPreferredQuote;\n\nvar _require2 = require(\"../common/util-shared\"),\n    isNextLineEmpty = _require2.isNextLineEmpty,\n    isNextLineEmptyAfterIndex = _require2.isNextLineEmptyAfterIndex,\n    getNextNonSpaceNonCommentCharacterIndex = _require2.getNextNonSpaceNonCommentCharacterIndex;\n\nvar isIdentifierName = require(\"esutils\").keyword.isIdentifierNameES5;\n\nvar embed = require(\"./embed\");\n\nvar clean = require(\"./clean\");\n\nvar insertPragma = require(\"./pragma\").insertPragma;\n\nvar handleComments = require(\"./comments\");\n\nvar pathNeedsParens = require(\"./needs-parens\");\n\nvar _require3 = require(\"./html-binding\"),\n    printHtmlBinding = _require3.printHtmlBinding,\n    isVueEventBindingExpression = _require3.isVueEventBindingExpression;\n\nvar preprocess = require(\"./preprocess\");\n\nvar _require4 = require(\"./utils\"),\n    getLeftSide = _require4.getLeftSide,\n    getLeftSidePathName = _require4.getLeftSidePathName,\n    hasNakedLeftSide = _require4.hasNakedLeftSide,\n    hasNode = _require4.hasNode,\n    hasFlowAnnotationComment = _require4.hasFlowAnnotationComment,\n    hasFlowShorthandAnnotationComment = _require4.hasFlowShorthandAnnotationComment;\n\nvar needsQuoteProps = new WeakMap();\n\nvar _require5 = require(\"../doc\"),\n    _require5$builders = _require5.builders,\n    concat = _require5$builders.concat,\n    join = _require5$builders.join,\n    line = _require5$builders.line,\n    hardline = _require5$builders.hardline,\n    softline = _require5$builders.softline,\n    literalline = _require5$builders.literalline,\n    group = _require5$builders.group,\n    indent = _require5$builders.indent,\n    align = _require5$builders.align,\n    conditionalGroup = _require5$builders.conditionalGroup,\n    fill = _require5$builders.fill,\n    ifBreak = _require5$builders.ifBreak,\n    breakParent = _require5$builders.breakParent,\n    lineSuffixBoundary = _require5$builders.lineSuffixBoundary,\n    addAlignmentToDoc = _require5$builders.addAlignmentToDoc,\n    dedent = _require5$builders.dedent,\n    _require5$utils = _require5.utils,\n    willBreak = _require5$utils.willBreak,\n    isLineNext = _require5$utils.isLineNext,\n    isEmpty = _require5$utils.isEmpty,\n    removeLines = _require5$utils.removeLines,\n    printDocToString = _require5.printer.printDocToString;\n\nvar uid = 0;\n\nfunction shouldPrintComma(options, level) {\n  level = level || \"es5\";\n\n  switch (options.trailingComma) {\n    case \"all\":\n      if (level === \"all\") {\n        return true;\n      }\n\n    // fallthrough\n\n    case \"es5\":\n      if (level === \"es5\") {\n        return true;\n      }\n\n    // fallthrough\n\n    case \"none\":\n    default:\n      return false;\n  }\n}\n\nfunction genericPrint(path, options, printPath, args) {\n  var node = path.getValue();\n  var needsParens = false;\n  var linesWithoutParens = printPathNoParens(path, options, printPath, args);\n\n  if (!node || isEmpty(linesWithoutParens)) {\n    return linesWithoutParens;\n  }\n\n  var parentExportDecl = getParentExportDeclaration(path);\n  var decorators = [];\n\n  if (node.type === \"ClassMethod\" || node.type === \"ClassPrivateMethod\" || node.type === \"ClassProperty\" || node.type === \"TSAbstractClassProperty\" || node.type === \"ClassPrivateProperty\" || node.type === \"MethodDefinition\" || node.type === \"TSAbstractMethodDefinition\") {// their decorators are handled themselves\n  } else if (node.decorators && node.decorators.length > 0 && // If the parent node is an export declaration and the decorator\n  // was written before the export, the export will be responsible\n  // for printing the decorators.\n  !(parentExportDecl && options.locStart(parentExportDecl, {\n    ignoreDecorators: true\n  }) > options.locStart(node.decorators[0]))) {\n    var shouldBreak = node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\" || hasNewlineBetweenOrAfterDecorators(node, options);\n    var separator = shouldBreak ? hardline : line;\n    path.each(function (decoratorPath) {\n      var decorator = decoratorPath.getValue();\n\n      if (decorator.expression) {\n        decorator = decorator.expression;\n      } else {\n        decorator = decorator.callee;\n      }\n\n      decorators.push(printPath(decoratorPath), separator);\n    }, \"decorators\");\n\n    if (parentExportDecl) {\n      decorators.unshift(hardline);\n    }\n  } else if (isExportDeclaration(node) && node.declaration && node.declaration.decorators && node.declaration.decorators.length > 0 && // Only print decorators here if they were written before the export,\n  // otherwise they are printed by the node.declaration\n  options.locStart(node, {\n    ignoreDecorators: true\n  }) > options.locStart(node.declaration.decorators[0])) {\n    // Export declarations are responsible for printing any decorators\n    // that logically apply to node.declaration.\n    path.each(function (decoratorPath) {\n      var decorator = decoratorPath.getValue();\n      var prefix = decorator.type === \"Decorator\" ? \"\" : \"@\";\n      decorators.push(prefix, printPath(decoratorPath), hardline);\n    }, \"declaration\", \"decorators\");\n  } else {\n    // Nodes with decorators can't have parentheses, so we can avoid\n    // computing pathNeedsParens() except in this case.\n    needsParens = pathNeedsParens(path, options);\n  }\n\n  var parts = [];\n\n  if (needsParens) {\n    parts.unshift(\"(\");\n  }\n\n  parts.push(linesWithoutParens);\n\n  if (needsParens) {\n    var _node = path.getValue();\n\n    if (hasFlowShorthandAnnotationComment(_node)) {\n      parts.push(\" /*\");\n      parts.push(_node.trailingComments[0].value.trimLeft());\n      parts.push(\"*/\");\n      _node.trailingComments[0].printed = true;\n    }\n\n    parts.push(\")\");\n  }\n\n  if (decorators.length > 0) {\n    return group(concat(decorators.concat(parts)));\n  }\n\n  return concat(parts);\n}\n\nfunction hasNewlineBetweenOrAfterDecorators(node, options) {\n  return hasNewlineInRange(options.originalText, options.locStart(node.decorators[0]), options.locEnd(getLast(node.decorators))) || hasNewline(options.originalText, options.locEnd(getLast(node.decorators)));\n}\n\nfunction printDecorators(path, options, print) {\n  var node = path.getValue();\n  return group(concat([join(line, path.map(print, \"decorators\")), hasNewlineBetweenOrAfterDecorators(node, options) ? hardline : line]));\n}\n\nfunction hasPrettierIgnore(path) {\n  return hasIgnoreComment(path) || hasJsxIgnoreComment(path);\n}\n\nfunction hasJsxIgnoreComment(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n\n  if (!parent || !node || !isJSXNode(node) || !isJSXNode(parent)) {\n    return false;\n  } // Lookup the previous sibling, ignoring any empty JSXText elements\n\n\n  var index = parent.children.indexOf(node);\n  var prevSibling = null;\n\n  for (var i = index; i > 0; i--) {\n    var candidate = parent.children[i - 1];\n\n    if (candidate.type === \"JSXText\" && !isMeaningfulJSXText(candidate)) {\n      continue;\n    }\n\n    prevSibling = candidate;\n    break;\n  }\n\n  return prevSibling && prevSibling.type === \"JSXExpressionContainer\" && prevSibling.expression.type === \"JSXEmptyExpression\" && prevSibling.expression.comments && prevSibling.expression.comments.find(function (comment) {\n    return comment.value.trim() === \"prettier-ignore\";\n  });\n}\n/**\n * The following is the shared logic for\n * ternary operators, namely ConditionalExpression\n * and TSConditionalType\n * @typedef {Object} OperatorOptions\n * @property {() => Array<string | Doc>} beforeParts - Parts to print before the `?`.\n * @property {(breakClosingParen: boolean) => Array<string | Doc>} afterParts - Parts to print after the conditional expression.\n * @property {boolean} shouldCheckJsx - Whether to check for and print in JSX mode.\n * @property {string} conditionalNodeType - The type of the conditional expression node, ie \"ConditionalExpression\" or \"TSConditionalType\".\n * @property {string} consequentNodePropertyName - The property at which the consequent node can be found on the main node, eg \"consequent\".\n * @property {string} alternateNodePropertyName - The property at which the alternate node can be found on the main node, eg \"alternate\".\n * @property {string} testNodePropertyName - The property at which the test node can be found on the main node, eg \"test\".\n * @property {boolean} breakNested - Whether to break all nested ternaries when one breaks.\n * @param {FastPath} path - The path to the ConditionalExpression/TSConditionalType node.\n * @param {Options} options - Prettier options\n * @param {Function} print - Print function to call recursively\n * @param {OperatorOptions} operatorOptions\n * @returns Doc\n */\n\n\nfunction printTernaryOperator(path, options, print, operatorOptions) {\n  var node = path.getValue();\n  var testNode = node[operatorOptions.testNodePropertyName];\n  var consequentNode = node[operatorOptions.consequentNodePropertyName];\n  var alternateNode = node[operatorOptions.alternateNodePropertyName];\n  var parts = []; // We print a ConditionalExpression in either \"JSX mode\" or \"normal mode\".\n  // See tests/jsx/conditional-expression.js for more info.\n\n  var jsxMode = false;\n  var parent = path.getParentNode();\n  var forceNoIndent = parent.type === operatorOptions.conditionalNodeType; // Find the outermost non-ConditionalExpression parent, and the outermost\n  // ConditionalExpression parent. We'll use these to determine if we should\n  // print in JSX mode.\n\n  var currentParent;\n  var previousParent;\n  var i = 0;\n\n  do {\n    previousParent = currentParent || node;\n    currentParent = path.getParentNode(i);\n    i++;\n  } while (currentParent && currentParent.type === operatorOptions.conditionalNodeType);\n\n  var firstNonConditionalParent = currentParent || parent;\n  var lastConditionalParent = previousParent;\n\n  if (operatorOptions.shouldCheckJsx && (isJSXNode(testNode) || isJSXNode(consequentNode) || isJSXNode(alternateNode) || conditionalExpressionChainContainsJSX(lastConditionalParent))) {\n    jsxMode = true;\n    forceNoIndent = true; // Even though they don't need parens, we wrap (almost) everything in\n    // parens when using ?: within JSX, because the parens are analogous to\n    // curly braces in an if statement.\n\n    var wrap = function wrap(doc) {\n      return concat([ifBreak(\"(\", \"\"), indent(concat([softline, doc])), softline, ifBreak(\")\", \"\")]);\n    }; // The only things we don't wrap are:\n    // * Nested conditional expressions in alternates\n    // * null\n\n\n    var isNull = function isNull(node) {\n      return node.type === \"NullLiteral\" || node.type === \"Literal\" && node.value === null;\n    };\n\n    parts.push(\" ? \", isNull(consequentNode) ? path.call(print, operatorOptions.consequentNodePropertyName) : wrap(path.call(print, operatorOptions.consequentNodePropertyName)), \" : \", alternateNode.type === operatorOptions.conditionalNodeType || isNull(alternateNode) ? path.call(print, operatorOptions.alternateNodePropertyName) : wrap(path.call(print, operatorOptions.alternateNodePropertyName)));\n  } else {\n    // normal mode\n    var part = concat([line, \"? \", consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak(\"\", \"(\") : \"\", align(2, path.call(print, operatorOptions.consequentNodePropertyName)), consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak(\"\", \")\") : \"\", line, \": \", alternateNode.type === operatorOptions.conditionalNodeType ? path.call(print, operatorOptions.alternateNodePropertyName) : align(2, path.call(print, operatorOptions.alternateNodePropertyName))]);\n    parts.push(parent.type !== operatorOptions.conditionalNodeType || parent[operatorOptions.alternateNodePropertyName] === node ? part : options.useTabs ? dedent(indent(part)) : align(Math.max(0, options.tabWidth - 2), part));\n  } // We want a whole chain of ConditionalExpressions to all\n  // break if any of them break. That means we should only group around the\n  // outer-most ConditionalExpression.\n\n\n  var maybeGroup = function maybeGroup(doc) {\n    return operatorOptions.breakNested ? parent === firstNonConditionalParent ? group(doc) : doc : group(doc);\n  }; // Break the closing paren to keep the chain right after it:\n  // (a\n  //   ? b\n  //   : c\n  // ).call()\n\n\n  var breakClosingParen = !jsxMode && (parent.type === \"MemberExpression\" || parent.type === \"OptionalMemberExpression\") && !parent.computed;\n  return maybeGroup(concat([].concat(function (testDoc) {\n    return (\n      /**\n       *     a\n       *       ? b\n       *       : multiline\n       *         test\n       *         node\n       *       ^^ align(2)\n       *       ? d\n       *       : e\n       */\n      parent.type === operatorOptions.conditionalNodeType && parent[operatorOptions.alternateNodePropertyName] === node ? align(2, testDoc) : testDoc\n    );\n  }(concat(operatorOptions.beforeParts())), forceNoIndent ? concat(parts) : indent(concat(parts)), operatorOptions.afterParts(breakClosingParen))));\n}\n\nfunction getTypeScriptMappedTypeModifier(tokenNode, keyword) {\n  if (tokenNode === \"+\") {\n    return \"+\" + keyword;\n  } else if (tokenNode === \"-\") {\n    return \"-\" + keyword;\n  }\n\n  return keyword;\n}\n\nfunction printPathNoParens(path, options, print, args) {\n  var n = path.getValue();\n  var semi = options.semi ? \";\" : \"\";\n\n  if (!n) {\n    return \"\";\n  }\n\n  if (typeof n === \"string\") {\n    return n;\n  }\n\n  var htmlBinding = printHtmlBinding(path, options, print);\n\n  if (htmlBinding) {\n    return htmlBinding;\n  }\n\n  var parts = [];\n\n  switch (n.type) {\n    case \"JsExpressionRoot\":\n      return path.call(print, \"node\");\n\n    case \"JsonRoot\":\n      return concat([path.call(print, \"node\"), hardline]);\n\n    case \"File\":\n      // Print @babel/parser's InterpreterDirective here so that\n      // leading comments on the `Program` node get printed after the hashbang.\n      if (n.program && n.program.interpreter) {\n        parts.push(path.call(function (programPath) {\n          return programPath.call(print, \"interpreter\");\n        }, \"program\"));\n      }\n\n      parts.push(path.call(print, \"program\"));\n      return concat(parts);\n\n    case \"Program\":\n      // Babel 6\n      if (n.directives) {\n        path.each(function (childPath) {\n          parts.push(print(childPath), semi, hardline);\n\n          if (isNextLineEmpty(options.originalText, childPath.getValue(), options)) {\n            parts.push(hardline);\n          }\n        }, \"directives\");\n      }\n\n      parts.push(path.call(function (bodyPath) {\n        return printStatementSequence(bodyPath, options, print);\n      }, \"body\"));\n      parts.push(comments.printDanglingComments(path, options,\n      /* sameIndent */\n      true)); // Only force a trailing newline if there were any contents.\n\n      if (n.body.length || n.comments) {\n        parts.push(hardline);\n      }\n\n      return concat(parts);\n    // Babel extension.\n\n    case \"EmptyStatement\":\n      return \"\";\n\n    case \"ExpressionStatement\":\n      // Detect Flow-parsed directives\n      if (n.directive) {\n        return concat([nodeStr(n.expression, options, true), semi]);\n      }\n\n      if (options.parser === \"__vue_event_binding\") {\n        var parent = path.getParentNode();\n\n        if (parent.type === \"Program\" && parent.body.length === 1 && parent.body[0] === n) {\n          return concat([path.call(print, \"expression\"), isVueEventBindingExpression(n.expression) ? \";\" : \"\"]);\n        }\n      } // Do not append semicolon after the only JSX element in a program\n\n\n      return concat([path.call(print, \"expression\"), isTheOnlyJSXElementInMarkdown(options, path) ? \"\" : semi]);\n    // Babel extension.\n\n    case \"ParenthesizedExpression\":\n      return concat([\"(\", path.call(print, \"expression\"), \")\"]);\n\n    case \"AssignmentExpression\":\n      return printAssignment(n.left, path.call(print, \"left\"), concat([\" \", n.operator]), n.right, path.call(print, \"right\"), options);\n\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n    case \"NGPipeExpression\":\n      {\n        var _parent = path.getParentNode();\n\n        var parentParent = path.getParentNode(1);\n        var isInsideParenthesis = n !== _parent.body && (_parent.type === \"IfStatement\" || _parent.type === \"WhileStatement\" || _parent.type === \"DoWhileStatement\");\n\n        var _parts = printBinaryishExpressions(path, print, options,\n        /* isNested */\n        false, isInsideParenthesis); //   if (\n        //     this.hasPlugin(\"dynamicImports\") && this.lookahead().type === tt.parenLeft\n        //   ) {\n        //\n        // looks super weird, we want to break the children if the parent breaks\n        //\n        //   if (\n        //     this.hasPlugin(\"dynamicImports\") &&\n        //     this.lookahead().type === tt.parenLeft\n        //   ) {\n\n\n        if (isInsideParenthesis) {\n          return concat(_parts);\n        } // Break between the parens in\n        // unaries or in a member or specific call expression, i.e.\n        //\n        //   (\n        //     a &&\n        //     b &&\n        //     c\n        //   ).call()\n\n\n        if (_parent.type === \"CallExpression\" && _parent.callee === n || _parent.type === \"UnaryExpression\" || (_parent.type === \"MemberExpression\" || _parent.type === \"OptionalMemberExpression\") && !_parent.computed) {\n          return group(concat([indent(concat([softline, concat(_parts)])), softline]));\n        } // Avoid indenting sub-expressions in some cases where the first sub-expression is already\n        // indented accordingly. We should indent sub-expressions where the first case isn't indented.\n\n\n        var shouldNotIndent = _parent.type === \"ReturnStatement\" || _parent.type === \"JSXExpressionContainer\" && parentParent.type === \"JSXAttribute\" || n.type !== \"NGPipeExpression\" && (_parent.type === \"NGRoot\" && options.parser === \"__ng_binding\" || _parent.type === \"NGMicrosyntaxExpression\" && parentParent.type === \"NGMicrosyntax\" && parentParent.body.length === 1) || n === _parent.body && _parent.type === \"ArrowFunctionExpression\" || n !== _parent.body && _parent.type === \"ForStatement\" || _parent.type === \"ConditionalExpression\" && parentParent.type !== \"ReturnStatement\" && parentParent.type !== \"CallExpression\";\n        var shouldIndentIfInlining = _parent.type === \"AssignmentExpression\" || _parent.type === \"VariableDeclarator\" || _parent.type === \"ClassProperty\" || _parent.type === \"TSAbstractClassProperty\" || _parent.type === \"ClassPrivateProperty\" || _parent.type === \"ObjectProperty\" || _parent.type === \"Property\";\n        var samePrecedenceSubExpression = isBinaryish(n.left) && shouldFlatten(n.operator, n.left.operator);\n\n        if (shouldNotIndent || shouldInlineLogicalExpression(n) && !samePrecedenceSubExpression || !shouldInlineLogicalExpression(n) && shouldIndentIfInlining) {\n          return group(concat(_parts));\n        }\n\n        if (_parts.length === 0) {\n          return \"\";\n        } // If the right part is a JSX node, we include it in a separate group to\n        // prevent it breaking the whole chain, so we can print the expression like:\n        //\n        //   foo && bar && (\n        //     <Foo>\n        //       <Bar />\n        //     </Foo>\n        //   )\n\n\n        var hasJSX = isJSXNode(n.right);\n        var rest = concat(hasJSX ? _parts.slice(1, -1) : _parts.slice(1));\n        var groupId = Symbol(\"logicalChain-\" + ++uid);\n        var chain = group(concat([// Don't include the initial expression in the indentation\n        // level. The first item is guaranteed to be the first\n        // left-most expression.\n        _parts.length > 0 ? _parts[0] : \"\", indent(rest)]), {\n          id: groupId\n        });\n\n        if (!hasJSX) {\n          return chain;\n        }\n\n        var jsxPart = getLast(_parts);\n        return group(concat([chain, ifBreak(indent(jsxPart), jsxPart, {\n          groupId: groupId\n        })]));\n      }\n\n    case \"AssignmentPattern\":\n      return concat([path.call(print, \"left\"), \" = \", path.call(print, \"right\")]);\n\n    case \"TSTypeAssertion\":\n      {\n        var shouldBreakAfterCast = !(n.expression.type === \"ArrayExpression\" || n.expression.type === \"ObjectExpression\");\n        var castGroup = group(concat([\"<\", indent(concat([softline, path.call(print, \"typeAnnotation\")])), softline, \">\"]));\n        var exprContents = concat([ifBreak(\"(\"), indent(concat([softline, path.call(print, \"expression\")])), softline, ifBreak(\")\")]);\n\n        if (shouldBreakAfterCast) {\n          return conditionalGroup([concat([castGroup, path.call(print, \"expression\")]), concat([castGroup, group(exprContents, {\n            shouldBreak: true\n          })]), concat([castGroup, path.call(print, \"expression\")])]);\n        }\n\n        return group(concat([castGroup, path.call(print, \"expression\")]));\n      }\n\n    case \"OptionalMemberExpression\":\n    case \"MemberExpression\":\n      {\n        var _parent2 = path.getParentNode();\n\n        var firstNonMemberParent;\n        var i = 0;\n\n        do {\n          firstNonMemberParent = path.getParentNode(i);\n          i++;\n        } while (firstNonMemberParent && (firstNonMemberParent.type === \"MemberExpression\" || firstNonMemberParent.type === \"OptionalMemberExpression\" || firstNonMemberParent.type === \"TSNonNullExpression\"));\n\n        var shouldInline = firstNonMemberParent && (firstNonMemberParent.type === \"NewExpression\" || firstNonMemberParent.type === \"BindExpression\" || firstNonMemberParent.type === \"VariableDeclarator\" && firstNonMemberParent.id.type !== \"Identifier\" || firstNonMemberParent.type === \"AssignmentExpression\" && firstNonMemberParent.left.type !== \"Identifier\") || n.computed || n.object.type === \"Identifier\" && n.property.type === \"Identifier\" && _parent2.type !== \"MemberExpression\" && _parent2.type !== \"OptionalMemberExpression\";\n        return concat([path.call(print, \"object\"), shouldInline ? printMemberLookup(path, options, print) : group(indent(concat([softline, printMemberLookup(path, options, print)])))]);\n      }\n\n    case \"MetaProperty\":\n      return concat([path.call(print, \"meta\"), \".\", path.call(print, \"property\")]);\n\n    case \"BindExpression\":\n      if (n.object) {\n        parts.push(path.call(print, \"object\"));\n      }\n\n      parts.push(group(indent(concat([softline, printBindExpressionCallee(path, options, print)]))));\n      return concat(parts);\n\n    case \"Identifier\":\n      {\n        return concat([n.name, printOptionalToken(path), printTypeAnnotation(path, options, print)]);\n      }\n\n    case \"SpreadElement\":\n    case \"SpreadElementPattern\":\n    case \"RestProperty\":\n    case \"SpreadProperty\":\n    case \"SpreadPropertyPattern\":\n    case \"RestElement\":\n    case \"ObjectTypeSpreadProperty\":\n      return concat([\"...\", path.call(print, \"argument\"), printTypeAnnotation(path, options, print)]);\n\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n      parts.push(printFunctionDeclaration(path, print, options));\n\n      if (!n.body) {\n        parts.push(semi);\n      }\n\n      return concat(parts);\n\n    case \"ArrowFunctionExpression\":\n      {\n        if (n.async) {\n          parts.push(\"async \");\n        }\n\n        if (shouldPrintParamsWithoutParens(path, options)) {\n          parts.push(path.call(print, \"params\", 0));\n        } else {\n          parts.push(group(concat([printFunctionParams(path, print, options,\n          /* expandLast */\n          args && (args.expandLastArg || args.expandFirstArg),\n          /* printTypeParams */\n          true), printReturnType(path, print, options)])));\n        }\n\n        var dangling = comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true, function (comment) {\n          var nextCharacter = getNextNonSpaceNonCommentCharacterIndex(options.originalText, comment, options);\n          return options.originalText.substr(nextCharacter, 2) === \"=>\";\n        });\n\n        if (dangling) {\n          parts.push(\" \", dangling);\n        }\n\n        parts.push(\" =>\");\n        var body = path.call(function (bodyPath) {\n          return print(bodyPath, args);\n        }, \"body\"); // We want to always keep these types of nodes on the same line\n        // as the arrow.\n\n        if (!hasLeadingOwnLineComment(options.originalText, n.body, options) && (n.body.type === \"ArrayExpression\" || n.body.type === \"ObjectExpression\" || n.body.type === \"BlockStatement\" || isJSXNode(n.body) || isTemplateOnItsOwnLine(n.body, options.originalText, options) || n.body.type === \"ArrowFunctionExpression\" || n.body.type === \"DoExpression\")) {\n          return group(concat([concat(parts), \" \", body]));\n        } // We handle sequence expressions as the body of arrows specially,\n        // so that the required parentheses end up on their own lines.\n\n\n        if (n.body.type === \"SequenceExpression\") {\n          return group(concat([concat(parts), group(concat([\" (\", indent(concat([softline, body])), softline, \")\"]))]));\n        } // if the arrow function is expanded as last argument, we are adding a\n        // level of indentation and need to add a softline to align the closing )\n        // with the opening (, or if it's inside a JSXExpression (e.g. an attribute)\n        // we should align the expression's closing } with the line with the opening {.\n\n\n        var shouldAddSoftLine = (args && args.expandLastArg || path.getParentNode().type === \"JSXExpressionContainer\") && !(n.comments && n.comments.length);\n        var printTrailingComma = args && args.expandLastArg && shouldPrintComma(options, \"all\"); // In order to avoid confusion between\n        // a => a ? a : a\n        // a <= a ? a : a\n\n        var shouldAddParens = n.body.type === \"ConditionalExpression\" && !startsWithNoLookaheadToken(n.body,\n        /* forbidFunctionAndClass */\n        false);\n        return group(concat([concat(parts), group(concat([indent(concat([line, shouldAddParens ? ifBreak(\"\", \"(\") : \"\", body, shouldAddParens ? ifBreak(\"\", \")\") : \"\"])), shouldAddSoftLine ? concat([ifBreak(printTrailingComma ? \",\" : \"\"), softline]) : \"\"]))]));\n      }\n\n    case \"MethodDefinition\":\n    case \"TSAbstractMethodDefinition\":\n      if (n.decorators && n.decorators.length !== 0) {\n        parts.push(printDecorators(path, options, print));\n      }\n\n      if (n.accessibility) {\n        parts.push(n.accessibility + \" \");\n      }\n\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      if (n.type === \"TSAbstractMethodDefinition\") {\n        parts.push(\"abstract \");\n      }\n\n      parts.push(printMethod(path, options, print));\n      return concat(parts);\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n\n      if (n.delegate) {\n        parts.push(\"*\");\n      }\n\n      if (n.argument) {\n        parts.push(\" \", path.call(print, \"argument\"));\n      }\n\n      return concat(parts);\n\n    case \"AwaitExpression\":\n      return concat([\"await \", path.call(print, \"argument\")]);\n\n    case \"ImportSpecifier\":\n      if (n.importKind) {\n        parts.push(path.call(print, \"importKind\"), \" \");\n      }\n\n      parts.push(path.call(print, \"imported\"));\n\n      if (n.local && n.local.name !== n.imported.name) {\n        parts.push(\" as \", path.call(print, \"local\"));\n      }\n\n      return concat(parts);\n\n    case \"ExportSpecifier\":\n      parts.push(path.call(print, \"local\"));\n\n      if (n.exported && n.exported.name !== n.local.name) {\n        parts.push(\" as \", path.call(print, \"exported\"));\n      }\n\n      return concat(parts);\n\n    case \"ImportNamespaceSpecifier\":\n      parts.push(\"* as \");\n      parts.push(path.call(print, \"local\"));\n      return concat(parts);\n\n    case \"ImportDefaultSpecifier\":\n      return path.call(print, \"local\");\n\n    case \"TSExportAssignment\":\n      return concat([\"export = \", path.call(print, \"expression\"), semi]);\n\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n      return printExportDeclaration(path, options, print);\n\n    case \"ExportAllDeclaration\":\n      parts.push(\"export \");\n\n      if (n.exportKind === \"type\") {\n        parts.push(\"type \");\n      }\n\n      parts.push(\"* from \", path.call(print, \"source\"), semi);\n      return concat(parts);\n\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      return path.call(print, \"exported\");\n\n    case \"ImportDeclaration\":\n      {\n        parts.push(\"import \");\n\n        if (n.importKind && n.importKind !== \"value\") {\n          parts.push(n.importKind + \" \");\n        }\n\n        var standalones = [];\n        var grouped = [];\n\n        if (n.specifiers && n.specifiers.length > 0) {\n          path.each(function (specifierPath) {\n            var value = specifierPath.getValue();\n\n            if (value.type === \"ImportDefaultSpecifier\" || value.type === \"ImportNamespaceSpecifier\") {\n              standalones.push(print(specifierPath));\n            } else {\n              grouped.push(print(specifierPath));\n            }\n          }, \"specifiers\");\n\n          if (standalones.length > 0) {\n            parts.push(join(\", \", standalones));\n          }\n\n          if (standalones.length > 0 && grouped.length > 0) {\n            parts.push(\", \");\n          }\n\n          if (grouped.length === 1 && standalones.length === 0 && n.specifiers && !n.specifiers.some(function (node) {\n            return node.comments;\n          })) {\n            parts.push(concat([\"{\", options.bracketSpacing ? \" \" : \"\", concat(grouped), options.bracketSpacing ? \" \" : \"\", \"}\"]));\n          } else if (grouped.length >= 1) {\n            parts.push(group(concat([\"{\", indent(concat([options.bracketSpacing ? line : softline, join(concat([\",\", line]), grouped)])), ifBreak(shouldPrintComma(options) ? \",\" : \"\"), options.bracketSpacing ? line : softline, \"}\"])));\n          }\n\n          parts.push(\" from \");\n        } else if (n.importKind && n.importKind === \"type\" || // import {} from 'x'\n        /{\\s*}/.test(options.originalText.slice(options.locStart(n), options.locStart(n.source)))) {\n          parts.push(\"{} from \");\n        }\n\n        parts.push(path.call(print, \"source\"), semi);\n        return concat(parts);\n      }\n\n    case \"Import\":\n      return \"import\";\n\n    case \"TSModuleBlock\":\n    case \"BlockStatement\":\n      {\n        var naked = path.call(function (bodyPath) {\n          return printStatementSequence(bodyPath, options, print);\n        }, \"body\");\n        var hasContent = n.body.find(function (node) {\n          return node.type !== \"EmptyStatement\";\n        });\n        var hasDirectives = n.directives && n.directives.length > 0;\n\n        var _parent3 = path.getParentNode();\n\n        var _parentParent = path.getParentNode(1);\n\n        if (!hasContent && !hasDirectives && !hasDanglingComments(n) && (_parent3.type === \"ArrowFunctionExpression\" || _parent3.type === \"FunctionExpression\" || _parent3.type === \"FunctionDeclaration\" || _parent3.type === \"ObjectMethod\" || _parent3.type === \"ClassMethod\" || _parent3.type === \"ClassPrivateMethod\" || _parent3.type === \"ForStatement\" || _parent3.type === \"WhileStatement\" || _parent3.type === \"DoWhileStatement\" || _parent3.type === \"DoExpression\" || _parent3.type === \"CatchClause\" && !_parentParent.finalizer || _parent3.type === \"TSModuleDeclaration\")) {\n          return \"{}\";\n        }\n\n        parts.push(\"{\"); // Babel 6\n\n        if (hasDirectives) {\n          path.each(function (childPath) {\n            parts.push(indent(concat([hardline, print(childPath), semi])));\n\n            if (isNextLineEmpty(options.originalText, childPath.getValue(), options)) {\n              parts.push(hardline);\n            }\n          }, \"directives\");\n        }\n\n        if (hasContent) {\n          parts.push(indent(concat([hardline, naked])));\n        }\n\n        parts.push(comments.printDanglingComments(path, options));\n        parts.push(hardline, \"}\");\n        return concat(parts);\n      }\n\n    case \"ReturnStatement\":\n      parts.push(\"return\");\n\n      if (n.argument) {\n        if (returnArgumentHasLeadingComment(options, n.argument)) {\n          parts.push(concat([\" (\", indent(concat([hardline, path.call(print, \"argument\")])), hardline, \")\"]));\n        } else if (n.argument.type === \"LogicalExpression\" || n.argument.type === \"BinaryExpression\" || n.argument.type === \"SequenceExpression\") {\n          parts.push(group(concat([ifBreak(\" (\", \" \"), indent(concat([softline, path.call(print, \"argument\")])), softline, ifBreak(\")\")])));\n        } else {\n          parts.push(\" \", path.call(print, \"argument\"));\n        }\n      }\n\n      if (hasDanglingComments(n)) {\n        parts.push(\" \", comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true));\n      }\n\n      parts.push(semi);\n      return concat(parts);\n\n    case \"NewExpression\":\n    case \"OptionalCallExpression\":\n    case \"CallExpression\":\n      {\n        var isNew = n.type === \"NewExpression\";\n        var optional = printOptionalToken(path);\n\n        if ( // We want to keep CommonJS- and AMD-style require calls, and AMD-style\n        // define calls, as a unit.\n        // e.g. `define([\"some/lib\", (lib) => {`\n        !isNew && n.callee.type === \"Identifier\" && (n.callee.name === \"require\" || n.callee.name === \"define\") || // Template literals as single arguments\n        n.arguments.length === 1 && isTemplateOnItsOwnLine(n.arguments[0], options.originalText, options) || // Keep test declarations on a single line\n        // e.g. `it('long name', () => {`\n        !isNew && isTestCall(n, path.getParentNode())) {\n          return concat([isNew ? \"new \" : \"\", path.call(print, \"callee\"), optional, printFunctionTypeParameters(path, options, print), concat([\"(\", join(\", \", path.map(print, \"arguments\")), \")\"])]);\n        } // Inline Flow annotation comments following Identifiers in Call nodes need to\n        // stay with the Identifier. For example:\n        //\n        // foo /*:: <SomeGeneric> */(bar);\n        //\n        // Here, we ensure that such comments stay between the Identifier and the Callee.\n\n\n        var isIdentifierWithFlowAnnotation = n.callee.type === \"Identifier\" && hasFlowAnnotationComment(n.callee.trailingComments);\n\n        if (isIdentifierWithFlowAnnotation) {\n          n.callee.trailingComments[0].printed = true;\n        } // We detect calls on member lookups and possibly print them in a\n        // special chain format. See `printMemberChain` for more info.\n\n\n        if (!isNew && isMemberish(n.callee)) {\n          return printMemberChain(path, options, print);\n        }\n\n        return concat([isNew ? \"new \" : \"\", path.call(print, \"callee\"), optional, isIdentifierWithFlowAnnotation ? \"/*:: \".concat(n.callee.trailingComments[0].value.substring(2).trim(), \" */\") : \"\", printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]);\n      }\n\n    case \"TSInterfaceDeclaration\":\n      if (isNodeStartingWithDeclare(n, options)) {\n        parts.push(\"declare \");\n      }\n\n      parts.push(n[\"abstract\"] ? \"abstract \" : \"\", printTypeScriptModifiers(path, options, print), \"interface \", path.call(print, \"id\"), n.typeParameters ? path.call(print, \"typeParameters\") : \"\", \" \");\n\n      if (n[\"extends\"] && n[\"extends\"].length) {\n        parts.push(group(indent(concat([softline, \"extends \", (n[\"extends\"].length === 1 ? identity : indent)(join(concat([\",\", line]), path.map(print, \"extends\"))), \" \"]))));\n      }\n\n      parts.push(path.call(print, \"body\"));\n      return concat(parts);\n\n    case \"ObjectTypeInternalSlot\":\n      return concat([n[\"static\"] ? \"static \" : \"\", \"[[\", path.call(print, \"id\"), \"]]\", printOptionalToken(path), n.method ? \"\" : \": \", path.call(print, \"value\")]);\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n    case \"ObjectTypeAnnotation\":\n    case \"TSInterfaceBody\":\n    case \"TSTypeLiteral\":\n      {\n        var propertiesField;\n\n        if (n.type === \"TSTypeLiteral\") {\n          propertiesField = \"members\";\n        } else if (n.type === \"TSInterfaceBody\") {\n          propertiesField = \"body\";\n        } else {\n          propertiesField = \"properties\";\n        }\n\n        var isTypeAnnotation = n.type === \"ObjectTypeAnnotation\";\n        var fields = [];\n\n        if (isTypeAnnotation) {\n          fields.push(\"indexers\", \"callProperties\", \"internalSlots\");\n        }\n\n        fields.push(propertiesField);\n        var firstProperty = fields.map(function (field) {\n          return n[field][0];\n        }).sort(function (a, b) {\n          return options.locStart(a) - options.locStart(b);\n        })[0];\n\n        var _parent4 = path.getParentNode(0);\n\n        var isFlowInterfaceLikeBody = isTypeAnnotation && _parent4 && (_parent4.type === \"InterfaceDeclaration\" || _parent4.type === \"DeclareInterface\" || _parent4.type === \"DeclareClass\") && path.getName() === \"body\";\n        var shouldBreak = n.type === \"TSInterfaceBody\" || isFlowInterfaceLikeBody || n.type === \"ObjectPattern\" && _parent4.type !== \"FunctionDeclaration\" && _parent4.type !== \"FunctionExpression\" && _parent4.type !== \"ArrowFunctionExpression\" && _parent4.type !== \"AssignmentPattern\" && _parent4.type !== \"CatchClause\" && n.properties.some(function (property) {\n          return property.value && (property.value.type === \"ObjectPattern\" || property.value.type === \"ArrayPattern\");\n        }) || n.type !== \"ObjectPattern\" && firstProperty && hasNewlineInRange(options.originalText, options.locStart(n), options.locStart(firstProperty));\n        var separator = isFlowInterfaceLikeBody ? \";\" : n.type === \"TSInterfaceBody\" || n.type === \"TSTypeLiteral\" ? ifBreak(semi, \";\") : \",\";\n        var leftBrace = n.exact ? \"{|\" : \"{\";\n        var rightBrace = n.exact ? \"|}\" : \"}\"; // Unfortunately, things are grouped together in the ast can be\n        // interleaved in the source code. So we need to reorder them before\n        // printing them.\n\n        var propsAndLoc = [];\n        fields.forEach(function (field) {\n          path.each(function (childPath) {\n            var node = childPath.getValue();\n            propsAndLoc.push({\n              node: node,\n              printed: print(childPath),\n              loc: options.locStart(node)\n            });\n          }, field);\n        });\n        var separatorParts = [];\n        var props = propsAndLoc.sort(function (a, b) {\n          return a.loc - b.loc;\n        }).map(function (prop) {\n          var result = concat(separatorParts.concat(group(prop.printed)));\n          separatorParts = [separator, line];\n\n          if ((prop.node.type === \"TSPropertySignature\" || prop.node.type === \"TSMethodSignature\" || prop.node.type === \"TSConstructSignatureDeclaration\") && hasNodeIgnoreComment(prop.node)) {\n            separatorParts.shift();\n          }\n\n          if (isNextLineEmpty(options.originalText, prop.node, options)) {\n            separatorParts.push(hardline);\n          }\n\n          return result;\n        });\n\n        if (n.inexact) {\n          props.push(concat(separatorParts.concat(group(\"...\"))));\n        }\n\n        var lastElem = getLast(n[propertiesField]);\n        var canHaveTrailingSeparator = !(lastElem && (lastElem.type === \"RestProperty\" || lastElem.type === \"RestElement\" || hasNodeIgnoreComment(lastElem) || n.inexact));\n        var content;\n\n        if (props.length === 0) {\n          if (!hasDanglingComments(n)) {\n            return concat([leftBrace, rightBrace, printTypeAnnotation(path, options, print)]);\n          }\n\n          content = group(concat([leftBrace, comments.printDanglingComments(path, options), softline, rightBrace, printOptionalToken(path), printTypeAnnotation(path, options, print)]));\n        } else {\n          content = concat([leftBrace, indent(concat([options.bracketSpacing ? line : softline, concat(props)])), ifBreak(canHaveTrailingSeparator && (separator !== \",\" || shouldPrintComma(options)) ? separator : \"\"), concat([options.bracketSpacing ? line : softline, rightBrace]), printOptionalToken(path), printTypeAnnotation(path, options, print)]);\n        } // If we inline the object as first argument of the parent, we don't want\n        // to create another group so that the object breaks before the return\n        // type\n\n\n        var parentParentParent = path.getParentNode(2);\n\n        if (n.type === \"ObjectPattern\" && _parent4 && shouldHugArguments(_parent4) && !n.decorators && _parent4.params[0] === n || shouldHugType(n) && parentParentParent && shouldHugArguments(parentParentParent) && parentParentParent.params[0].typeAnnotation && parentParentParent.params[0].typeAnnotation.typeAnnotation === n) {\n          return content;\n        }\n\n        return group(content, {\n          shouldBreak: shouldBreak\n        });\n      }\n    // Babel 6\n\n    case \"ObjectProperty\": // Non-standard AST node type.\n\n    case \"Property\":\n      if (n.method || n.kind === \"get\" || n.kind === \"set\") {\n        return printMethod(path, options, print);\n      }\n\n      if (n.shorthand) {\n        parts.push(path.call(print, \"value\"));\n      } else {\n        var printedLeft;\n\n        if (n.computed) {\n          printedLeft = concat([\"[\", path.call(print, \"key\"), \"]\"]);\n        } else {\n          printedLeft = printPropertyKey(path, options, print);\n        }\n\n        parts.push(printAssignment(n.key, printedLeft, \":\", n.value, path.call(print, \"value\"), options));\n      }\n\n      return concat(parts);\n    // Babel 6\n\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      if (n.decorators && n.decorators.length !== 0) {\n        parts.push(printDecorators(path, options, print));\n      }\n\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      parts = parts.concat(printObjectMethod(path, options, print));\n      return concat(parts);\n    // Babel 6\n\n    case \"ObjectMethod\":\n      return printObjectMethod(path, options, print);\n\n    case \"Decorator\":\n      return concat([\"@\", path.call(print, \"expression\"), path.call(print, \"callee\")]);\n\n    case \"ArrayExpression\":\n    case \"ArrayPattern\":\n      if (n.elements.length === 0) {\n        if (!hasDanglingComments(n)) {\n          parts.push(\"[]\");\n        } else {\n          parts.push(group(concat([\"[\", comments.printDanglingComments(path, options), softline, \"]\"])));\n        }\n      } else {\n        var _lastElem = getLast(n.elements);\n\n        var canHaveTrailingComma = !(_lastElem && _lastElem.type === \"RestElement\"); // JavaScript allows you to have empty elements in an array which\n        // changes its length based on the number of commas. The algorithm\n        // is that if the last argument is null, we need to force insert\n        // a comma to ensure JavaScript recognizes it.\n        //   [,].length === 1\n        //   [1,].length === 1\n        //   [1,,].length === 2\n        //\n        // Note that getLast returns null if the array is empty, but\n        // we already check for an empty array just above so we are safe\n\n        var needsForcedTrailingComma = canHaveTrailingComma && _lastElem === null;\n        parts.push(group(concat([\"[\", indent(concat([softline, printArrayItems(path, options, \"elements\", print)])), needsForcedTrailingComma ? \",\" : \"\", ifBreak(canHaveTrailingComma && !needsForcedTrailingComma && shouldPrintComma(options) ? \",\" : \"\"), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), softline, \"]\"])));\n      }\n\n      parts.push(printOptionalToken(path), printTypeAnnotation(path, options, print));\n      return concat(parts);\n\n    case \"SequenceExpression\":\n      {\n        var _parent5 = path.getParentNode(0);\n\n        if (_parent5.type === \"ExpressionStatement\" || _parent5.type === \"ForStatement\") {\n          // For ExpressionStatements and for-loop heads, which are among\n          // the few places a SequenceExpression appears unparenthesized, we want\n          // to indent expressions after the first.\n          var _parts2 = [];\n          path.each(function (p) {\n            if (p.getName() === 0) {\n              _parts2.push(print(p));\n            } else {\n              _parts2.push(\",\", indent(concat([line, print(p)])));\n            }\n          }, \"expressions\");\n          return group(concat(_parts2));\n        }\n\n        return group(concat([join(concat([\",\", line]), path.map(print, \"expressions\"))]));\n      }\n\n    case \"ThisExpression\":\n      return \"this\";\n\n    case \"Super\":\n      return \"super\";\n\n    case \"NullLiteral\":\n      // Babel 6 Literal split\n      return \"null\";\n\n    case \"RegExpLiteral\":\n      // Babel 6 Literal split\n      return printRegex(n);\n\n    case \"NumericLiteral\":\n      // Babel 6 Literal split\n      return printNumber(n.extra.raw);\n\n    case \"BigIntLiteral\":\n      return concat([printNumber(n.extra ? n.extra.rawValue : // TypeScript\n      n.value), \"n\"]);\n\n    case \"BooleanLiteral\": // Babel 6 Literal split\n\n    case \"StringLiteral\": // Babel 6 Literal split\n\n    case \"Literal\":\n      {\n        if (n.regex) {\n          return printRegex(n.regex);\n        }\n\n        if (typeof n.value === \"number\") {\n          return printNumber(n.raw);\n        }\n\n        if (typeof n.value !== \"string\") {\n          return \"\" + n.value;\n        } // TypeScript workaround for https://github.com/JamesHenry/typescript-estree/issues/2\n        // See corresponding workaround in needs-parens.js\n\n\n        var grandParent = path.getParentNode(1);\n        var isTypeScriptDirective = options.parser === \"typescript\" && typeof n.value === \"string\" && grandParent && (grandParent.type === \"Program\" || grandParent.type === \"BlockStatement\");\n        return nodeStr(n, options, isTypeScriptDirective);\n      }\n\n    case \"Directive\":\n      return path.call(print, \"value\");\n    // Babel 6\n\n    case \"DirectiveLiteral\":\n      return nodeStr(n, options);\n\n    case \"UnaryExpression\":\n      parts.push(n.operator);\n\n      if (/[a-z]$/.test(n.operator)) {\n        parts.push(\" \");\n      }\n\n      if (n.argument.comments && n.argument.comments.length > 0) {\n        parts.push(group(concat([\"(\", indent(concat([softline, path.call(print, \"argument\")])), softline, \")\"])));\n      } else {\n        parts.push(path.call(print, \"argument\"));\n      }\n\n      return concat(parts);\n\n    case \"UpdateExpression\":\n      parts.push(path.call(print, \"argument\"), n.operator);\n\n      if (n.prefix) {\n        parts.reverse();\n      }\n\n      return concat(parts);\n\n    case \"ConditionalExpression\":\n      return printTernaryOperator(path, options, print, {\n        beforeParts: function beforeParts() {\n          return [path.call(print, \"test\")];\n        },\n        afterParts: function afterParts(breakClosingParen) {\n          return [breakClosingParen ? softline : \"\"];\n        },\n        shouldCheckJsx: true,\n        conditionalNodeType: \"ConditionalExpression\",\n        consequentNodePropertyName: \"consequent\",\n        alternateNodePropertyName: \"alternate\",\n        testNodePropertyName: \"test\",\n        breakNested: true\n      });\n\n    case \"VariableDeclaration\":\n      {\n        var printed = path.map(function (childPath) {\n          return print(childPath);\n        }, \"declarations\"); // We generally want to terminate all variable declarations with a\n        // semicolon, except when they in the () part of for loops.\n\n        var parentNode = path.getParentNode();\n        var isParentForLoop = parentNode.type === \"ForStatement\" || parentNode.type === \"ForInStatement\" || parentNode.type === \"ForOfStatement\" || parentNode.type === \"ForAwaitStatement\";\n        var hasValue = n.declarations.some(function (decl) {\n          return decl.init;\n        });\n        var firstVariable;\n\n        if (printed.length === 1 && !n.declarations[0].comments) {\n          firstVariable = printed[0];\n        } else if (printed.length > 0) {\n          // Indent first var to comply with eslint one-var rule\n          firstVariable = indent(printed[0]);\n        }\n\n        parts = [isNodeStartingWithDeclare(n, options) ? \"declare \" : \"\", n.kind, firstVariable ? concat([\" \", firstVariable]) : \"\", indent(concat(printed.slice(1).map(function (p) {\n          return concat([\",\", hasValue && !isParentForLoop ? hardline : line, p]);\n        })))];\n\n        if (!(isParentForLoop && parentNode.body !== n)) {\n          parts.push(semi);\n        }\n\n        return group(concat(parts));\n      }\n\n    case \"TSTypeAliasDeclaration\":\n      {\n        if (n.declare) {\n          parts.push(\"declare \");\n        }\n\n        var _printed = printAssignmentRight(n.id, n.typeAnnotation, n.typeAnnotation && path.call(print, \"typeAnnotation\"), options);\n\n        parts.push(\"type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" =\", _printed, semi);\n        return group(concat(parts));\n      }\n\n    case \"VariableDeclarator\":\n      return printAssignment(n.id, path.call(print, \"id\"), \" =\", n.init, n.init && path.call(print, \"init\"), options);\n\n    case \"WithStatement\":\n      return group(concat([\"with (\", path.call(print, \"object\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n    case \"IfStatement\":\n      {\n        var con = adjustClause(n.consequent, path.call(print, \"consequent\"));\n        var opening = group(concat([\"if (\", group(concat([indent(concat([softline, path.call(print, \"test\")])), softline])), \")\", con]));\n        parts.push(opening);\n\n        if (n.alternate) {\n          var commentOnOwnLine = hasTrailingComment(n.consequent) && n.consequent.comments.some(function (comment) {\n            return comment.trailing && !handleComments.isBlockComment(comment);\n          }) || needsHardlineAfterDanglingComment(n);\n          var elseOnSameLine = n.consequent.type === \"BlockStatement\" && !commentOnOwnLine;\n          parts.push(elseOnSameLine ? \" \" : hardline);\n\n          if (hasDanglingComments(n)) {\n            parts.push(comments.printDanglingComments(path, options, true), commentOnOwnLine ? hardline : \" \");\n          }\n\n          parts.push(\"else\", group(adjustClause(n.alternate, path.call(print, \"alternate\"), n.alternate.type === \"IfStatement\")));\n        }\n\n        return concat(parts);\n      }\n\n    case \"ForStatement\":\n      {\n        var _body = adjustClause(n.body, path.call(print, \"body\")); // We want to keep dangling comments above the loop to stay consistent.\n        // Any comment positioned between the for statement and the parentheses\n        // is going to be printed before the statement.\n\n\n        var _dangling = comments.printDanglingComments(path, options,\n        /* sameLine */\n        true);\n\n        var printedComments = _dangling ? concat([_dangling, softline]) : \"\";\n\n        if (!n.init && !n.test && !n.update) {\n          return concat([printedComments, group(concat([\"for (;;)\", _body]))]);\n        }\n\n        return concat([printedComments, group(concat([\"for (\", group(concat([indent(concat([softline, path.call(print, \"init\"), \";\", line, path.call(print, \"test\"), \";\", line, path.call(print, \"update\")])), softline])), \")\", _body]))]);\n      }\n\n    case \"WhileStatement\":\n      return group(concat([\"while (\", group(concat([indent(concat([softline, path.call(print, \"test\")])), softline])), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n    case \"ForInStatement\":\n      // Note: esprima can't actually parse \"for each (\".\n      return group(concat([n.each ? \"for each (\" : \"for (\", path.call(print, \"left\"), \" in \", path.call(print, \"right\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n    case \"ForOfStatement\":\n    case \"ForAwaitStatement\":\n      {\n        // Babel 7 removed ForAwaitStatement in favor of ForOfStatement\n        // with `\"await\": true`:\n        // https://github.com/estree/estree/pull/138\n        var isAwait = n.type === \"ForAwaitStatement\" || n[\"await\"];\n        return group(concat([\"for\", isAwait ? \" await\" : \"\", \" (\", path.call(print, \"left\"), \" of \", path.call(print, \"right\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n      }\n\n    case \"DoWhileStatement\":\n      {\n        var clause = adjustClause(n.body, path.call(print, \"body\"));\n        var doBody = group(concat([\"do\", clause]));\n        parts = [doBody];\n\n        if (n.body.type === \"BlockStatement\") {\n          parts.push(\" \");\n        } else {\n          parts.push(hardline);\n        }\n\n        parts.push(\"while (\");\n        parts.push(group(concat([indent(concat([softline, path.call(print, \"test\")])), softline])), \")\", semi);\n        return concat(parts);\n      }\n\n    case \"DoExpression\":\n      return concat([\"do \", path.call(print, \"body\")]);\n\n    case \"BreakStatement\":\n      parts.push(\"break\");\n\n      if (n.label) {\n        parts.push(\" \", path.call(print, \"label\"));\n      }\n\n      parts.push(semi);\n      return concat(parts);\n\n    case \"ContinueStatement\":\n      parts.push(\"continue\");\n\n      if (n.label) {\n        parts.push(\" \", path.call(print, \"label\"));\n      }\n\n      parts.push(semi);\n      return concat(parts);\n\n    case \"LabeledStatement\":\n      if (n.body.type === \"EmptyStatement\") {\n        return concat([path.call(print, \"label\"), \":;\"]);\n      }\n\n      return concat([path.call(print, \"label\"), \": \", path.call(print, \"body\")]);\n\n    case \"TryStatement\":\n      return concat([\"try \", path.call(print, \"block\"), n.handler ? concat([\" \", path.call(print, \"handler\")]) : \"\", n.finalizer ? concat([\" finally \", path.call(print, \"finalizer\")]) : \"\"]);\n\n    case \"CatchClause\":\n      if (n.param) {\n        var hasComments = n.param.comments && n.param.comments.some(function (comment) {\n          return !handleComments.isBlockComment(comment) || comment.leading && hasNewline(options.originalText, options.locEnd(comment)) || comment.trailing && hasNewline(options.originalText, options.locStart(comment), {\n            backwards: true\n          });\n        });\n        var param = path.call(print, \"param\");\n        return concat([\"catch \", hasComments ? concat([\"(\", indent(concat([softline, param])), softline, \") \"]) : concat([\"(\", param, \") \"]), path.call(print, \"body\")]);\n      }\n\n      return concat([\"catch \", path.call(print, \"body\")]);\n\n    case \"ThrowStatement\":\n      return concat([\"throw \", path.call(print, \"argument\"), semi]);\n    // Note: ignoring n.lexical because it has no printing consequences.\n\n    case \"SwitchStatement\":\n      return concat([group(concat([\"switch (\", indent(concat([softline, path.call(print, \"discriminant\")])), softline, \")\"])), \" {\", n.cases.length > 0 ? indent(concat([hardline, join(hardline, path.map(function (casePath) {\n        var caseNode = casePath.getValue();\n        return concat([casePath.call(print), n.cases.indexOf(caseNode) !== n.cases.length - 1 && isNextLineEmpty(options.originalText, caseNode, options) ? hardline : \"\"]);\n      }, \"cases\"))])) : \"\", hardline, \"}\"]);\n\n    case \"SwitchCase\":\n      {\n        if (n.test) {\n          parts.push(\"case \", path.call(print, \"test\"), \":\");\n        } else {\n          parts.push(\"default:\");\n        }\n\n        var consequent = n.consequent.filter(function (node) {\n          return node.type !== \"EmptyStatement\";\n        });\n\n        if (consequent.length > 0) {\n          var cons = path.call(function (consequentPath) {\n            return printStatementSequence(consequentPath, options, print);\n          }, \"consequent\");\n          parts.push(consequent.length === 1 && consequent[0].type === \"BlockStatement\" ? concat([\" \", cons]) : indent(concat([hardline, cons])));\n        }\n\n        return concat(parts);\n      }\n    // JSX extensions below.\n\n    case \"DebuggerStatement\":\n      return concat([\"debugger\", semi]);\n\n    case \"JSXAttribute\":\n      parts.push(path.call(print, \"name\"));\n\n      if (n.value) {\n        var res;\n\n        if (isStringLiteral(n.value)) {\n          var raw = rawText(n.value); // Unescape all quotes so we get an accurate preferred quote\n\n          var _final = raw.replace(/&apos;/g, \"'\").replace(/&quot;/g, '\"');\n\n          var quote = getPreferredQuote(_final, options.jsxSingleQuote ? \"'\" : '\"');\n\n          var _escape = quote === \"'\" ? \"&apos;\" : \"&quot;\";\n\n          _final = _final.replace(new RegExp(quote, \"g\"), _escape);\n          res = concat([quote, _final, quote]);\n        } else {\n          res = path.call(print, \"value\");\n        }\n\n        parts.push(\"=\", res);\n      }\n\n      return concat(parts);\n\n    case \"JSXIdentifier\":\n      return \"\" + n.name;\n\n    case \"JSXNamespacedName\":\n      return join(\":\", [path.call(print, \"namespace\"), path.call(print, \"name\")]);\n\n    case \"JSXMemberExpression\":\n      return join(\".\", [path.call(print, \"object\"), path.call(print, \"property\")]);\n\n    case \"TSQualifiedName\":\n      return join(\".\", [path.call(print, \"left\"), path.call(print, \"right\")]);\n\n    case \"JSXSpreadAttribute\":\n    case \"JSXSpreadChild\":\n      {\n        return concat([\"{\", path.call(function (p) {\n          var printed = concat([\"...\", print(p)]);\n          var n = p.getValue();\n\n          if (!n.comments || !n.comments.length) {\n            return printed;\n          }\n\n          return concat([indent(concat([softline, comments.printComments(p, function () {\n            return printed;\n          }, options)])), softline]);\n        }, n.type === \"JSXSpreadAttribute\" ? \"argument\" : \"expression\"), \"}\"]);\n      }\n\n    case \"JSXExpressionContainer\":\n      {\n        var _parent6 = path.getParentNode(0);\n\n        var preventInline = _parent6.type === \"JSXAttribute\" && n.expression.comments && n.expression.comments.length > 0;\n\n        var _shouldInline = !preventInline && (n.expression.type === \"ArrayExpression\" || n.expression.type === \"ObjectExpression\" || n.expression.type === \"ArrowFunctionExpression\" || n.expression.type === \"CallExpression\" || n.expression.type === \"OptionalCallExpression\" || n.expression.type === \"FunctionExpression\" || n.expression.type === \"JSXEmptyExpression\" || n.expression.type === \"TemplateLiteral\" || n.expression.type === \"TaggedTemplateExpression\" || n.expression.type === \"DoExpression\" || isJSXNode(_parent6) && (n.expression.type === \"ConditionalExpression\" || isBinaryish(n.expression)));\n\n        if (_shouldInline) {\n          return group(concat([\"{\", path.call(print, \"expression\"), lineSuffixBoundary, \"}\"]));\n        }\n\n        return group(concat([\"{\", indent(concat([softline, path.call(print, \"expression\")])), softline, lineSuffixBoundary, \"}\"]));\n      }\n\n    case \"JSXFragment\":\n    case \"JSXElement\":\n      {\n        var elem = comments.printComments(path, function () {\n          return printJSXElement(path, options, print);\n        }, options);\n        return maybeWrapJSXElementInParens(path, elem);\n      }\n\n    case \"JSXOpeningElement\":\n      {\n        var _n = path.getValue();\n\n        var nameHasComments = _n.name && _n.name.comments && _n.name.comments.length > 0 || _n.typeParameters && _n.typeParameters.comments && _n.typeParameters.comments.length > 0; // Don't break self-closing elements with no attributes and no comments\n\n        if (_n.selfClosing && !_n.attributes.length && !nameHasComments) {\n          return concat([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), \" />\"]);\n        } // don't break up opening elements with a single long text attribute\n\n\n        if (_n.attributes && _n.attributes.length === 1 && _n.attributes[0].value && isStringLiteral(_n.attributes[0].value) && !_n.attributes[0].value.value.includes(\"\\n\") && // We should break for the following cases:\n        // <div\n        //   // comment\n        //   attr=\"value\"\n        // >\n        // <div\n        //   attr=\"value\"\n        //   // comment\n        // >\n        !nameHasComments && (!_n.attributes[0].comments || !_n.attributes[0].comments.length)) {\n          return group(concat([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), \" \", concat(path.map(print, \"attributes\")), _n.selfClosing ? \" />\" : \">\"]));\n        }\n\n        var lastAttrHasTrailingComments = _n.attributes.length && hasTrailingComment(getLast(_n.attributes));\n        var bracketSameLine = // Simple tags (no attributes and no comment in tag name) should be\n        // kept unbroken regardless of `jsxBracketSameLine`\n        !_n.attributes.length && !nameHasComments || options.jsxBracketSameLine && ( // We should print the bracket in a new line for the following cases:\n        // <div\n        //   // comment\n        // >\n        // <div\n        //   attr // comment\n        // >\n        !nameHasComments || _n.attributes.length) && !lastAttrHasTrailingComments; // We should print the opening element expanded if any prop value is a\n        // string literal with newlines\n\n        var _shouldBreak = _n.attributes && _n.attributes.some(function (attr) {\n          return attr.value && isStringLiteral(attr.value) && attr.value.value.includes(\"\\n\");\n        });\n\n        return group(concat([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), concat([indent(concat(path.map(function (attr) {\n          return concat([line, print(attr)]);\n        }, \"attributes\"))), _n.selfClosing ? line : bracketSameLine ? \">\" : softline]), _n.selfClosing ? \"/>\" : bracketSameLine ? \"\" : \">\"]), {\n          shouldBreak: _shouldBreak\n        });\n      }\n\n    case \"JSXClosingElement\":\n      return concat([\"</\", path.call(print, \"name\"), \">\"]);\n\n    case \"JSXOpeningFragment\":\n    case \"JSXClosingFragment\":\n      {\n        var hasComment = n.comments && n.comments.length;\n        var hasOwnLineComment = hasComment && !n.comments.every(handleComments.isBlockComment);\n        var isOpeningFragment = n.type === \"JSXOpeningFragment\";\n        return concat([isOpeningFragment ? \"<\" : \"</\", indent(concat([hasOwnLineComment ? hardline : hasComment && !isOpeningFragment ? \" \" : \"\", comments.printDanglingComments(path, options, true)])), hasOwnLineComment ? hardline : \"\", \">\"]);\n      }\n\n    case \"JSXText\":\n      /* istanbul ignore next */\n      throw new Error(\"JSXTest should be handled by JSXElement\");\n\n    case \"JSXEmptyExpression\":\n      {\n        var requiresHardline = n.comments && !n.comments.every(handleComments.isBlockComment);\n        return concat([comments.printDanglingComments(path, options,\n        /* sameIndent */\n        !requiresHardline), requiresHardline ? hardline : \"\"]);\n      }\n\n    case \"ClassBody\":\n      if (!n.comments && n.body.length === 0) {\n        return \"{}\";\n      }\n\n      return concat([\"{\", n.body.length > 0 ? indent(concat([hardline, path.call(function (bodyPath) {\n        return printStatementSequence(bodyPath, options, print);\n      }, \"body\")])) : comments.printDanglingComments(path, options), hardline, \"}\"]);\n\n    case \"ClassProperty\":\n    case \"TSAbstractClassProperty\":\n    case \"ClassPrivateProperty\":\n      {\n        if (n.decorators && n.decorators.length !== 0) {\n          parts.push(printDecorators(path, options, print));\n        }\n\n        if (n.accessibility) {\n          parts.push(n.accessibility + \" \");\n        }\n\n        if (n[\"static\"]) {\n          parts.push(\"static \");\n        }\n\n        if (n.type === \"TSAbstractClassProperty\") {\n          parts.push(\"abstract \");\n        }\n\n        if (n.readonly) {\n          parts.push(\"readonly \");\n        }\n\n        var variance = getFlowVariance(n);\n\n        if (variance) {\n          parts.push(variance);\n        }\n\n        if (n.computed) {\n          parts.push(\"[\", path.call(print, \"key\"), \"]\");\n        } else {\n          parts.push(printPropertyKey(path, options, print));\n        }\n\n        parts.push(printOptionalToken(path));\n        parts.push(printTypeAnnotation(path, options, print));\n\n        if (n.value) {\n          parts.push(\" =\", printAssignmentRight(n.key, n.value, path.call(print, \"value\"), options));\n        }\n\n        parts.push(semi);\n        return group(concat(parts));\n      }\n\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      if (isNodeStartingWithDeclare(n, options)) {\n        parts.push(\"declare \");\n      }\n\n      parts.push(concat(printClass(path, options, print)));\n      return concat(parts);\n\n    case \"TSInterfaceHeritage\":\n      parts.push(path.call(print, \"expression\"));\n\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n\n      return concat(parts);\n\n    case \"TemplateElement\":\n      return join(literalline, n.value.raw.split(/\\r?\\n/g));\n\n    case \"TemplateLiteral\":\n      {\n        var expressions = path.map(print, \"expressions\");\n\n        var _parentNode = path.getParentNode();\n\n        if (isJestEachTemplateLiteral(n, _parentNode)) {\n          var _printed2 = printJestEachTemplateLiteral(n, expressions, options);\n\n          if (_printed2) {\n            return _printed2;\n          }\n        }\n\n        var isSimple = isSimpleTemplateLiteral(n);\n\n        if (isSimple) {\n          expressions = expressions.map(function (doc) {\n            return printDocToString(doc, Object.assign({}, options, {\n              printWidth: Infinity\n            })).formatted;\n          });\n        }\n\n        parts.push(lineSuffixBoundary, \"`\");\n        path.each(function (childPath) {\n          var i = childPath.getName();\n          parts.push(print(childPath));\n\n          if (i < expressions.length) {\n            // For a template literal of the following form:\n            //   `someQuery {\n            //     ${call({\n            //       a,\n            //       b,\n            //     })}\n            //   }`\n            // the expression is on its own line (there is a \\n in the previous\n            // quasi literal), therefore we want to indent the JavaScript\n            // expression inside at the beginning of ${ instead of the beginning\n            // of the `.\n            var tabWidth = options.tabWidth;\n            var quasi = childPath.getValue();\n            var indentSize = getIndentSize(quasi.value.raw, tabWidth);\n            var _printed3 = expressions[i];\n\n            if (!isSimple) {\n              // Breaks at the template element boundaries (${ and }) are preferred to breaking\n              // in the middle of a MemberExpression\n              if (n.expressions[i].comments && n.expressions[i].comments.length || n.expressions[i].type === \"MemberExpression\" || n.expressions[i].type === \"OptionalMemberExpression\" || n.expressions[i].type === \"ConditionalExpression\") {\n                _printed3 = concat([indent(concat([softline, _printed3])), softline]);\n              }\n            }\n\n            var aligned = indentSize === 0 && quasi.value.raw.endsWith(\"\\n\") ? align(-Infinity, _printed3) : addAlignmentToDoc(_printed3, indentSize, tabWidth);\n            parts.push(group(concat([\"${\", aligned, lineSuffixBoundary, \"}\"])));\n          }\n        }, \"quasis\");\n        parts.push(\"`\");\n        return concat(parts);\n      }\n    // These types are unprintable because they serve as abstract\n    // supertypes for other (printable) types.\n\n    case \"TaggedTemplateExpression\":\n      return concat([path.call(print, \"tag\"), path.call(print, \"typeParameters\"), path.call(print, \"quasi\")]);\n\n    case \"Node\":\n    case \"Printable\":\n    case \"SourceLocation\":\n    case \"Position\":\n    case \"Statement\":\n    case \"Function\":\n    case \"Pattern\":\n    case \"Expression\":\n    case \"Declaration\":\n    case \"Specifier\":\n    case \"NamedSpecifier\":\n    case \"Comment\":\n    case \"MemberTypeAnnotation\": // Flow\n\n    case \"Type\":\n      /* istanbul ignore next */\n      throw new Error(\"unprintable type: \" + JSON.stringify(n.type));\n    // Type Annotations for Facebook Flow, typically stripped out or\n    // transformed away before printing.\n\n    case \"TypeAnnotation\":\n    case \"TSTypeAnnotation\":\n      if (n.typeAnnotation) {\n        return path.call(print, \"typeAnnotation\");\n      }\n      /* istanbul ignore next */\n\n\n      return \"\";\n\n    case \"TSTupleType\":\n    case \"TupleTypeAnnotation\":\n      {\n        var typesField = n.type === \"TSTupleType\" ? \"elementTypes\" : \"types\";\n        return group(concat([\"[\", indent(concat([softline, printArrayItems(path, options, typesField, print)])), ifBreak(shouldPrintComma(options, \"all\") ? \",\" : \"\"), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), softline, \"]\"]));\n      }\n\n    case \"ExistsTypeAnnotation\":\n      return \"*\";\n\n    case \"EmptyTypeAnnotation\":\n      return \"empty\";\n\n    case \"AnyTypeAnnotation\":\n      return \"any\";\n\n    case \"MixedTypeAnnotation\":\n      return \"mixed\";\n\n    case \"ArrayTypeAnnotation\":\n      return concat([path.call(print, \"elementType\"), \"[]\"]);\n\n    case \"BooleanTypeAnnotation\":\n      return \"boolean\";\n\n    case \"BooleanLiteralTypeAnnotation\":\n      return \"\" + n.value;\n\n    case \"DeclareClass\":\n      return printFlowDeclaration(path, printClass(path, options, print));\n\n    case \"TSDeclareFunction\":\n      // For TypeScript the TSDeclareFunction node shares the AST\n      // structure with FunctionDeclaration\n      return concat([n.declare ? \"declare \" : \"\", printFunctionDeclaration(path, print, options), semi]);\n\n    case \"DeclareFunction\":\n      return printFlowDeclaration(path, [\"function \", path.call(print, \"id\"), n.predicate ? \" \" : \"\", path.call(print, \"predicate\"), semi]);\n\n    case \"DeclareModule\":\n      return printFlowDeclaration(path, [\"module \", path.call(print, \"id\"), \" \", path.call(print, \"body\")]);\n\n    case \"DeclareModuleExports\":\n      return printFlowDeclaration(path, [\"module.exports\", \": \", path.call(print, \"typeAnnotation\"), semi]);\n\n    case \"DeclareVariable\":\n      return printFlowDeclaration(path, [\"var \", path.call(print, \"id\"), semi]);\n\n    case \"DeclareExportAllDeclaration\":\n      return concat([\"declare export * from \", path.call(print, \"source\")]);\n\n    case \"DeclareExportDeclaration\":\n      return concat([\"declare \", printExportDeclaration(path, options, print)]);\n\n    case \"DeclareOpaqueType\":\n    case \"OpaqueType\":\n      {\n        parts.push(\"opaque type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n\n        if (n.supertype) {\n          parts.push(\": \", path.call(print, \"supertype\"));\n        }\n\n        if (n.impltype) {\n          parts.push(\" = \", path.call(print, \"impltype\"));\n        }\n\n        parts.push(semi);\n\n        if (n.type === \"DeclareOpaqueType\") {\n          return printFlowDeclaration(path, parts);\n        }\n\n        return concat(parts);\n      }\n\n    case \"FunctionTypeAnnotation\":\n    case \"TSFunctionType\":\n      {\n        // FunctionTypeAnnotation is ambiguous:\n        // declare function foo(a: B): void; OR\n        // var A: (a: B) => void;\n        var _parent7 = path.getParentNode(0);\n\n        var _parentParent2 = path.getParentNode(1);\n\n        var _parentParentParent = path.getParentNode(2);\n\n        var isArrowFunctionTypeAnnotation = n.type === \"TSFunctionType\" || !((_parent7.type === \"ObjectTypeProperty\" || _parent7.type === \"ObjectTypeInternalSlot\") && !getFlowVariance(_parent7) && !_parent7.optional && options.locStart(_parent7) === options.locStart(n) || _parent7.type === \"ObjectTypeCallProperty\" || _parentParentParent && _parentParentParent.type === \"DeclareFunction\");\n        var needsColon = isArrowFunctionTypeAnnotation && (_parent7.type === \"TypeAnnotation\" || _parent7.type === \"TSTypeAnnotation\"); // Sadly we can't put it inside of FastPath::needsColon because we are\n        // printing \":\" as part of the expression and it would put parenthesis\n        // around :(\n\n        var needsParens = needsColon && isArrowFunctionTypeAnnotation && (_parent7.type === \"TypeAnnotation\" || _parent7.type === \"TSTypeAnnotation\") && _parentParent2.type === \"ArrowFunctionExpression\";\n\n        if (isObjectTypePropertyAFunction(_parent7, options)) {\n          isArrowFunctionTypeAnnotation = true;\n          needsColon = true;\n        }\n\n        if (needsParens) {\n          parts.push(\"(\");\n        }\n\n        parts.push(printFunctionParams(path, print, options,\n        /* expandArg */\n        false,\n        /* printTypeParams */\n        true)); // The returnType is not wrapped in a TypeAnnotation, so the colon\n        // needs to be added separately.\n\n        if (n.returnType || n.predicate || n.typeAnnotation) {\n          parts.push(isArrowFunctionTypeAnnotation ? \" => \" : \": \", path.call(print, \"returnType\"), path.call(print, \"predicate\"), path.call(print, \"typeAnnotation\"));\n        }\n\n        if (needsParens) {\n          parts.push(\")\");\n        }\n\n        return group(concat(parts));\n      }\n\n    case \"TSRestType\":\n      return concat([\"...\", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSOptionalType\":\n      return concat([path.call(print, \"typeAnnotation\"), \"?\"]);\n\n    case \"FunctionTypeParam\":\n      return concat([path.call(print, \"name\"), printOptionalToken(path), n.name ? \": \" : \"\", path.call(print, \"typeAnnotation\")]);\n\n    case \"GenericTypeAnnotation\":\n      return concat([path.call(print, \"id\"), path.call(print, \"typeParameters\")]);\n\n    case \"DeclareInterface\":\n    case \"InterfaceDeclaration\":\n    case \"InterfaceTypeAnnotation\":\n      {\n        if (n.type === \"DeclareInterface\" || isNodeStartingWithDeclare(n, options)) {\n          parts.push(\"declare \");\n        }\n\n        parts.push(\"interface\");\n\n        if (n.type === \"DeclareInterface\" || n.type === \"InterfaceDeclaration\") {\n          parts.push(\" \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n        }\n\n        if (n[\"extends\"].length > 0) {\n          parts.push(group(indent(concat([line, \"extends \", (n[\"extends\"].length === 1 ? identity : indent)(join(concat([\",\", line]), path.map(print, \"extends\")))]))));\n        }\n\n        parts.push(\" \", path.call(print, \"body\"));\n        return group(concat(parts));\n      }\n\n    case \"ClassImplements\":\n    case \"InterfaceExtends\":\n      return concat([path.call(print, \"id\"), path.call(print, \"typeParameters\")]);\n\n    case \"TSClassImplements\":\n      return concat([path.call(print, \"expression\"), path.call(print, \"typeParameters\")]);\n\n    case \"TSIntersectionType\":\n    case \"IntersectionTypeAnnotation\":\n      {\n        var types = path.map(print, \"types\");\n        var result = [];\n        var wasIndented = false;\n\n        for (var _i = 0; _i < types.length; ++_i) {\n          if (_i === 0) {\n            result.push(types[_i]);\n          } else if (isObjectType(n.types[_i - 1]) && isObjectType(n.types[_i])) {\n            // If both are objects, don't indent\n            result.push(concat([\" & \", wasIndented ? indent(types[_i]) : types[_i]]));\n          } else if (!isObjectType(n.types[_i - 1]) && !isObjectType(n.types[_i])) {\n            // If no object is involved, go to the next line if it breaks\n            result.push(indent(concat([\" &\", line, types[_i]])));\n          } else {\n            // If you go from object to non-object or vis-versa, then inline it\n            if (_i > 1) {\n              wasIndented = true;\n            }\n\n            result.push(\" & \", _i > 1 ? indent(types[_i]) : types[_i]);\n          }\n        }\n\n        return group(concat(result));\n      }\n\n    case \"TSUnionType\":\n    case \"UnionTypeAnnotation\":\n      {\n        // single-line variation\n        // A | B | C\n        // multi-line variation\n        // | A\n        // | B\n        // | C\n        var _parent8 = path.getParentNode(); // If there's a leading comment, the parent is doing the indentation\n\n\n        var shouldIndent = _parent8.type !== \"TypeParameterInstantiation\" && _parent8.type !== \"TSTypeParameterInstantiation\" && _parent8.type !== \"GenericTypeAnnotation\" && _parent8.type !== \"TSTypeReference\" && _parent8.type !== \"TSTypeAssertion\" && !(_parent8.type === \"FunctionTypeParam\" && !_parent8.name) && !((_parent8.type === \"TypeAlias\" || _parent8.type === \"VariableDeclarator\" || _parent8.type === \"TSTypeAliasDeclaration\") && hasLeadingOwnLineComment(options.originalText, n, options)); // {\n        //   a: string\n        // } | null | void\n        // should be inlined and not be printed in the multi-line variant\n\n        var shouldHug = shouldHugType(n); // We want to align the children but without its comment, so it looks like\n        // | child1\n        // // comment\n        // | child2\n\n        var _printed4 = path.map(function (typePath) {\n          var printedType = typePath.call(print);\n\n          if (!shouldHug) {\n            printedType = align(2, printedType);\n          }\n\n          return comments.printComments(typePath, function () {\n            return printedType;\n          }, options);\n        }, \"types\");\n\n        if (shouldHug) {\n          return join(\" | \", _printed4);\n        }\n\n        var shouldAddStartLine = shouldIndent && !hasLeadingOwnLineComment(options.originalText, n, options);\n        var code = concat([ifBreak(concat([shouldAddStartLine ? line : \"\", \"| \"])), join(concat([line, \"| \"]), _printed4)]);\n        var hasParens;\n\n        if (n.type === \"TSUnionType\") {\n          var _grandParent = path.getNode(2);\n\n          var greatGrandParent = path.getParentNode(2);\n          var greatGreatGrandParent = path.getParentNode(3);\n          hasParens = _parent8.type === \"TSParenthesizedType\" && (_grandParent.type === \"TSAsExpression\" || _grandParent.type === \"TSUnionType\" || _grandParent.type === \"TSIntersectionType\" || _grandParent.type === \"TSTypeOperator\" || _grandParent.type === \"TSArrayType\") || greatGrandParent && greatGrandParent.type === \"TSParenthesizedType\" && greatGreatGrandParent && (greatGreatGrandParent.type === \"TSUnionType\" || greatGreatGrandParent.type === \"TSIntersectionType\");\n        } else {\n          hasParens = pathNeedsParens(path, options);\n        }\n\n        if (hasParens) {\n          return group(concat([indent(code), softline]));\n        }\n\n        return group(shouldIndent ? indent(code) : code);\n      }\n\n    case \"NullableTypeAnnotation\":\n      return concat([\"?\", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSNullKeyword\":\n    case \"NullLiteralTypeAnnotation\":\n      return \"null\";\n\n    case \"ThisTypeAnnotation\":\n      return \"this\";\n\n    case \"NumberTypeAnnotation\":\n      return \"number\";\n\n    case \"ObjectTypeCallProperty\":\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      parts.push(path.call(print, \"value\"));\n      return concat(parts);\n\n    case \"ObjectTypeIndexer\":\n      {\n        var _variance = getFlowVariance(n);\n\n        return concat([_variance || \"\", \"[\", path.call(print, \"id\"), n.id ? \": \" : \"\", path.call(print, \"key\"), \"]: \", path.call(print, \"value\")]);\n      }\n\n    case \"ObjectTypeProperty\":\n      {\n        var _variance2 = getFlowVariance(n);\n\n        var modifier = \"\";\n\n        if (n.proto) {\n          modifier = \"proto \";\n        } else if (n[\"static\"]) {\n          modifier = \"static \";\n        }\n\n        return concat([modifier, isGetterOrSetter(n) ? n.kind + \" \" : \"\", _variance2 || \"\", printPropertyKey(path, options, print), printOptionalToken(path), isFunctionNotation(n, options) ? \"\" : \": \", path.call(print, \"value\")]);\n      }\n\n    case \"QualifiedTypeIdentifier\":\n      return concat([path.call(print, \"qualification\"), \".\", path.call(print, \"id\")]);\n\n    case \"StringLiteralTypeAnnotation\":\n      return nodeStr(n, options);\n\n    case \"NumberLiteralTypeAnnotation\":\n      assert.strictEqual(_typeof(n.value), \"number\");\n\n      if (n.extra != null) {\n        return printNumber(n.extra.raw);\n      }\n\n      return printNumber(n.raw);\n\n    case \"StringTypeAnnotation\":\n      return \"string\";\n\n    case \"DeclareTypeAlias\":\n    case \"TypeAlias\":\n      {\n        if (n.type === \"DeclareTypeAlias\" || isNodeStartingWithDeclare(n, options)) {\n          parts.push(\"declare \");\n        }\n\n        var _printed5 = printAssignmentRight(n.id, n.right, path.call(print, \"right\"), options);\n\n        parts.push(\"type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" =\", _printed5, semi);\n        return group(concat(parts));\n      }\n\n    case \"TypeCastExpression\":\n      {\n        var value = path.getValue(); // Flow supports a comment syntax for specifying type annotations: https://flow.org/en/docs/types/comments/.\n        // Unfortunately, its parser doesn't differentiate between comment annotations and regular\n        // annotations when producing an AST. So to preserve parentheses around type casts that use\n        // the comment syntax, we need to hackily read the source itself to see if the code contains\n        // a type annotation comment.\n        //\n        // Note that we're able to use the normal whitespace regex here because the Flow parser has\n        // already deemed this AST node to be a type cast. Only the Babel parser needs the\n        // non-line-break whitespace regex, which is why hasFlowShorthandAnnotationComment() is\n        // implemented differently.\n\n        var commentSyntax = value && value.typeAnnotation && value.typeAnnotation.range && options.originalText.substring(value.typeAnnotation.range[0]).match(/^\\/\\*\\s*:/);\n        return concat([\"(\", path.call(print, \"expression\"), commentSyntax ? \" /*\" : \"\", \": \", path.call(print, \"typeAnnotation\"), commentSyntax ? \" */\" : \"\", \")\"]);\n      }\n\n    case \"TypeParameterDeclaration\":\n    case \"TypeParameterInstantiation\":\n      {\n        var _value = path.getValue();\n\n        var commentStart = _value.range ? options.originalText.substring(0, _value.range[0]).lastIndexOf(\"/*\") : -1; // As noted in the TypeCastExpression comments above, we're able to use a normal whitespace regex here\n        // because we know for sure that this is a type definition.\n\n        var _commentSyntax = commentStart >= 0 && options.originalText.substring(commentStart).match(/^\\/\\*\\s*::/);\n\n        if (_commentSyntax) {\n          return concat([\"/*:: \", printTypeParameters(path, options, print, \"params\"), \" */\"]);\n        }\n\n        return printTypeParameters(path, options, print, \"params\");\n      }\n\n    case \"TSTypeParameterDeclaration\":\n    case \"TSTypeParameterInstantiation\":\n      return printTypeParameters(path, options, print, \"params\");\n\n    case \"TSTypeParameter\":\n    case \"TypeParameter\":\n      {\n        var _parent9 = path.getParentNode();\n\n        if (_parent9.type === \"TSMappedType\") {\n          parts.push(\"[\", path.call(print, \"name\"));\n\n          if (n.constraint) {\n            parts.push(\" in \", path.call(print, \"constraint\"));\n          }\n\n          parts.push(\"]\");\n          return concat(parts);\n        }\n\n        var _variance3 = getFlowVariance(n);\n\n        if (_variance3) {\n          parts.push(_variance3);\n        }\n\n        parts.push(path.call(print, \"name\"));\n\n        if (n.bound) {\n          parts.push(\": \");\n          parts.push(path.call(print, \"bound\"));\n        }\n\n        if (n.constraint) {\n          parts.push(\" extends \", path.call(print, \"constraint\"));\n        }\n\n        if (n[\"default\"]) {\n          parts.push(\" = \", path.call(print, \"default\"));\n        } // Keep comma if the file extension is .tsx and\n        // has one type parameter that isn't extend with any types.\n        // Because, otherwise formatted result will be invalid as tsx.\n\n\n        var _grandParent2 = path.getNode(2);\n\n        if (_parent9.params && _parent9.params.length === 1 && options.filepath && /\\.tsx$/i.test(options.filepath) && !n.constraint && _grandParent2.type === \"ArrowFunctionExpression\") {\n          parts.push(\",\");\n        }\n\n        return concat(parts);\n      }\n\n    case \"TypeofTypeAnnotation\":\n      return concat([\"typeof \", path.call(print, \"argument\")]);\n\n    case \"VoidTypeAnnotation\":\n      return \"void\";\n\n    case \"InferredPredicate\":\n      return \"%checks\";\n    // Unhandled types below. If encountered, nodes of these types should\n    // be either left alone or desugared into AST types that are fully\n    // supported by the pretty-printer.\n\n    case \"DeclaredPredicate\":\n      return concat([\"%checks(\", path.call(print, \"value\"), \")\"]);\n\n    case \"TSAbstractKeyword\":\n      return \"abstract\";\n\n    case \"TSAnyKeyword\":\n      return \"any\";\n\n    case \"TSAsyncKeyword\":\n      return \"async\";\n\n    case \"TSBooleanKeyword\":\n      return \"boolean\";\n\n    case \"TSBigIntKeyword\":\n      return \"bigint\";\n\n    case \"TSConstKeyword\":\n      return \"const\";\n\n    case \"TSDeclareKeyword\":\n      return \"declare\";\n\n    case \"TSExportKeyword\":\n      return \"export\";\n\n    case \"TSNeverKeyword\":\n      return \"never\";\n\n    case \"TSNumberKeyword\":\n      return \"number\";\n\n    case \"TSObjectKeyword\":\n      return \"object\";\n\n    case \"TSProtectedKeyword\":\n      return \"protected\";\n\n    case \"TSPrivateKeyword\":\n      return \"private\";\n\n    case \"TSPublicKeyword\":\n      return \"public\";\n\n    case \"TSReadonlyKeyword\":\n      return \"readonly\";\n\n    case \"TSSymbolKeyword\":\n      return \"symbol\";\n\n    case \"TSStaticKeyword\":\n      return \"static\";\n\n    case \"TSStringKeyword\":\n      return \"string\";\n\n    case \"TSUndefinedKeyword\":\n      return \"undefined\";\n\n    case \"TSUnknownKeyword\":\n      return \"unknown\";\n\n    case \"TSVoidKeyword\":\n      return \"void\";\n\n    case \"TSAsExpression\":\n      return concat([path.call(print, \"expression\"), \" as \", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSArrayType\":\n      return concat([path.call(print, \"elementType\"), \"[]\"]);\n\n    case \"TSPropertySignature\":\n      {\n        if (n[\"export\"]) {\n          parts.push(\"export \");\n        }\n\n        if (n.accessibility) {\n          parts.push(n.accessibility + \" \");\n        }\n\n        if (n[\"static\"]) {\n          parts.push(\"static \");\n        }\n\n        if (n.readonly) {\n          parts.push(\"readonly \");\n        }\n\n        if (n.computed) {\n          parts.push(\"[\");\n        }\n\n        parts.push(printPropertyKey(path, options, print));\n\n        if (n.computed) {\n          parts.push(\"]\");\n        }\n\n        parts.push(printOptionalToken(path));\n\n        if (n.typeAnnotation) {\n          parts.push(\": \");\n          parts.push(path.call(print, \"typeAnnotation\"));\n        } // This isn't valid semantically, but it's in the AST so we can print it.\n\n\n        if (n.initializer) {\n          parts.push(\" = \", path.call(print, \"initializer\"));\n        }\n\n        return concat(parts);\n      }\n\n    case \"TSParameterProperty\":\n      if (n.accessibility) {\n        parts.push(n.accessibility + \" \");\n      }\n\n      if (n[\"export\"]) {\n        parts.push(\"export \");\n      }\n\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      if (n.readonly) {\n        parts.push(\"readonly \");\n      }\n\n      parts.push(path.call(print, \"parameter\"));\n      return concat(parts);\n\n    case \"TSTypeReference\":\n      return concat([path.call(print, \"typeName\"), printTypeParameters(path, options, print, \"typeParameters\")]);\n\n    case \"TSTypeQuery\":\n      return concat([\"typeof \", path.call(print, \"exprName\")]);\n\n    case \"TSParenthesizedType\":\n      {\n        return path.call(print, \"typeAnnotation\");\n      }\n\n    case \"TSIndexSignature\":\n      {\n        var _parent10 = path.getParentNode();\n\n        return concat([n[\"export\"] ? \"export \" : \"\", n.accessibility ? concat([n.accessibility, \" \"]) : \"\", n[\"static\"] ? \"static \" : \"\", n.readonly ? \"readonly \" : \"\", \"[\", n.parameters ? concat(path.map(print, \"parameters\")) : \"\", \"]: \", path.call(print, \"typeAnnotation\"), _parent10.type === \"ClassBody\" ? semi : \"\"]);\n      }\n\n    case \"TSTypePredicate\":\n      return concat([path.call(print, \"parameterName\"), \" is \", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSNonNullExpression\":\n      return concat([path.call(print, \"expression\"), \"!\"]);\n\n    case \"TSThisType\":\n      return \"this\";\n\n    case \"TSImportType\":\n      return concat([!n.isTypeOf ? \"\" : \"typeof \", \"import(\", path.call(print, \"parameter\"), \")\", !n.qualifier ? \"\" : concat([\".\", path.call(print, \"qualifier\")]), printTypeParameters(path, options, print, \"typeParameters\")]);\n\n    case \"TSLiteralType\":\n      return path.call(print, \"literal\");\n\n    case \"TSIndexedAccessType\":\n      return concat([path.call(print, \"objectType\"), \"[\", path.call(print, \"indexType\"), \"]\"]);\n\n    case \"TSConstructSignatureDeclaration\":\n    case \"TSCallSignatureDeclaration\":\n    case \"TSConstructorType\":\n      {\n        if (n.type !== \"TSCallSignatureDeclaration\") {\n          parts.push(\"new \");\n        }\n\n        parts.push(group(printFunctionParams(path, print, options,\n        /* expandArg */\n        false,\n        /* printTypeParams */\n        true)));\n\n        if (n.returnType) {\n          var isType = n.type === \"TSConstructorType\";\n          parts.push(isType ? \" => \" : \": \", path.call(print, \"returnType\"));\n        }\n\n        return concat(parts);\n      }\n\n    case \"TSTypeOperator\":\n      return concat([n.operator, \" \", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSMappedType\":\n      {\n        var _shouldBreak2 = hasNewlineInRange(options.originalText, options.locStart(n), options.locEnd(n));\n\n        return group(concat([\"{\", indent(concat([options.bracketSpacing ? line : softline, n.readonly ? concat([getTypeScriptMappedTypeModifier(n.readonly, \"readonly\"), \" \"]) : \"\", printTypeScriptModifiers(path, options, print), path.call(print, \"typeParameter\"), n.optional ? getTypeScriptMappedTypeModifier(n.optional, \"?\") : \"\", \": \", path.call(print, \"typeAnnotation\"), ifBreak(semi, \"\")])), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), options.bracketSpacing ? line : softline, \"}\"]), {\n          shouldBreak: _shouldBreak2\n        });\n      }\n\n    case \"TSMethodSignature\":\n      parts.push(n.accessibility ? concat([n.accessibility, \" \"]) : \"\", n[\"export\"] ? \"export \" : \"\", n[\"static\"] ? \"static \" : \"\", n.readonly ? \"readonly \" : \"\", n.computed ? \"[\" : \"\", path.call(print, \"key\"), n.computed ? \"]\" : \"\", printOptionalToken(path), printFunctionParams(path, print, options,\n      /* expandArg */\n      false,\n      /* printTypeParams */\n      true));\n\n      if (n.returnType) {\n        parts.push(\": \", path.call(print, \"returnType\"));\n      }\n\n      return group(concat(parts));\n\n    case \"TSNamespaceExportDeclaration\":\n      parts.push(\"export as namespace \", path.call(print, \"id\"));\n\n      if (options.semi) {\n        parts.push(\";\");\n      }\n\n      return group(concat(parts));\n\n    case \"TSEnumDeclaration\":\n      if (isNodeStartingWithDeclare(n, options)) {\n        parts.push(\"declare \");\n      }\n\n      if (n.modifiers) {\n        parts.push(printTypeScriptModifiers(path, options, print));\n      }\n\n      if (n[\"const\"]) {\n        parts.push(\"const \");\n      }\n\n      parts.push(\"enum \", path.call(print, \"id\"), \" \");\n\n      if (n.members.length === 0) {\n        parts.push(group(concat([\"{\", comments.printDanglingComments(path, options), softline, \"}\"])));\n      } else {\n        parts.push(group(concat([\"{\", indent(concat([hardline, printArrayItems(path, options, \"members\", print), shouldPrintComma(options, \"es5\") ? \",\" : \"\"])), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), hardline, \"}\"])));\n      }\n\n      return concat(parts);\n\n    case \"TSEnumMember\":\n      parts.push(path.call(print, \"id\"));\n\n      if (n.initializer) {\n        parts.push(\" = \", path.call(print, \"initializer\"));\n      }\n\n      return concat(parts);\n\n    case \"TSImportEqualsDeclaration\":\n      if (n.isExport) {\n        parts.push(\"export \");\n      }\n\n      parts.push(\"import \", path.call(print, \"id\"), \" = \", path.call(print, \"moduleReference\"));\n\n      if (options.semi) {\n        parts.push(\";\");\n      }\n\n      return group(concat(parts));\n\n    case \"TSExternalModuleReference\":\n      return concat([\"require(\", path.call(print, \"expression\"), \")\"]);\n\n    case \"TSModuleDeclaration\":\n      {\n        var _parent11 = path.getParentNode();\n\n        var isExternalModule = isLiteral(n.id);\n        var parentIsDeclaration = _parent11.type === \"TSModuleDeclaration\";\n        var bodyIsDeclaration = n.body && n.body.type === \"TSModuleDeclaration\";\n\n        if (parentIsDeclaration) {\n          parts.push(\".\");\n        } else {\n          if (n.declare === true) {\n            parts.push(\"declare \");\n          }\n\n          parts.push(printTypeScriptModifiers(path, options, print));\n          var textBetweenNodeAndItsId = options.originalText.slice(options.locStart(n), options.locStart(n.id)); // Global declaration looks like this:\n          // (declare)? global { ... }\n\n          var isGlobalDeclaration = n.id.type === \"Identifier\" && n.id.name === \"global\" && !/namespace|module/.test(textBetweenNodeAndItsId);\n\n          if (!isGlobalDeclaration) {\n            parts.push(isExternalModule || /(^|\\s)module(\\s|$)/.test(textBetweenNodeAndItsId) ? \"module \" : \"namespace \");\n          }\n        }\n\n        parts.push(path.call(print, \"id\"));\n\n        if (bodyIsDeclaration) {\n          parts.push(path.call(print, \"body\"));\n        } else if (n.body) {\n          parts.push(\" \", group(path.call(print, \"body\")));\n        } else {\n          parts.push(semi);\n        }\n\n        return concat(parts);\n      }\n\n    case \"PrivateName\":\n      return concat([\"#\", path.call(print, \"id\")]);\n\n    case \"TSConditionalType\":\n      return printTernaryOperator(path, options, print, {\n        beforeParts: function beforeParts() {\n          return [path.call(print, \"checkType\"), \" \", \"extends\", \" \", path.call(print, \"extendsType\")];\n        },\n        afterParts: function afterParts() {\n          return [];\n        },\n        shouldCheckJsx: false,\n        conditionalNodeType: \"TSConditionalType\",\n        consequentNodePropertyName: \"trueType\",\n        alternateNodePropertyName: \"falseType\",\n        testNodePropertyName: \"checkType\",\n        breakNested: true\n      });\n\n    case \"TSInferType\":\n      return concat([\"infer\", \" \", path.call(print, \"typeParameter\")]);\n\n    case \"InterpreterDirective\":\n      parts.push(\"#!\", n.value, hardline);\n\n      if (isNextLineEmpty(options.originalText, n, options)) {\n        parts.push(hardline);\n      }\n\n      return concat(parts);\n\n    case \"NGRoot\":\n      return concat([].concat(path.call(print, \"node\"), !n.node.comments || n.node.comments.length === 0 ? [] : concat([\" //\", n.node.comments[0].value.trimRight()])));\n\n    case \"NGChainedExpression\":\n      return group(join(concat([\";\", line]), path.map(function (childPath) {\n        return hasNgSideEffect(childPath) ? print(childPath) : concat([\"(\", print(childPath), \")\"]);\n      }, \"expressions\")));\n\n    case \"NGEmptyExpression\":\n      return \"\";\n\n    case \"NGQuotedExpression\":\n      return concat([n.prefix, \":\", n.value]);\n\n    case \"NGMicrosyntax\":\n      return concat(path.map(function (childPath, index) {\n        return concat([index === 0 ? \"\" : isNgForOf(childPath.getValue(), index, n) ? \" \" : concat([\";\", line]), print(childPath)]);\n      }, \"body\"));\n\n    case \"NGMicrosyntaxKey\":\n      return /^[a-z_$][a-z0-9_$]*(-[a-z_$][a-z0-9_$])*$/i.test(n.name) ? n.name : JSON.stringify(n.name);\n\n    case \"NGMicrosyntaxExpression\":\n      return concat([path.call(print, \"expression\"), n.alias === null ? \"\" : concat([\" as \", path.call(print, \"alias\")])]);\n\n    case \"NGMicrosyntaxKeyedExpression\":\n      {\n        var index = path.getName();\n\n        var _parentNode2 = path.getParentNode();\n\n        var shouldNotPrintColon = isNgForOf(n, index, _parentNode2) || (index === 1 && (n.key.name === \"then\" || n.key.name === \"else\") || index === 2 && n.key.name === \"else\" && _parentNode2.body[index - 1].type === \"NGMicrosyntaxKeyedExpression\" && _parentNode2.body[index - 1].key.name === \"then\") && _parentNode2.body[0].type === \"NGMicrosyntaxExpression\";\n        return concat([path.call(print, \"key\"), shouldNotPrintColon ? \" \" : \": \", path.call(print, \"expression\")]);\n      }\n\n    case \"NGMicrosyntaxLet\":\n      return concat([\"let \", path.call(print, \"key\"), n.value === null ? \"\" : concat([\" = \", path.call(print, \"value\")])]);\n\n    case \"NGMicrosyntaxAs\":\n      return concat([path.call(print, \"key\"), \" as \", path.call(print, \"alias\")]);\n\n    default:\n      /* istanbul ignore next */\n      throw new Error(\"unknown type: \" + JSON.stringify(n.type));\n  }\n}\n\nfunction isNgForOf(node, index, parentNode) {\n  return node.type === \"NGMicrosyntaxKeyedExpression\" && node.key.name === \"of\" && index === 1 && parentNode.body[0].type === \"NGMicrosyntaxLet\" && parentNode.body[0].value === null;\n}\n/** identify if an angular expression seems to have side effects */\n\n\nfunction hasNgSideEffect(path) {\n  return hasNode(path.getValue(), function (node) {\n    switch (node.type) {\n      case undefined:\n        return false;\n\n      case \"CallExpression\":\n      case \"OptionalCallExpression\":\n      case \"AssignmentExpression\":\n        return true;\n    }\n  });\n}\n\nfunction printStatementSequence(path, options, print) {\n  var printed = [];\n  var bodyNode = path.getNode();\n  var isClass = bodyNode.type === \"ClassBody\";\n  path.map(function (stmtPath, i) {\n    var stmt = stmtPath.getValue(); // Just in case the AST has been modified to contain falsy\n    // \"statements,\" it's safer simply to skip them.\n\n    /* istanbul ignore if */\n\n    if (!stmt) {\n      return;\n    } // Skip printing EmptyStatement nodes to avoid leaving stray\n    // semicolons lying around.\n\n\n    if (stmt.type === \"EmptyStatement\") {\n      return;\n    }\n\n    var stmtPrinted = print(stmtPath);\n    var text = options.originalText;\n    var parts = []; // in no-semi mode, prepend statement with semicolon if it might break ASI\n    // don't prepend the only JSX element in a program with semicolon\n\n    if (!options.semi && !isClass && !isTheOnlyJSXElementInMarkdown(options, stmtPath) && stmtNeedsASIProtection(stmtPath, options)) {\n      if (stmt.comments && stmt.comments.some(function (comment) {\n        return comment.leading;\n      })) {\n        parts.push(print(stmtPath, {\n          needsSemi: true\n        }));\n      } else {\n        parts.push(\";\", stmtPrinted);\n      }\n    } else {\n      parts.push(stmtPrinted);\n    }\n\n    if (!options.semi && isClass) {\n      if (classPropMayCauseASIProblems(stmtPath)) {\n        parts.push(\";\");\n      } else if (stmt.type === \"ClassProperty\") {\n        var nextChild = bodyNode.body[i + 1];\n\n        if (classChildNeedsASIProtection(nextChild)) {\n          parts.push(\";\");\n        }\n      }\n    }\n\n    if (isNextLineEmpty(text, stmt, options) && !isLastStatement(stmtPath)) {\n      parts.push(hardline);\n    }\n\n    printed.push(concat(parts));\n  });\n  return join(hardline, printed);\n}\n\nfunction printPropertyKey(path, options, print) {\n  var node = path.getNode();\n  var parent = path.getParentNode();\n  var key = node.key;\n\n  if (options.quoteProps === \"consistent\" && !needsQuoteProps.has(parent)) {\n    var objectHasStringProp = (parent.properties || parent.body || parent.members).some(function (prop) {\n      return !prop.computed && prop.key && isStringLiteral(prop.key) && !isStringPropSafeToCoerceToIdentifier(prop, options);\n    });\n    needsQuoteProps.set(parent, objectHasStringProp);\n  }\n\n  if (key.type === \"Identifier\" && !node.computed && (options.parser === \"json\" || options.quoteProps === \"consistent\" && needsQuoteProps.get(parent))) {\n    // a -> \"a\"\n    var prop = printString(JSON.stringify(key.name), options);\n    return path.call(function (keyPath) {\n      return comments.printComments(keyPath, function () {\n        return prop;\n      }, options);\n    }, \"key\");\n  }\n\n  if (!node.computed && isStringPropSafeToCoerceToIdentifier(node, options) && (options.quoteProps === \"as-needed\" || options.quoteProps === \"consistent\" && !needsQuoteProps.get(parent))) {\n    // 'a' -> a\n    return path.call(function (keyPath) {\n      return comments.printComments(keyPath, function () {\n        return key.value;\n      }, options);\n    }, \"key\");\n  }\n\n  return path.call(print, \"key\");\n}\n\nfunction printMethod(path, options, print) {\n  var node = path.getNode();\n  var semi = options.semi ? \";\" : \"\";\n  var kind = node.kind;\n  var parts = [];\n\n  if (node.type === \"ObjectMethod\" || node.type === \"ClassMethod\" || node.type === \"ClassPrivateMethod\") {\n    node.value = node;\n  }\n\n  if (node.value.async) {\n    parts.push(\"async \");\n  }\n\n  if (!kind || kind === \"init\" || kind === \"method\" || kind === \"constructor\") {\n    if (node.value.generator) {\n      parts.push(\"*\");\n    }\n  } else {\n    assert.ok(kind === \"get\" || kind === \"set\");\n    parts.push(kind, \" \");\n  }\n\n  var key = printPropertyKey(path, options, print);\n\n  if (node.computed) {\n    key = concat([\"[\", key, \"]\"]);\n  }\n\n  parts.push(key, concat(path.call(function (valuePath) {\n    return [printFunctionTypeParameters(valuePath, options, print), group(concat([printFunctionParams(valuePath, print, options), printReturnType(valuePath, print, options)]))];\n  }, \"value\")));\n\n  if (!node.value.body || node.value.body.length === 0) {\n    parts.push(semi);\n  } else {\n    parts.push(\" \", path.call(print, \"value\", \"body\"));\n  }\n\n  return concat(parts);\n}\n\nfunction couldGroupArg(arg) {\n  return arg.type === \"ObjectExpression\" && (arg.properties.length > 0 || arg.comments) || arg.type === \"ArrayExpression\" && (arg.elements.length > 0 || arg.comments) || arg.type === \"TSTypeAssertion\" || arg.type === \"TSAsExpression\" || arg.type === \"FunctionExpression\" || arg.type === \"ArrowFunctionExpression\" && ( // we want to avoid breaking inside composite return types but not simple keywords\n  // https://github.com/prettier/prettier/issues/4070\n  // export class Thing implements OtherThing {\n  //   do: (type: Type) => Provider<Prop> = memoize(\n  //     (type: ObjectType): Provider<Opts> => {}\n  //   );\n  // }\n  // https://github.com/prettier/prettier/issues/6099\n  // app.get(\"/\", (req, res): void => {\n  //   res.send(\"Hello World!\");\n  // });\n  !arg.returnType || !arg.returnType.typeAnnotation || arg.returnType.typeAnnotation.type !== \"TSTypeReference\") && (arg.body.type === \"BlockStatement\" || arg.body.type === \"ArrowFunctionExpression\" || arg.body.type === \"ObjectExpression\" || arg.body.type === \"ArrayExpression\" || arg.body.type === \"CallExpression\" || arg.body.type === \"OptionalCallExpression\" || arg.body.type === \"ConditionalExpression\" || isJSXNode(arg.body));\n}\n\nfunction shouldGroupLastArg(args) {\n  var lastArg = getLast(args);\n  var penultimateArg = getPenultimate(args);\n  return !hasLeadingComment(lastArg) && !hasTrailingComment(lastArg) && couldGroupArg(lastArg) && ( // If the last two arguments are of the same type,\n  // disable last element expansion.\n  !penultimateArg || penultimateArg.type !== lastArg.type);\n}\n\nfunction shouldGroupFirstArg(args) {\n  if (args.length !== 2) {\n    return false;\n  }\n\n  var firstArg = args[0];\n  var secondArg = args[1];\n  return (!firstArg.comments || !firstArg.comments.length) && (firstArg.type === \"FunctionExpression\" || firstArg.type === \"ArrowFunctionExpression\" && firstArg.body.type === \"BlockStatement\") && secondArg.type !== \"FunctionExpression\" && secondArg.type !== \"ArrowFunctionExpression\" && secondArg.type !== \"ConditionalExpression\" && !couldGroupArg(secondArg);\n}\n\nfunction isSimpleFlowType(node) {\n  var flowTypeAnnotations = [\"AnyTypeAnnotation\", \"NullLiteralTypeAnnotation\", \"GenericTypeAnnotation\", \"ThisTypeAnnotation\", \"NumberTypeAnnotation\", \"VoidTypeAnnotation\", \"EmptyTypeAnnotation\", \"MixedTypeAnnotation\", \"BooleanTypeAnnotation\", \"BooleanLiteralTypeAnnotation\", \"StringTypeAnnotation\"];\n  return node && flowTypeAnnotations.indexOf(node.type) !== -1 && !(node.type === \"GenericTypeAnnotation\" && node.typeParameters);\n}\n\nfunction isJestEachTemplateLiteral(node, parentNode) {\n  /**\n   * describe.each`table`(name, fn)\n   * describe.only.each`table`(name, fn)\n   * describe.skip.each`table`(name, fn)\n   * test.each`table`(name, fn)\n   * test.only.each`table`(name, fn)\n   * test.skip.each`table`(name, fn)\n   *\n   * Ref: https://github.com/facebook/jest/pull/6102\n   */\n  var jestEachTriggerRegex = /^[xf]?(describe|it|test)$/;\n  return parentNode.type === \"TaggedTemplateExpression\" && parentNode.quasi === node && parentNode.tag.type === \"MemberExpression\" && parentNode.tag.property.type === \"Identifier\" && parentNode.tag.property.name === \"each\" && (parentNode.tag.object.type === \"Identifier\" && jestEachTriggerRegex.test(parentNode.tag.object.name) || parentNode.tag.object.type === \"MemberExpression\" && parentNode.tag.object.property.type === \"Identifier\" && (parentNode.tag.object.property.name === \"only\" || parentNode.tag.object.property.name === \"skip\") && parentNode.tag.object.object.type === \"Identifier\" && jestEachTriggerRegex.test(parentNode.tag.object.object.name));\n}\n\nfunction printJestEachTemplateLiteral(node, expressions, options) {\n  /**\n   * a    | b    | expected\n   * ${1} | ${1} | ${2}\n   * ${1} | ${2} | ${3}\n   * ${2} | ${1} | ${3}\n   */\n  var headerNames = node.quasis[0].value.raw.trim().split(/\\s*\\|\\s*/);\n\n  if (headerNames.length > 1 || headerNames.some(function (headerName) {\n    return headerName.length !== 0;\n  })) {\n    var parts = [];\n    var stringifiedExpressions = expressions.map(function (doc) {\n      return \"${\" + printDocToString(doc, Object.assign({}, options, {\n        printWidth: Infinity,\n        endOfLine: \"lf\"\n      })).formatted + \"}\";\n    });\n    var tableBody = [{\n      hasLineBreak: false,\n      cells: []\n    }];\n\n    for (var i = 1; i < node.quasis.length; i++) {\n      var row = tableBody[tableBody.length - 1];\n      var correspondingExpression = stringifiedExpressions[i - 1];\n      row.cells.push(correspondingExpression);\n\n      if (correspondingExpression.indexOf(\"\\n\") !== -1) {\n        row.hasLineBreak = true;\n      }\n\n      if (node.quasis[i].value.raw.indexOf(\"\\n\") !== -1) {\n        tableBody.push({\n          hasLineBreak: false,\n          cells: []\n        });\n      }\n    }\n\n    var maxColumnCount = tableBody.reduce(function (maxColumnCount, row) {\n      return Math.max(maxColumnCount, row.cells.length);\n    }, headerNames.length);\n    var maxColumnWidths = Array.from(new Array(maxColumnCount), function () {\n      return 0;\n    });\n    var table = [{\n      cells: headerNames\n    }].concat(tableBody.filter(function (row) {\n      return row.cells.length !== 0;\n    }));\n    table.filter(function (row) {\n      return !row.hasLineBreak;\n    }).forEach(function (row) {\n      row.cells.forEach(function (cell, index) {\n        maxColumnWidths[index] = Math.max(maxColumnWidths[index], getStringWidth(cell));\n      });\n    });\n    parts.push(lineSuffixBoundary, \"`\", indent(concat([hardline, join(hardline, table.map(function (row) {\n      return join(\" | \", row.cells.map(function (cell, index) {\n        return row.hasLineBreak ? cell : cell + \" \".repeat(maxColumnWidths[index] - getStringWidth(cell));\n      }));\n    }))])), hardline, \"`\");\n    return concat(parts);\n  }\n}\n/** @param node {import(\"estree\").TemplateLiteral} */\n\n\nfunction isSimpleTemplateLiteral(node) {\n  if (node.expressions.length === 0) {\n    return false;\n  }\n\n  return node.expressions.every(function (expr) {\n    // Disallow comments since printDocToString can't print them here\n    if (expr.comments) {\n      return false;\n    } // Allow `x` and `this`\n\n\n    if (expr.type === \"Identifier\" || expr.type === \"ThisExpression\") {\n      return true;\n    } // Allow `a.b.c`, `a.b[c]`, and `this.x.y`\n\n\n    if ((expr.type === \"MemberExpression\" || expr.type === \"OptionalMemberExpression\") && (expr.property.type === \"Identifier\" || expr.property.type === \"Literal\")) {\n      var ancestor = expr;\n\n      while (ancestor.type === \"MemberExpression\" || ancestor.type === \"OptionalMemberExpression\") {\n        ancestor = ancestor.object;\n\n        if (ancestor.comments) {\n          return false;\n        }\n      }\n\n      if (ancestor.type === \"Identifier\" || ancestor.type === \"ThisExpression\") {\n        return true;\n      }\n\n      return false;\n    }\n\n    return false;\n  });\n}\n\nvar functionCompositionFunctionNames = new Set([\"pipe\", // RxJS, Ramda\n\"pipeP\", // Ramda\n\"pipeK\", // Ramda\n\"compose\", // Ramda, Redux\n\"composeFlipped\", // Not from any library, but common in Haskell, so supported\n\"composeP\", // Ramda\n\"composeK\", // Ramda\n\"flow\", // Lodash\n\"flowRight\", // Lodash\n\"connect\", // Redux\n\"createSelector\" // Reselect\n]);\nvar ordinaryMethodNames = new Set([\"connect\" // GObject, MongoDB\n]);\n\nfunction isFunctionCompositionFunction(node) {\n  switch (node.type) {\n    case \"OptionalMemberExpression\":\n    case \"MemberExpression\":\n      {\n        return isFunctionCompositionFunction(node.property) && !ordinaryMethodNames.has(node.property.name);\n      }\n\n    case \"Identifier\":\n      {\n        return functionCompositionFunctionNames.has(node.name);\n      }\n\n    case \"StringLiteral\":\n    case \"Literal\":\n      {\n        return functionCompositionFunctionNames.has(node.value);\n      }\n  }\n}\n\nfunction printArgumentsList(path, options, print) {\n  var node = path.getValue();\n  var args = node.arguments;\n\n  if (args.length === 0) {\n    return concat([\"(\", comments.printDanglingComments(path, options,\n    /* sameIndent */\n    true), \")\"]);\n  } // useEffect(() => { ... }, [foo, bar, baz])\n\n\n  if (args.length === 2 && args[0].type === \"ArrowFunctionExpression\" && args[0].params.length === 0 && args[0].body.type === \"BlockStatement\" && args[1].type === \"ArrayExpression\" && !args.find(function (arg) {\n    return arg.comments;\n  })) {\n    return concat([\"(\", path.call(print, \"arguments\", 0), \", \", path.call(print, \"arguments\", 1), \")\"]);\n  } // func(\n  //   ({\n  //     a,\n  //     b\n  //   }) => {}\n  // );\n\n\n  function hasEmptyLineInObjectArgInArrowFunction(arg) {\n    return arg && arg.type === \"ArrowFunctionExpression\" && arg.params && arg.params.some(function (param) {\n      return param.type && param.type === \"ObjectPattern\" && param.properties && param.properties.some(function (property, i, properties) {\n        return i < properties.length - 1 && isNextLineEmpty(options.originalText, property, options);\n      });\n    });\n  }\n\n  var anyArgEmptyLine = false;\n  var hasEmptyLineFollowingFirstArg = false;\n  var lastArgIndex = args.length - 1;\n  var printedArguments = path.map(function (argPath, index) {\n    var arg = argPath.getNode();\n    var parts = [print(argPath)];\n\n    if (index === lastArgIndex) {// do nothing\n    } else if (isNextLineEmpty(options.originalText, arg, options)) {\n      if (index === 0) {\n        hasEmptyLineFollowingFirstArg = true;\n      }\n\n      anyArgEmptyLine = true;\n      parts.push(\",\", hardline, hardline);\n    } else {\n      parts.push(\",\", line);\n    }\n\n    anyArgEmptyLine = hasEmptyLineInObjectArgInArrowFunction(arg);\n    return concat(parts);\n  }, \"arguments\");\n  var maybeTrailingComma = // Dynamic imports cannot have trailing commas\n  !(node.callee && node.callee.type === \"Import\") && shouldPrintComma(options, \"all\") ? \",\" : \"\";\n\n  function allArgsBrokenOut() {\n    return group(concat([\"(\", indent(concat([line, concat(printedArguments)])), maybeTrailingComma, line, \")\"]), {\n      shouldBreak: true\n    });\n  } // We want to get\n  //    pipe(\n  //      x => x + 1,\n  //      x => x - 1\n  //    )\n  // here, but not\n  //    process.stdout.pipe(socket)\n\n\n  if (isFunctionCompositionFunction(node.callee) && args.length > 1) {\n    return allArgsBrokenOut();\n  }\n\n  var shouldGroupFirst = shouldGroupFirstArg(args);\n  var shouldGroupLast = shouldGroupLastArg(args);\n\n  if (shouldGroupFirst || shouldGroupLast) {\n    var shouldBreak = (shouldGroupFirst ? printedArguments.slice(1).some(willBreak) : printedArguments.slice(0, -1).some(willBreak)) || anyArgEmptyLine; // We want to print the last argument with a special flag\n\n    var printedExpanded;\n    var i = 0;\n    path.each(function (argPath) {\n      if (shouldGroupFirst && i === 0) {\n        printedExpanded = [concat([argPath.call(function (p) {\n          return print(p, {\n            expandFirstArg: true\n          });\n        }), printedArguments.length > 1 ? \",\" : \"\", hasEmptyLineFollowingFirstArg ? hardline : line, hasEmptyLineFollowingFirstArg ? hardline : \"\"])].concat(printedArguments.slice(1));\n      }\n\n      if (shouldGroupLast && i === args.length - 1) {\n        printedExpanded = printedArguments.slice(0, -1).concat(argPath.call(function (p) {\n          return print(p, {\n            expandLastArg: true\n          });\n        }));\n      }\n\n      i++;\n    }, \"arguments\");\n    var somePrintedArgumentsWillBreak = printedArguments.some(willBreak);\n    var simpleConcat = concat([\"(\", concat(printedExpanded), \")\"]);\n    return concat([somePrintedArgumentsWillBreak ? breakParent : \"\", conditionalGroup([!somePrintedArgumentsWillBreak ? simpleConcat : ifBreak(allArgsBrokenOut(), simpleConcat), shouldGroupFirst ? concat([\"(\", group(printedExpanded[0], {\n      shouldBreak: true\n    }), concat(printedExpanded.slice(1)), \")\"]) : concat([\"(\", concat(printedArguments.slice(0, -1)), group(getLast(printedExpanded), {\n      shouldBreak: true\n    }), \")\"]), allArgsBrokenOut()], {\n      shouldBreak: shouldBreak\n    })]);\n  }\n\n  return group(concat([\"(\", indent(concat([softline, concat(printedArguments)])), ifBreak(maybeTrailingComma), softline, \")\"]), {\n    shouldBreak: printedArguments.some(willBreak) || anyArgEmptyLine\n  });\n}\n\nfunction printTypeAnnotation(path, options, print) {\n  var node = path.getValue();\n\n  if (!node.typeAnnotation) {\n    return \"\";\n  }\n\n  var parentNode = path.getParentNode();\n  var isDefinite = node.definite || parentNode && parentNode.type === \"VariableDeclarator\" && parentNode.definite;\n  var isFunctionDeclarationIdentifier = parentNode.type === \"DeclareFunction\" && parentNode.id === node;\n\n  if (isFlowAnnotationComment(options.originalText, node.typeAnnotation, options)) {\n    return concat([\" /*: \", path.call(print, \"typeAnnotation\"), \" */\"]);\n  }\n\n  return concat([isFunctionDeclarationIdentifier ? \"\" : isDefinite ? \"!: \" : \": \", path.call(print, \"typeAnnotation\")]);\n}\n\nfunction printFunctionTypeParameters(path, options, print) {\n  var fun = path.getValue();\n\n  if (fun.typeArguments) {\n    return path.call(print, \"typeArguments\");\n  }\n\n  if (fun.typeParameters) {\n    return path.call(print, \"typeParameters\");\n  }\n\n  return \"\";\n}\n\nfunction printFunctionParams(path, print, options, expandArg, printTypeParams) {\n  var fun = path.getValue();\n  var parent = path.getParentNode();\n  var paramsField = fun.parameters ? \"parameters\" : \"params\";\n  var isParametersInTestCall = isTestCall(parent);\n  var shouldHugParameters = shouldHugArguments(fun);\n  var shouldExpandParameters = expandArg && !(fun[paramsField] && fun[paramsField].some(function (n) {\n    return n.comments;\n  }));\n  var typeParams = printTypeParams ? printFunctionTypeParameters(path, options, print) : \"\";\n  var printed = [];\n\n  if (fun[paramsField]) {\n    var lastArgIndex = fun[paramsField].length - 1;\n    printed = path.map(function (childPath, index) {\n      var parts = [];\n      var param = childPath.getValue();\n      parts.push(print(childPath));\n\n      if (index === lastArgIndex) {\n        if (fun.rest) {\n          parts.push(\",\", line);\n        }\n      } else if (isParametersInTestCall || shouldHugParameters || shouldExpandParameters) {\n        parts.push(\", \");\n      } else if (isNextLineEmpty(options.originalText, param, options)) {\n        parts.push(\",\", hardline, hardline);\n      } else {\n        parts.push(\",\", line);\n      }\n\n      return concat(parts);\n    }, paramsField);\n  }\n\n  if (fun.rest) {\n    printed.push(concat([\"...\", path.call(print, \"rest\")]));\n  }\n\n  if (printed.length === 0) {\n    return concat([typeParams, \"(\", comments.printDanglingComments(path, options,\n    /* sameIndent */\n    true, function (comment) {\n      return getNextNonSpaceNonCommentCharacter(options.originalText, comment, options.locEnd) === \")\";\n    }), \")\"]);\n  }\n\n  var lastParam = getLast(fun[paramsField]); // If the parent is a call with the first/last argument expansion and this is the\n  // params of the first/last argument, we dont want the arguments to break and instead\n  // want the whole expression to be on a new line.\n  //\n  // Good:                 Bad:\n  //   verylongcall(         verylongcall((\n  //     (a, b) => {           a,\n  //     }                     b,\n  //   })                    ) => {\n  //                         })\n\n  if (shouldExpandParameters) {\n    return group(concat([removeLines(typeParams), \"(\", concat(printed.map(removeLines)), \")\"]));\n  } // Single object destructuring should hug\n  //\n  // function({\n  //   a,\n  //   b,\n  //   c\n  // }) {}\n\n\n  var hasNotParameterDecorator = fun[paramsField].every(function (param) {\n    return !param.decorators;\n  });\n\n  if (shouldHugParameters && hasNotParameterDecorator) {\n    return concat([typeParams, \"(\", concat(printed), \")\"]);\n  } // don't break in specs, eg; `it(\"should maintain parens around done even when long\", (done) => {})`\n\n\n  if (isParametersInTestCall) {\n    return concat([typeParams, \"(\", concat(printed), \")\"]);\n  }\n\n  var isFlowShorthandWithOneArg = (isObjectTypePropertyAFunction(parent, options) || isTypeAnnotationAFunction(parent, options) || parent.type === \"TypeAlias\" || parent.type === \"UnionTypeAnnotation\" || parent.type === \"TSUnionType\" || parent.type === \"IntersectionTypeAnnotation\" || parent.type === \"FunctionTypeAnnotation\" && parent.returnType === fun) && fun[paramsField].length === 1 && fun[paramsField][0].name === null && fun[paramsField][0].typeAnnotation && fun.typeParameters === null && isSimpleFlowType(fun[paramsField][0].typeAnnotation) && !fun.rest;\n\n  if (isFlowShorthandWithOneArg) {\n    if (options.arrowParens === \"always\") {\n      return concat([\"(\", concat(printed), \")\"]);\n    }\n\n    return concat(printed);\n  }\n\n  var canHaveTrailingComma = !(lastParam && lastParam.type === \"RestElement\") && !fun.rest;\n  return concat([typeParams, \"(\", indent(concat([softline, concat(printed)])), ifBreak(canHaveTrailingComma && shouldPrintComma(options, \"all\") ? \",\" : \"\"), softline, \")\"]);\n}\n\nfunction shouldPrintParamsWithoutParens(path, options) {\n  if (options.arrowParens === \"always\") {\n    return false;\n  }\n\n  if (options.arrowParens === \"avoid\") {\n    var node = path.getValue();\n    return canPrintParamsWithoutParens(node);\n  } // Fallback default; should be unreachable\n\n\n  return false;\n}\n\nfunction canPrintParamsWithoutParens(node) {\n  return node.params.length === 1 && !node.rest && !node.typeParameters && !hasDanglingComments(node) && node.params[0].type === \"Identifier\" && !node.params[0].typeAnnotation && !node.params[0].comments && !node.params[0].optional && !node.predicate && !node.returnType;\n}\n\nfunction printFunctionDeclaration(path, print, options) {\n  var n = path.getValue();\n  var parts = [];\n\n  if (n.async) {\n    parts.push(\"async \");\n  }\n\n  parts.push(\"function\");\n\n  if (n.generator) {\n    parts.push(\"*\");\n  }\n\n  if (n.id) {\n    parts.push(\" \", path.call(print, \"id\"));\n  }\n\n  parts.push(printFunctionTypeParameters(path, options, print), group(concat([printFunctionParams(path, print, options), printReturnType(path, print, options)])), n.body ? \" \" : \"\", path.call(print, \"body\"));\n  return concat(parts);\n}\n\nfunction printObjectMethod(path, options, print) {\n  var objMethod = path.getValue();\n  var parts = [];\n\n  if (objMethod.async) {\n    parts.push(\"async \");\n  }\n\n  if (objMethod.generator) {\n    parts.push(\"*\");\n  }\n\n  if (objMethod.method || objMethod.kind === \"get\" || objMethod.kind === \"set\") {\n    return printMethod(path, options, print);\n  }\n\n  var key = printPropertyKey(path, options, print);\n\n  if (objMethod.computed) {\n    parts.push(\"[\", key, \"]\");\n  } else {\n    parts.push(key);\n  }\n\n  parts.push(printFunctionTypeParameters(path, options, print), group(concat([printFunctionParams(path, print, options), printReturnType(path, print, options)])), \" \", path.call(print, \"body\"));\n  return concat(parts);\n}\n\nfunction printReturnType(path, print, options) {\n  var n = path.getValue();\n  var returnType = path.call(print, \"returnType\");\n\n  if (n.returnType && isFlowAnnotationComment(options.originalText, n.returnType, options)) {\n    return concat([\" /*: \", returnType, \" */\"]);\n  }\n\n  var parts = [returnType]; // prepend colon to TypeScript type annotation\n\n  if (n.returnType && n.returnType.typeAnnotation) {\n    parts.unshift(\": \");\n  }\n\n  if (n.predicate) {\n    // The return type will already add the colon, but otherwise we\n    // need to do it ourselves\n    parts.push(n.returnType ? \" \" : \": \", path.call(print, \"predicate\"));\n  }\n\n  return concat(parts);\n}\n\nfunction printExportDeclaration(path, options, print) {\n  var decl = path.getValue();\n  var semi = options.semi ? \";\" : \"\";\n  var parts = [\"export \"];\n  var isDefault = decl[\"default\"] || decl.type === \"ExportDefaultDeclaration\";\n\n  if (isDefault) {\n    parts.push(\"default \");\n  }\n\n  parts.push(comments.printDanglingComments(path, options,\n  /* sameIndent */\n  true));\n\n  if (needsHardlineAfterDanglingComment(decl)) {\n    parts.push(hardline);\n  }\n\n  if (decl.declaration) {\n    parts.push(path.call(print, \"declaration\"));\n\n    if (isDefault && decl.declaration.type !== \"ClassDeclaration\" && decl.declaration.type !== \"FunctionDeclaration\" && decl.declaration.type !== \"TSInterfaceDeclaration\" && decl.declaration.type !== \"DeclareClass\" && decl.declaration.type !== \"DeclareFunction\" && decl.declaration.type !== \"TSDeclareFunction\") {\n      parts.push(semi);\n    }\n  } else {\n    if (decl.specifiers && decl.specifiers.length > 0) {\n      var specifiers = [];\n      var defaultSpecifiers = [];\n      var namespaceSpecifiers = [];\n      path.each(function (specifierPath) {\n        var specifierType = path.getValue().type;\n\n        if (specifierType === \"ExportSpecifier\") {\n          specifiers.push(print(specifierPath));\n        } else if (specifierType === \"ExportDefaultSpecifier\") {\n          defaultSpecifiers.push(print(specifierPath));\n        } else if (specifierType === \"ExportNamespaceSpecifier\") {\n          namespaceSpecifiers.push(concat([\"* as \", print(specifierPath)]));\n        }\n      }, \"specifiers\");\n      var isNamespaceFollowed = namespaceSpecifiers.length !== 0 && specifiers.length !== 0;\n      var isDefaultFollowed = defaultSpecifiers.length !== 0 && (namespaceSpecifiers.length !== 0 || specifiers.length !== 0);\n      var canBreak = specifiers.length > 1 || defaultSpecifiers.length > 0 || decl.specifiers && decl.specifiers.some(function (node) {\n        return node.comments;\n      });\n      var printed = \"\";\n\n      if (specifiers.length !== 0) {\n        if (canBreak) {\n          printed = group(concat([\"{\", indent(concat([options.bracketSpacing ? line : softline, join(concat([\",\", line]), specifiers)])), ifBreak(shouldPrintComma(options) ? \",\" : \"\"), options.bracketSpacing ? line : softline, \"}\"]));\n        } else {\n          printed = concat([\"{\", options.bracketSpacing ? \" \" : \"\", concat(specifiers), options.bracketSpacing ? \" \" : \"\", \"}\"]);\n        }\n      }\n\n      parts.push(decl.exportKind === \"type\" ? \"type \" : \"\", concat(defaultSpecifiers), concat([isDefaultFollowed ? \", \" : \"\"]), concat(namespaceSpecifiers), concat([isNamespaceFollowed ? \", \" : \"\"]), printed);\n    } else {\n      parts.push(\"{}\");\n    }\n\n    if (decl.source) {\n      parts.push(\" from \", path.call(print, \"source\"));\n    }\n\n    parts.push(semi);\n  }\n\n  return concat(parts);\n}\n\nfunction printFlowDeclaration(path, parts) {\n  var parentExportDecl = getParentExportDeclaration(path);\n\n  if (parentExportDecl) {\n    assert.strictEqual(parentExportDecl.type, \"DeclareExportDeclaration\");\n  } else {\n    // If the parent node has type DeclareExportDeclaration, then it\n    // will be responsible for printing the \"declare\" token. Otherwise\n    // it needs to be printed with this non-exported declaration node.\n    parts.unshift(\"declare \");\n  }\n\n  return concat(parts);\n}\n\nfunction getFlowVariance(path) {\n  if (!path.variance) {\n    return null;\n  } // Babel 7.0 currently uses variance node type, and flow should\n  // follow suit soon:\n  // https://github.com/babel/babel/issues/4722\n\n\n  var variance = path.variance.kind || path.variance;\n\n  switch (variance) {\n    case \"plus\":\n      return \"+\";\n\n    case \"minus\":\n      return \"-\";\n\n    default:\n      /* istanbul ignore next */\n      return variance;\n  }\n}\n\nfunction printTypeScriptModifiers(path, options, print) {\n  var n = path.getValue();\n\n  if (!n.modifiers || !n.modifiers.length) {\n    return \"\";\n  }\n\n  return concat([join(\" \", path.map(print, \"modifiers\")), \" \"]);\n}\n\nfunction printTypeParameters(path, options, print, paramsKey) {\n  var n = path.getValue();\n\n  if (!n[paramsKey]) {\n    return \"\";\n  } // for TypeParameterDeclaration typeParameters is a single node\n\n\n  if (!Array.isArray(n[paramsKey])) {\n    return path.call(print, paramsKey);\n  }\n\n  var grandparent = path.getNode(2);\n  var isParameterInTestCall = grandparent != null && isTestCall(grandparent);\n  var shouldInline = isParameterInTestCall || n[paramsKey].length === 0 || n[paramsKey].length === 1 && (shouldHugType(n[paramsKey][0]) || n[paramsKey][0].type === \"GenericTypeAnnotation\" && shouldHugType(n[paramsKey][0].id) || n[paramsKey][0].type === \"TSTypeReference\" && shouldHugType(n[paramsKey][0].typeName) || n[paramsKey][0].type === \"NullableTypeAnnotation\");\n\n  if (shouldInline) {\n    return concat([\"<\", join(\", \", path.map(print, paramsKey)), \">\"]);\n  }\n\n  return group(concat([\"<\", indent(concat([softline, join(concat([\",\", line]), path.map(print, paramsKey))])), ifBreak(options.parser !== \"typescript\" && shouldPrintComma(options, \"all\") ? \",\" : \"\"), softline, \">\"]));\n}\n\nfunction printClass(path, options, print) {\n  var n = path.getValue();\n  var parts = [];\n\n  if (n[\"abstract\"]) {\n    parts.push(\"abstract \");\n  }\n\n  parts.push(\"class\");\n\n  if (n.id) {\n    parts.push(\" \", path.call(print, \"id\"));\n  }\n\n  parts.push(path.call(print, \"typeParameters\"));\n  var partsGroup = [];\n\n  if (n.superClass) {\n    var printed = concat([\"extends \", path.call(print, \"superClass\"), path.call(print, \"superTypeParameters\")]); // Keep old behaviour of extends in same line\n    // If there is only on extends and there are not comments\n\n    if ((!n[\"implements\"] || n[\"implements\"].length === 0) && (!n.superClass.comments || n.superClass.comments.length === 0)) {\n      parts.push(concat([\" \", path.call(function (superClass) {\n        return comments.printComments(superClass, function () {\n          return printed;\n        }, options);\n      }, \"superClass\")]));\n    } else {\n      partsGroup.push(group(concat([line, path.call(function (superClass) {\n        return comments.printComments(superClass, function () {\n          return printed;\n        }, options);\n      }, \"superClass\")])));\n    }\n  } else if (n[\"extends\"] && n[\"extends\"].length > 0) {\n    parts.push(\" extends \", join(\", \", path.map(print, \"extends\")));\n  }\n\n  if (n[\"mixins\"] && n[\"mixins\"].length > 0) {\n    partsGroup.push(line, \"mixins \", group(indent(join(concat([\",\", line]), path.map(print, \"mixins\")))));\n  }\n\n  if (n[\"implements\"] && n[\"implements\"].length > 0) {\n    partsGroup.push(line, \"implements\", group(indent(concat([line, join(concat([\",\", line]), path.map(print, \"implements\"))]))));\n  }\n\n  if (partsGroup.length > 0) {\n    parts.push(group(indent(concat(partsGroup))));\n  }\n\n  if (n.body && n.body.comments && hasLeadingOwnLineComment(options.originalText, n.body, options)) {\n    parts.push(hardline);\n  } else {\n    parts.push(\" \");\n  }\n\n  parts.push(path.call(print, \"body\"));\n  return parts;\n}\n\nfunction printOptionalToken(path) {\n  var node = path.getValue();\n\n  if (!node.optional) {\n    return \"\";\n  }\n\n  if (node.type === \"OptionalCallExpression\" || node.type === \"OptionalMemberExpression\" && node.computed) {\n    return \"?.\";\n  }\n\n  return \"?\";\n}\n\nfunction printMemberLookup(path, options, print) {\n  var property = path.call(print, \"property\");\n  var n = path.getValue();\n  var optional = printOptionalToken(path);\n\n  if (!n.computed) {\n    return concat([optional, \".\", property]);\n  }\n\n  if (!n.property || isNumericLiteral(n.property)) {\n    return concat([optional, \"[\", property, \"]\"]);\n  }\n\n  return group(concat([optional, \"[\", indent(concat([softline, property])), softline, \"]\"]));\n}\n\nfunction printBindExpressionCallee(path, options, print) {\n  return concat([\"::\", path.call(print, \"callee\")]);\n} // We detect calls on member expressions specially to format a\n// common pattern better. The pattern we are looking for is this:\n//\n// arr\n//   .map(x => x + 1)\n//   .filter(x => x > 10)\n//   .some(x => x % 2)\n//\n// The way it is structured in the AST is via a nested sequence of\n// MemberExpression and CallExpression. We need to traverse the AST\n// and make groups out of it to print it in the desired way.\n\n\nfunction printMemberChain(path, options, print) {\n  // The first phase is to linearize the AST by traversing it down.\n  //\n  //   a().b()\n  // has the following AST structure:\n  //   CallExpression(MemberExpression(CallExpression(Identifier)))\n  // and we transform it into\n  //   [Identifier, CallExpression, MemberExpression, CallExpression]\n  var printedNodes = []; // Here we try to retain one typed empty line after each call expression or\n  // the first group whether it is in parentheses or not\n\n  function shouldInsertEmptyLineAfter(node) {\n    var originalText = options.originalText;\n    var nextCharIndex = getNextNonSpaceNonCommentCharacterIndex(originalText, node, options);\n    var nextChar = originalText.charAt(nextCharIndex); // if it is cut off by a parenthesis, we only account for one typed empty\n    // line after that parenthesis\n\n    if (nextChar == \")\") {\n      return isNextLineEmptyAfterIndex(originalText, nextCharIndex + 1, options);\n    }\n\n    return isNextLineEmpty(originalText, node, options);\n  }\n\n  function rec(path) {\n    var node = path.getValue();\n\n    if ((node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\") && (isMemberish(node.callee) || node.callee.type === \"CallExpression\" || node.callee.type === \"OptionalCallExpression\")) {\n      printedNodes.unshift({\n        node: node,\n        printed: concat([comments.printComments(path, function () {\n          return concat([printOptionalToken(path), printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]);\n        }, options), shouldInsertEmptyLineAfter(node) ? hardline : \"\"])\n      });\n      path.call(function (callee) {\n        return rec(callee);\n      }, \"callee\");\n    } else if (isMemberish(node)) {\n      printedNodes.unshift({\n        node: node,\n        needsParens: pathNeedsParens(path, options),\n        printed: comments.printComments(path, function () {\n          return node.type === \"OptionalMemberExpression\" || node.type === \"MemberExpression\" ? printMemberLookup(path, options, print) : printBindExpressionCallee(path, options, print);\n        }, options)\n      });\n      path.call(function (object) {\n        return rec(object);\n      }, \"object\");\n    } else if (node.type === \"TSNonNullExpression\") {\n      printedNodes.unshift({\n        node: node,\n        printed: comments.printComments(path, function () {\n          return \"!\";\n        }, options)\n      });\n      path.call(function (expression) {\n        return rec(expression);\n      }, \"expression\");\n    } else {\n      printedNodes.unshift({\n        node: node,\n        printed: path.call(print)\n      });\n    }\n  } // Note: the comments of the root node have already been printed, so we\n  // need to extract this first call without printing them as they would\n  // if handled inside of the recursive call.\n\n\n  var node = path.getValue();\n  printedNodes.unshift({\n    node: node,\n    printed: concat([printOptionalToken(path), printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)])\n  });\n  path.call(function (callee) {\n    return rec(callee);\n  }, \"callee\"); // Once we have a linear list of printed nodes, we want to create groups out\n  // of it.\n  //\n  //   a().b.c().d().e\n  // will be grouped as\n  //   [\n  //     [Identifier, CallExpression],\n  //     [MemberExpression, MemberExpression, CallExpression],\n  //     [MemberExpression, CallExpression],\n  //     [MemberExpression],\n  //   ]\n  // so that we can print it as\n  //   a()\n  //     .b.c()\n  //     .d()\n  //     .e\n  // The first group is the first node followed by\n  //   - as many CallExpression as possible\n  //       < fn()()() >.something()\n  //   - as many array acessors as possible\n  //       < fn()[0][1][2] >.something()\n  //   - then, as many MemberExpression as possible but the last one\n  //       < this.items >.something()\n\n  var groups = [];\n  var currentGroup = [printedNodes[0]];\n  var i = 1;\n\n  for (; i < printedNodes.length; ++i) {\n    if (printedNodes[i].node.type === \"TSNonNullExpression\" || printedNodes[i].node.type === \"OptionalCallExpression\" || printedNodes[i].node.type === \"CallExpression\" || (printedNodes[i].node.type === \"MemberExpression\" || printedNodes[i].node.type === \"OptionalMemberExpression\") && printedNodes[i].node.computed && isNumericLiteral(printedNodes[i].node.property)) {\n      currentGroup.push(printedNodes[i]);\n    } else {\n      break;\n    }\n  }\n\n  if (printedNodes[0].node.type !== \"CallExpression\" && printedNodes[0].node.type !== \"OptionalCallExpression\") {\n    for (; i + 1 < printedNodes.length; ++i) {\n      if (isMemberish(printedNodes[i].node) && isMemberish(printedNodes[i + 1].node)) {\n        currentGroup.push(printedNodes[i]);\n      } else {\n        break;\n      }\n    }\n  }\n\n  groups.push(currentGroup);\n  currentGroup = []; // Then, each following group is a sequence of MemberExpression followed by\n  // a sequence of CallExpression. To compute it, we keep adding things to the\n  // group until we has seen a CallExpression in the past and reach a\n  // MemberExpression\n\n  var hasSeenCallExpression = false;\n\n  for (; i < printedNodes.length; ++i) {\n    if (hasSeenCallExpression && isMemberish(printedNodes[i].node)) {\n      // [0] should be appended at the end of the group instead of the\n      // beginning of the next one\n      if (printedNodes[i].node.computed && isNumericLiteral(printedNodes[i].node.property)) {\n        currentGroup.push(printedNodes[i]);\n        continue;\n      }\n\n      groups.push(currentGroup);\n      currentGroup = [];\n      hasSeenCallExpression = false;\n    }\n\n    if (printedNodes[i].node.type === \"CallExpression\" || printedNodes[i].node.type === \"OptionalCallExpression\") {\n      hasSeenCallExpression = true;\n    }\n\n    currentGroup.push(printedNodes[i]);\n\n    if (printedNodes[i].node.comments && printedNodes[i].node.comments.some(function (comment) {\n      return comment.trailing;\n    })) {\n      groups.push(currentGroup);\n      currentGroup = [];\n      hasSeenCallExpression = false;\n    }\n  }\n\n  if (currentGroup.length > 0) {\n    groups.push(currentGroup);\n  } // There are cases like Object.keys(), Observable.of(), _.values() where\n  // they are the subject of all the chained calls and therefore should\n  // be kept on the same line:\n  //\n  //   Object.keys(items)\n  //     .filter(x => x)\n  //     .map(x => x)\n  //\n  // In order to detect those cases, we use an heuristic: if the first\n  // node is an identifier with the name starting with a capital\n  // letter or just a sequence of _$. The rationale is that they are\n  // likely to be factories.\n\n\n  function isFactory(name) {\n    return /^[A-Z]|^[_$]+$/.test(name);\n  } // In case the Identifier is shorter than tab width, we can keep the\n  // first call in a single line, if it's an ExpressionStatement.\n  //\n  //   d3.scaleLinear()\n  //     .domain([0, 100])\n  //     .range([0, width]);\n  //\n\n\n  function isShort(name) {\n    return name.length <= options.tabWidth;\n  }\n\n  function shouldNotWrap(groups) {\n    var parent = path.getParentNode();\n    var isExpression = parent && parent.type === \"ExpressionStatement\";\n    var hasComputed = groups[1].length && groups[1][0].node.computed;\n\n    if (groups[0].length === 1) {\n      var firstNode = groups[0][0].node;\n      return firstNode.type === \"ThisExpression\" || firstNode.type === \"Identifier\" && (isFactory(firstNode.name) || isExpression && isShort(firstNode.name) || hasComputed);\n    }\n\n    var lastNode = getLast(groups[0]).node;\n    return (lastNode.type === \"MemberExpression\" || lastNode.type === \"OptionalMemberExpression\") && lastNode.property.type === \"Identifier\" && (isFactory(lastNode.property.name) || hasComputed);\n  }\n\n  var shouldMerge = groups.length >= 2 && !groups[1][0].node.comments && shouldNotWrap(groups);\n\n  function printGroup(printedGroup) {\n    var printed = printedGroup.map(function (tuple) {\n      return tuple.printed;\n    }); // Checks if the last node (i.e. the parent node) needs parens and print\n    // accordingly\n\n    if (printedGroup.length > 0 && printedGroup[printedGroup.length - 1].needsParens) {\n      return concat([\"(\"].concat(_toConsumableArray(printed), [\")\"]));\n    }\n\n    return concat(printed);\n  }\n\n  function printIndentedGroup(groups) {\n    if (groups.length === 0) {\n      return \"\";\n    }\n\n    return indent(group(concat([hardline, join(hardline, groups.map(printGroup))])));\n  }\n\n  var printedGroups = groups.map(printGroup);\n  var oneLine = concat(printedGroups);\n  var cutoff = shouldMerge ? 3 : 2;\n  var flatGroups = groups.slice(0, cutoff).reduce(function (res, group) {\n    return res.concat(group);\n  }, []);\n  var hasComment = flatGroups.slice(1, -1).some(function (node) {\n    return hasLeadingComment(node.node);\n  }) || flatGroups.slice(0, -1).some(function (node) {\n    return hasTrailingComment(node.node);\n  }) || groups[cutoff] && hasLeadingComment(groups[cutoff][0].node); // If we only have a single `.`, we shouldn't do anything fancy and just\n  // render everything concatenated together.\n\n  if (groups.length <= cutoff && !hasComment) {\n    return group(oneLine);\n  } // Find out the last node in the first group and check if it has an\n  // empty line after\n\n\n  var lastNodeBeforeIndent = getLast(shouldMerge ? groups.slice(1, 2)[0] : groups[0]).node;\n  var shouldHaveEmptyLineBeforeIndent = lastNodeBeforeIndent.type !== \"CallExpression\" && lastNodeBeforeIndent.type !== \"OptionalCallExpression\" && shouldInsertEmptyLineAfter(lastNodeBeforeIndent);\n  var expanded = concat([printGroup(groups[0]), shouldMerge ? concat(groups.slice(1, 2).map(printGroup)) : \"\", shouldHaveEmptyLineBeforeIndent ? hardline : \"\", printIndentedGroup(groups.slice(shouldMerge ? 2 : 1))]);\n  var callExpressions = printedNodes.map(function (_ref) {\n    var node = _ref.node;\n    return node;\n  }).filter(isCallOrOptionalCallExpression); // We don't want to print in one line if there's:\n  //  * A comment.\n  //  * 3 or more chained calls.\n  //  * Any group but the last one has a hard line.\n  // If the last group is a function it's okay to inline if it fits.\n\n  if (hasComment || callExpressions.length >= 3 || printedGroups.slice(0, -1).some(willBreak) ||\n  /**\n   *     scopes.filter(scope => scope.value !== '').map((scope, i) => {\n   *       // multi line content\n   *     })\n   */\n  function (lastGroupDoc, lastGroupNode) {\n    return isCallOrOptionalCallExpression(lastGroupNode) && willBreak(lastGroupDoc);\n  }(getLast(printedGroups), getLast(getLast(groups)).node) && callExpressions.slice(0, -1).some(function (n) {\n    return n.arguments.some(isFunctionOrArrowExpression);\n  })) {\n    return group(expanded);\n  }\n\n  return concat([// We only need to check `oneLine` because if `expanded` is chosen\n  // that means that the parent group has already been broken\n  // naturally\n  willBreak(oneLine) || shouldHaveEmptyLineBeforeIndent ? breakParent : \"\", conditionalGroup([oneLine, expanded])]);\n}\n\nfunction isCallOrOptionalCallExpression(node) {\n  return node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\";\n}\n\nfunction isJSXNode(node) {\n  return node.type === \"JSXElement\" || node.type === \"JSXFragment\";\n}\n\nfunction isEmptyJSXElement(node) {\n  if (node.children.length === 0) {\n    return true;\n  }\n\n  if (node.children.length > 1) {\n    return false;\n  } // if there is one text child and does not contain any meaningful text\n  // we can treat the element as empty.\n\n\n  var child = node.children[0];\n  return isLiteral(child) && !isMeaningfulJSXText(child);\n} // Only space, newline, carriage return, and tab are treated as whitespace\n// inside JSX.\n\n\nvar jsxWhitespaceChars = \" \\n\\r\\t\";\nvar containsNonJsxWhitespaceRegex = new RegExp(\"[^\" + jsxWhitespaceChars + \"]\");\nvar matchJsxWhitespaceRegex = new RegExp(\"([\" + jsxWhitespaceChars + \"]+)\"); // Meaningful if it contains non-whitespace characters,\n// or it contains whitespace without a new line.\n\nfunction isMeaningfulJSXText(node) {\n  return isLiteral(node) && (containsNonJsxWhitespaceRegex.test(rawText(node)) || !/\\n/.test(rawText(node)));\n}\n\nfunction conditionalExpressionChainContainsJSX(node) {\n  return Boolean(getConditionalChainContents(node).find(isJSXNode));\n} // If we have nested conditional expressions, we want to print them in JSX mode\n// if there's at least one JSXElement somewhere in the tree.\n//\n// A conditional expression chain like this should be printed in normal mode,\n// because there aren't JSXElements anywhere in it:\n//\n// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : \"Unknown\";\n//\n// But a conditional expression chain like this should be printed in JSX mode,\n// because there is a JSXElement in the last ConditionalExpression:\n//\n// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : <span className=\"warning\">Unknown</span>;\n//\n// This type of ConditionalExpression chain is structured like this in the AST:\n//\n// ConditionalExpression {\n//   test: ...,\n//   consequent: ...,\n//   alternate: ConditionalExpression {\n//     test: ...,\n//     consequent: ...,\n//     alternate: ConditionalExpression {\n//       test: ...,\n//       consequent: ...,\n//       alternate: ...,\n//     }\n//   }\n// }\n//\n// We want to traverse over that shape and convert it into a flat structure so\n// that we can find if there's a JSXElement somewhere inside.\n\n\nfunction getConditionalChainContents(node) {\n  // Given this code:\n  //\n  // // Using a ConditionalExpression as the consequent is uncommon, but should\n  // // be handled.\n  // A ? B : C ? D : E ? F ? G : H : I\n  //\n  // which has this AST:\n  //\n  // ConditionalExpression {\n  //   test: Identifier(A),\n  //   consequent: Identifier(B),\n  //   alternate: ConditionalExpression {\n  //     test: Identifier(C),\n  //     consequent: Identifier(D),\n  //     alternate: ConditionalExpression {\n  //       test: Identifier(E),\n  //       consequent: ConditionalExpression {\n  //         test: Identifier(F),\n  //         consequent: Identifier(G),\n  //         alternate: Identifier(H),\n  //       },\n  //       alternate: Identifier(I),\n  //     }\n  //   }\n  // }\n  //\n  // we should return this Array:\n  //\n  // [\n  //   Identifier(A),\n  //   Identifier(B),\n  //   Identifier(C),\n  //   Identifier(D),\n  //   Identifier(E),\n  //   Identifier(F),\n  //   Identifier(G),\n  //   Identifier(H),\n  //   Identifier(I)\n  // ];\n  //\n  // This loses the information about whether each node was the test,\n  // consequent, or alternate, but we don't care about that here- we are only\n  // flattening this structure to find if there's any JSXElements inside.\n  var nonConditionalExpressions = [];\n\n  function recurse(node) {\n    if (node.type === \"ConditionalExpression\") {\n      recurse(node.test);\n      recurse(node.consequent);\n      recurse(node.alternate);\n    } else {\n      nonConditionalExpressions.push(node);\n    }\n  }\n\n  recurse(node);\n  return nonConditionalExpressions;\n} // Detect an expression node representing `{\" \"}`\n\n\nfunction isJSXWhitespaceExpression(node) {\n  return node.type === \"JSXExpressionContainer\" && isLiteral(node.expression) && node.expression.value === \" \" && !node.expression.comments;\n}\n\nfunction separatorNoWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {\n  if (isFacebookTranslationTag) {\n    return \"\";\n  }\n\n  if (childNode.type === \"JSXElement\" && !childNode.closingElement || nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement) {\n    return child.length === 1 ? softline : hardline;\n  }\n\n  return softline;\n}\n\nfunction separatorWithWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {\n  if (isFacebookTranslationTag) {\n    return hardline;\n  }\n\n  if (child.length === 1) {\n    return childNode.type === \"JSXElement\" && !childNode.closingElement || nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement ? hardline : softline;\n  }\n\n  return hardline;\n} // JSX Children are strange, mostly for two reasons:\n// 1. JSX reads newlines into string values, instead of skipping them like JS\n// 2. up to one whitespace between elements within a line is significant,\n//    but not between lines.\n//\n// Leading, trailing, and lone whitespace all need to\n// turn themselves into the rather ugly `{' '}` when breaking.\n//\n// We print JSX using the `fill` doc primitive.\n// This requires that we give it an array of alternating\n// content and whitespace elements.\n// To ensure this we add dummy `\"\"` content elements as needed.\n\n\nfunction printJSXChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag) {\n  var n = path.getValue();\n  var children = []; // using `map` instead of `each` because it provides `i`\n\n  path.map(function (childPath, i) {\n    var child = childPath.getValue();\n\n    if (isLiteral(child)) {\n      var text = rawText(child); // Contains a non-whitespace character\n\n      if (isMeaningfulJSXText(child)) {\n        var words = text.split(matchJsxWhitespaceRegex); // Starts with whitespace\n\n        if (words[0] === \"\") {\n          children.push(\"\");\n          words.shift();\n\n          if (/\\n/.test(words[0])) {\n            var next = n.children[i + 1];\n            children.push(separatorWithWhitespace(isFacebookTranslationTag, words[1], child, next));\n          } else {\n            children.push(jsxWhitespace);\n          }\n\n          words.shift();\n        }\n\n        var endWhitespace; // Ends with whitespace\n\n        if (getLast(words) === \"\") {\n          words.pop();\n          endWhitespace = words.pop();\n        } // This was whitespace only without a new line.\n\n\n        if (words.length === 0) {\n          return;\n        }\n\n        words.forEach(function (word, i) {\n          if (i % 2 === 1) {\n            children.push(line);\n          } else {\n            children.push(word);\n          }\n        });\n\n        if (endWhitespace !== undefined) {\n          if (/\\n/.test(endWhitespace)) {\n            var _next = n.children[i + 1];\n            children.push(separatorWithWhitespace(isFacebookTranslationTag, getLast(children), child, _next));\n          } else {\n            children.push(jsxWhitespace);\n          }\n        } else {\n          var _next2 = n.children[i + 1];\n          children.push(separatorNoWhitespace(isFacebookTranslationTag, getLast(children), child, _next2));\n        }\n      } else if (/\\n/.test(text)) {\n        // Keep (up to one) blank line between tags/expressions/text.\n        // Note: We don't keep blank lines between text elements.\n        if (text.match(/\\n/g).length > 1) {\n          children.push(\"\");\n          children.push(hardline);\n        }\n      } else {\n        children.push(\"\");\n        children.push(jsxWhitespace);\n      }\n    } else {\n      var printedChild = print(childPath);\n      children.push(printedChild);\n      var _next3 = n.children[i + 1];\n\n      var directlyFollowedByMeaningfulText = _next3 && isMeaningfulJSXText(_next3);\n\n      if (directlyFollowedByMeaningfulText) {\n        var firstWord = rawText(_next3).trim().split(matchJsxWhitespaceRegex)[0];\n        children.push(separatorNoWhitespace(isFacebookTranslationTag, firstWord, child, _next3));\n      } else {\n        children.push(hardline);\n      }\n    }\n  }, \"children\");\n  return children;\n} // JSX expands children from the inside-out, instead of the outside-in.\n// This is both to break children before attributes,\n// and to ensure that when children break, their parents do as well.\n//\n// Any element that is written without any newlines and fits on a single line\n// is left that way.\n// Not only that, any user-written-line containing multiple JSX siblings\n// should also be kept on one line if possible,\n// so each user-written-line is wrapped in its own group.\n//\n// Elements that contain newlines or don't fit on a single line (recursively)\n// are fully-split, using hardline and shouldBreak: true.\n//\n// To support that case properly, all leading and trailing spaces\n// are stripped from the list of children, and replaced with a single hardline.\n\n\nfunction printJSXElement(path, options, print) {\n  var n = path.getValue();\n\n  if (n.type === \"JSXElement\" && isEmptyJSXElement(n)) {\n    return concat([path.call(print, \"openingElement\"), path.call(print, \"closingElement\")]);\n  }\n\n  var openingLines = n.type === \"JSXElement\" ? path.call(print, \"openingElement\") : path.call(print, \"openingFragment\");\n  var closingLines = n.type === \"JSXElement\" ? path.call(print, \"closingElement\") : path.call(print, \"closingFragment\");\n\n  if (n.children.length === 1 && n.children[0].type === \"JSXExpressionContainer\" && (n.children[0].expression.type === \"TemplateLiteral\" || n.children[0].expression.type === \"TaggedTemplateExpression\")) {\n    return concat([openingLines, concat(path.map(print, \"children\")), closingLines]);\n  } // Convert `{\" \"}` to text nodes containing a space.\n  // This makes it easy to turn them into `jsxWhitespace` which\n  // can then print as either a space or `{\" \"}` when breaking.\n\n\n  n.children = n.children.map(function (child) {\n    if (isJSXWhitespaceExpression(child)) {\n      return {\n        type: \"JSXText\",\n        value: \" \",\n        raw: \" \"\n      };\n    }\n\n    return child;\n  });\n  var containsTag = n.children.filter(isJSXNode).length > 0;\n  var containsMultipleExpressions = n.children.filter(function (child) {\n    return child.type === \"JSXExpressionContainer\";\n  }).length > 1;\n  var containsMultipleAttributes = n.type === \"JSXElement\" && n.openingElement.attributes.length > 1; // Record any breaks. Should never go from true to false, only false to true.\n\n  var forcedBreak = willBreak(openingLines) || containsTag || containsMultipleAttributes || containsMultipleExpressions;\n  var rawJsxWhitespace = options.singleQuote ? \"{' '}\" : '{\" \"}';\n  var jsxWhitespace = ifBreak(concat([rawJsxWhitespace, softline]), \" \");\n  var isFacebookTranslationTag = n.openingElement && n.openingElement.name && n.openingElement.name.name === \"fbt\";\n  var children = printJSXChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag);\n  var containsText = n.children.filter(function (child) {\n    return isMeaningfulJSXText(child);\n  }).length > 0; // We can end up we multiple whitespace elements with empty string\n  // content between them.\n  // We need to remove empty whitespace and softlines before JSX whitespace\n  // to get the correct output.\n\n  for (var i = children.length - 2; i >= 0; i--) {\n    var isPairOfEmptyStrings = children[i] === \"\" && children[i + 1] === \"\";\n    var isPairOfHardlines = children[i] === hardline && children[i + 1] === \"\" && children[i + 2] === hardline;\n    var isLineFollowedByJSXWhitespace = (children[i] === softline || children[i] === hardline) && children[i + 1] === \"\" && children[i + 2] === jsxWhitespace;\n    var isJSXWhitespaceFollowedByLine = children[i] === jsxWhitespace && children[i + 1] === \"\" && (children[i + 2] === softline || children[i + 2] === hardline);\n    var isDoubleJSXWhitespace = children[i] === jsxWhitespace && children[i + 1] === \"\" && children[i + 2] === jsxWhitespace;\n    var isPairOfHardOrSoftLines = children[i] === softline && children[i + 1] === \"\" && children[i + 2] === hardline || children[i] === hardline && children[i + 1] === \"\" && children[i + 2] === softline;\n\n    if (isPairOfHardlines && containsText || isPairOfEmptyStrings || isLineFollowedByJSXWhitespace || isDoubleJSXWhitespace || isPairOfHardOrSoftLines) {\n      children.splice(i, 2);\n    } else if (isJSXWhitespaceFollowedByLine) {\n      children.splice(i + 1, 2);\n    }\n  } // Trim trailing lines (or empty strings)\n\n\n  while (children.length && (isLineNext(getLast(children)) || isEmpty(getLast(children)))) {\n    children.pop();\n  } // Trim leading lines (or empty strings)\n\n\n  while (children.length && (isLineNext(children[0]) || isEmpty(children[0])) && (isLineNext(children[1]) || isEmpty(children[1]))) {\n    children.shift();\n    children.shift();\n  } // Tweak how we format children if outputting this element over multiple lines.\n  // Also detect whether we will force this element to output over multiple lines.\n\n\n  var multilineChildren = [];\n  children.forEach(function (child, i) {\n    // There are a number of situations where we need to ensure we display\n    // whitespace as `{\" \"}` when outputting this element over multiple lines.\n    if (child === jsxWhitespace) {\n      if (i === 1 && children[i - 1] === \"\") {\n        if (children.length === 2) {\n          // Solitary whitespace\n          multilineChildren.push(rawJsxWhitespace);\n          return;\n        } // Leading whitespace\n\n\n        multilineChildren.push(concat([rawJsxWhitespace, hardline]));\n        return;\n      } else if (i === children.length - 1) {\n        // Trailing whitespace\n        multilineChildren.push(rawJsxWhitespace);\n        return;\n      } else if (children[i - 1] === \"\" && children[i - 2] === hardline) {\n        // Whitespace after line break\n        multilineChildren.push(rawJsxWhitespace);\n        return;\n      }\n    }\n\n    multilineChildren.push(child);\n\n    if (willBreak(child)) {\n      forcedBreak = true;\n    }\n  }); // If there is text we use `fill` to fit as much onto each line as possible.\n  // When there is no text (just tags and expressions) we use `group`\n  // to output each on a separate line.\n\n  var content = containsText ? fill(multilineChildren) : group(concat(multilineChildren), {\n    shouldBreak: true\n  });\n  var multiLineElem = group(concat([openingLines, indent(concat([hardline, content])), hardline, closingLines]));\n\n  if (forcedBreak) {\n    return multiLineElem;\n  }\n\n  return conditionalGroup([group(concat([openingLines, concat(children), closingLines])), multiLineElem]);\n}\n\nfunction maybeWrapJSXElementInParens(path, elem) {\n  var parent = path.getParentNode();\n\n  if (!parent) {\n    return elem;\n  }\n\n  var NO_WRAP_PARENTS = {\n    ArrayExpression: true,\n    JSXAttribute: true,\n    JSXElement: true,\n    JSXExpressionContainer: true,\n    JSXFragment: true,\n    ExpressionStatement: true,\n    CallExpression: true,\n    OptionalCallExpression: true,\n    ConditionalExpression: true,\n    JsExpressionRoot: true\n  };\n\n  if (NO_WRAP_PARENTS[parent.type]) {\n    return elem;\n  }\n\n  var shouldBreak = matchAncestorTypes(path, [\"ArrowFunctionExpression\", \"CallExpression\", \"JSXExpressionContainer\"]);\n  return group(concat([ifBreak(\"(\"), indent(concat([softline, elem])), softline, ifBreak(\")\")]), {\n    shouldBreak: shouldBreak\n  });\n}\n\nfunction isBinaryish(node) {\n  return node.type === \"BinaryExpression\" || node.type === \"LogicalExpression\" || node.type === \"NGPipeExpression\";\n}\n\nfunction isMemberish(node) {\n  return node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\" || node.type === \"BindExpression\" && node.object;\n}\n\nfunction shouldInlineLogicalExpression(node) {\n  if (node.type !== \"LogicalExpression\") {\n    return false;\n  }\n\n  if (node.right.type === \"ObjectExpression\" && node.right.properties.length !== 0) {\n    return true;\n  }\n\n  if (node.right.type === \"ArrayExpression\" && node.right.elements.length !== 0) {\n    return true;\n  }\n\n  if (isJSXNode(node.right)) {\n    return true;\n  }\n\n  return false;\n} // For binary expressions to be consistent, we need to group\n// subsequent operators with the same precedence level under a single\n// group. Otherwise they will be nested such that some of them break\n// onto new lines but not all. Operators with the same precedence\n// level should either all break or not. Because we group them by\n// precedence level and the AST is structured based on precedence\n// level, things are naturally broken up correctly, i.e. `&&` is\n// broken before `+`.\n\n\nfunction printBinaryishExpressions(path, print, options, isNested, isInsideParenthesis) {\n  var parts = [];\n  var node = path.getValue(); // We treat BinaryExpression and LogicalExpression nodes the same.\n\n  if (isBinaryish(node)) {\n    // Put all operators with the same precedence level in the same\n    // group. The reason we only need to do this with the `left`\n    // expression is because given an expression like `1 + 2 - 3`, it\n    // is always parsed like `((1 + 2) - 3)`, meaning the `left` side\n    // is where the rest of the expression will exist. Binary\n    // expressions on the right side mean they have a difference\n    // precedence level and should be treated as a separate group, so\n    // print them normally. (This doesn't hold for the `**` operator,\n    // which is unique in that it is right-associative.)\n    if (shouldFlatten(node.operator, node.left.operator)) {\n      // Flatten them out by recursively calling this function.\n      parts = parts.concat(path.call(function (left) {\n        return printBinaryishExpressions(left, print, options,\n        /* isNested */\n        true, isInsideParenthesis);\n      }, \"left\"));\n    } else {\n      parts.push(path.call(print, \"left\"));\n    }\n\n    var shouldInline = shouldInlineLogicalExpression(node);\n    var lineBeforeOperator = (node.operator === \"|>\" || node.type === \"NGPipeExpression\" || node.operator === \"|\" && options.parser === \"__vue_expression\") && !hasLeadingOwnLineComment(options.originalText, node.right, options);\n    var operator = node.type === \"NGPipeExpression\" ? \"|\" : node.operator;\n    var rightSuffix = node.type === \"NGPipeExpression\" && node.arguments.length !== 0 ? group(indent(concat([softline, \": \", join(concat([softline, \":\", ifBreak(\" \")]), path.map(print, \"arguments\").map(function (arg) {\n      return align(2, group(arg));\n    }))]))) : \"\";\n    var right = shouldInline ? concat([operator, \" \", path.call(print, \"right\"), rightSuffix]) : concat([lineBeforeOperator ? softline : \"\", operator, lineBeforeOperator ? \" \" : line, path.call(print, \"right\"), rightSuffix]); // If there's only a single binary expression, we want to create a group\n    // in order to avoid having a small right part like -1 be on its own line.\n\n    var parent = path.getParentNode();\n    var shouldGroup = !(isInsideParenthesis && node.type === \"LogicalExpression\") && parent.type !== node.type && node.left.type !== node.type && node.right.type !== node.type;\n    parts.push(\" \", shouldGroup ? group(right) : right); // The root comments are already printed, but we need to manually print\n    // the other ones since we don't call the normal print on BinaryExpression,\n    // only for the left and right parts\n\n    if (isNested && node.comments) {\n      parts = comments.printComments(path, function () {\n        return concat(parts);\n      }, options);\n    }\n  } else {\n    // Our stopping case. Simply print the node normally.\n    parts.push(path.call(print));\n  }\n\n  return parts;\n}\n\nfunction printAssignmentRight(leftNode, rightNode, printedRight, options) {\n  if (hasLeadingOwnLineComment(options.originalText, rightNode, options)) {\n    return indent(concat([hardline, printedRight]));\n  }\n\n  var canBreak = isBinaryish(rightNode) && !shouldInlineLogicalExpression(rightNode) || rightNode.type === \"ConditionalExpression\" && isBinaryish(rightNode.test) && !shouldInlineLogicalExpression(rightNode.test) || rightNode.type === \"StringLiteralTypeAnnotation\" || rightNode.type === \"ClassExpression\" && rightNode.decorators && rightNode.decorators.length || (leftNode.type === \"Identifier\" || isStringLiteral(leftNode) || leftNode.type === \"MemberExpression\") && (isStringLiteral(rightNode) || isMemberExpressionChain(rightNode)) && // do not put values on a separate line from the key in json\n  options.parser !== \"json\" && options.parser !== \"json5\" || rightNode.type === \"SequenceExpression\";\n\n  if (canBreak) {\n    return group(indent(concat([line, printedRight])));\n  }\n\n  return concat([\" \", printedRight]);\n}\n\nfunction printAssignment(leftNode, printedLeft, operator, rightNode, printedRight, options) {\n  if (!rightNode) {\n    return printedLeft;\n  }\n\n  var printed = printAssignmentRight(leftNode, rightNode, printedRight, options);\n  return group(concat([printedLeft, operator, printed]));\n}\n\nfunction adjustClause(node, clause, forceSpace) {\n  if (node.type === \"EmptyStatement\") {\n    return \";\";\n  }\n\n  if (node.type === \"BlockStatement\" || forceSpace) {\n    return concat([\" \", clause]);\n  }\n\n  return indent(concat([line, clause]));\n}\n\nfunction nodeStr(node, options, isFlowOrTypeScriptDirectiveLiteral) {\n  var raw = rawText(node);\n  var isDirectiveLiteral = isFlowOrTypeScriptDirectiveLiteral || node.type === \"DirectiveLiteral\";\n  return printString(raw, options, isDirectiveLiteral);\n}\n\nfunction printRegex(node) {\n  var flags = node.flags.split(\"\").sort().join(\"\");\n  return \"/\".concat(node.pattern, \"/\").concat(flags);\n}\n\nfunction isLastStatement(path) {\n  var parent = path.getParentNode();\n\n  if (!parent) {\n    return true;\n  }\n\n  var node = path.getValue();\n  var body = (parent.body || parent.consequent).filter(function (stmt) {\n    return stmt.type !== \"EmptyStatement\";\n  });\n  return body && body[body.length - 1] === node;\n}\n\nfunction hasLeadingComment(node) {\n  return node.comments && node.comments.some(function (comment) {\n    return comment.leading;\n  });\n}\n\nfunction hasTrailingComment(node) {\n  return node.comments && node.comments.some(function (comment) {\n    return comment.trailing;\n  });\n}\n\nfunction hasLeadingOwnLineComment(text, node, options) {\n  if (isJSXNode(node)) {\n    return hasNodeIgnoreComment(node);\n  }\n\n  var res = node.comments && node.comments.some(function (comment) {\n    return comment.leading && hasNewline(text, options.locEnd(comment));\n  });\n  return res;\n}\n\nfunction isFlowAnnotationComment(text, typeAnnotation, options) {\n  var start = options.locStart(typeAnnotation);\n  var end = skipWhitespace(text, options.locEnd(typeAnnotation));\n  return text.substr(start, 2) === \"/*\" && text.substr(end, 2) === \"*/\";\n}\n\nfunction exprNeedsASIProtection(path, options) {\n  var node = path.getValue();\n  var maybeASIProblem = pathNeedsParens(path, options) || node.type === \"ParenthesizedExpression\" || node.type === \"TypeCastExpression\" || node.type === \"ArrowFunctionExpression\" && !shouldPrintParamsWithoutParens(path, options) || node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\" || node.type === \"UnaryExpression\" && node.prefix && (node.operator === \"+\" || node.operator === \"-\") || node.type === \"TemplateLiteral\" || node.type === \"TemplateElement\" || isJSXNode(node) || node.type === \"BindExpression\" && !node.object || node.type === \"RegExpLiteral\" || node.type === \"Literal\" && node.pattern || node.type === \"Literal\" && node.regex;\n\n  if (maybeASIProblem) {\n    return true;\n  }\n\n  if (!hasNakedLeftSide(node)) {\n    return false;\n  }\n\n  return path.call.apply(path, [function (childPath) {\n    return exprNeedsASIProtection(childPath, options);\n  }].concat(getLeftSidePathName(path, node)));\n}\n\nfunction stmtNeedsASIProtection(path, options) {\n  var node = path.getNode();\n\n  if (node.type !== \"ExpressionStatement\") {\n    return false;\n  }\n\n  return path.call(function (childPath) {\n    return exprNeedsASIProtection(childPath, options);\n  }, \"expression\");\n}\n\nfunction classPropMayCauseASIProblems(path) {\n  var node = path.getNode();\n\n  if (node.type !== \"ClassProperty\") {\n    return false;\n  }\n\n  var name = node.key && node.key.name; // this isn't actually possible yet with most parsers available today\n  // so isn't properly tested yet.\n\n  if ((name === \"static\" || name === \"get\" || name === \"set\") && !node.value && !node.typeAnnotation) {\n    return true;\n  }\n}\n\nfunction classChildNeedsASIProtection(node) {\n  if (!node) {\n    return;\n  }\n\n  if (node[\"static\"] || node.accessibility // TypeScript\n  ) {\n      return false;\n    }\n\n  if (!node.computed) {\n    var name = node.key && node.key.name;\n\n    if (name === \"in\" || name === \"instanceof\") {\n      return true;\n    }\n  }\n\n  switch (node.type) {\n    case \"ClassProperty\":\n    case \"TSAbstractClassProperty\":\n      return node.computed;\n\n    case \"MethodDefinition\": // Flow\n\n    case \"TSAbstractMethodDefinition\": // TypeScript\n\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      {\n        // Babel\n        var isAsync = node.value ? node.value.async : node.async;\n        var isGenerator = node.value ? node.value.generator : node.generator;\n\n        if (isAsync || node.kind === \"get\" || node.kind === \"set\") {\n          return false;\n        }\n\n        if (node.computed || isGenerator) {\n          return true;\n        }\n\n        return false;\n      }\n\n    default:\n      /* istanbul ignore next */\n      return false;\n  }\n} // This recurses the return argument, looking for the first token\n// (the leftmost leaf node) and, if it (or its parents) has any\n// leadingComments, returns true (so it can be wrapped in parens).\n\n\nfunction returnArgumentHasLeadingComment(options, argument) {\n  if (hasLeadingOwnLineComment(options.originalText, argument, options)) {\n    return true;\n  }\n\n  if (hasNakedLeftSide(argument)) {\n    var leftMost = argument;\n    var newLeftMost;\n\n    while (newLeftMost = getLeftSide(leftMost)) {\n      leftMost = newLeftMost;\n\n      if (hasLeadingOwnLineComment(options.originalText, leftMost, options)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction isMemberExpressionChain(node) {\n  if (node.type !== \"MemberExpression\" && node.type !== \"OptionalMemberExpression\") {\n    return false;\n  }\n\n  if (node.object.type === \"Identifier\") {\n    return true;\n  }\n\n  return isMemberExpressionChain(node.object);\n} // Hack to differentiate between the following two which have the same ast\n// type T = { method: () => void };\n// type T = { method(): void };\n\n\nfunction isObjectTypePropertyAFunction(node, options) {\n  return (node.type === \"ObjectTypeProperty\" || node.type === \"ObjectTypeInternalSlot\") && node.value.type === \"FunctionTypeAnnotation\" && !node[\"static\"] && !isFunctionNotation(node, options);\n} // TODO: This is a bad hack and we need a better way to distinguish between\n// arrow functions and otherwise\n\n\nfunction isFunctionNotation(node, options) {\n  return isGetterOrSetter(node) || sameLocStart(node, node.value, options);\n}\n\nfunction isGetterOrSetter(node) {\n  return node.kind === \"get\" || node.kind === \"set\";\n}\n\nfunction sameLocStart(nodeA, nodeB, options) {\n  return options.locStart(nodeA) === options.locStart(nodeB);\n} // Hack to differentiate between the following two which have the same ast\n// declare function f(a): void;\n// var f: (a) => void;\n\n\nfunction isTypeAnnotationAFunction(node, options) {\n  return (node.type === \"TypeAnnotation\" || node.type === \"TSTypeAnnotation\") && node.typeAnnotation.type === \"FunctionTypeAnnotation\" && !node[\"static\"] && !sameLocStart(node, node.typeAnnotation, options);\n}\n\nfunction isNodeStartingWithDeclare(node, options) {\n  if (!(options.parser === \"flow\" || options.parser === \"typescript\")) {\n    return false;\n  }\n\n  return options.originalText.slice(0, options.locStart(node)).match(/declare[ \\t]*$/) || options.originalText.slice(node.range[0], node.range[1]).startsWith(\"declare \");\n}\n\nfunction shouldHugType(node) {\n  if (isSimpleFlowType(node) || isObjectType(node)) {\n    return true;\n  }\n\n  if (node.type === \"UnionTypeAnnotation\" || node.type === \"TSUnionType\") {\n    var voidCount = node.types.filter(function (n) {\n      return n.type === \"VoidTypeAnnotation\" || n.type === \"TSVoidKeyword\" || n.type === \"NullLiteralTypeAnnotation\" || n.type === \"TSNullKeyword\";\n    }).length;\n    var objectCount = node.types.filter(function (n) {\n      return n.type === \"ObjectTypeAnnotation\" || n.type === \"TSTypeLiteral\" || // This is a bit aggressive but captures Array<{x}>\n      n.type === \"GenericTypeAnnotation\" || n.type === \"TSTypeReference\";\n    }).length;\n\n    if (node.types.length - 1 === voidCount && objectCount > 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldHugArguments(fun) {\n  return fun && fun.params && fun.params.length === 1 && !fun.params[0].comments && (fun.params[0].type === \"ObjectPattern\" || fun.params[0].type === \"ArrayPattern\" || fun.params[0].type === \"Identifier\" && fun.params[0].typeAnnotation && (fun.params[0].typeAnnotation.type === \"TypeAnnotation\" || fun.params[0].typeAnnotation.type === \"TSTypeAnnotation\") && isObjectType(fun.params[0].typeAnnotation.typeAnnotation) || fun.params[0].type === \"FunctionTypeParam\" && isObjectType(fun.params[0].typeAnnotation) || fun.params[0].type === \"AssignmentPattern\" && (fun.params[0].left.type === \"ObjectPattern\" || fun.params[0].left.type === \"ArrayPattern\") && (fun.params[0].right.type === \"Identifier\" || fun.params[0].right.type === \"ObjectExpression\" && fun.params[0].right.properties.length === 0 || fun.params[0].right.type === \"ArrayExpression\" && fun.params[0].right.elements.length === 0)) && !fun.rest;\n}\n\nfunction templateLiteralHasNewLines(template) {\n  return template.quasis.some(function (quasi) {\n    return quasi.value.raw.includes(\"\\n\");\n  });\n}\n\nfunction isTemplateOnItsOwnLine(n, text, options) {\n  return (n.type === \"TemplateLiteral\" && templateLiteralHasNewLines(n) || n.type === \"TaggedTemplateExpression\" && templateLiteralHasNewLines(n.quasi)) && !hasNewline(text, options.locStart(n), {\n    backwards: true\n  });\n}\n\nfunction printArrayItems(path, options, printPath, print) {\n  var printedElements = [];\n  var separatorParts = [];\n  path.each(function (childPath) {\n    printedElements.push(concat(separatorParts));\n    printedElements.push(group(print(childPath)));\n    separatorParts = [\",\", line];\n\n    if (childPath.getValue() && isNextLineEmpty(options.originalText, childPath.getValue(), options)) {\n      separatorParts.push(softline);\n    }\n  }, printPath);\n  return concat(printedElements);\n}\n\nfunction hasDanglingComments(node) {\n  return node.comments && node.comments.some(function (comment) {\n    return !comment.leading && !comment.trailing;\n  });\n}\n\nfunction needsHardlineAfterDanglingComment(node) {\n  if (!node.comments) {\n    return false;\n  }\n\n  var lastDanglingComment = getLast(node.comments.filter(function (comment) {\n    return !comment.leading && !comment.trailing;\n  }));\n  return lastDanglingComment && !handleComments.isBlockComment(lastDanglingComment);\n}\n\nfunction isLiteral(node) {\n  return node.type === \"BooleanLiteral\" || node.type === \"DirectiveLiteral\" || node.type === \"Literal\" || node.type === \"NullLiteral\" || node.type === \"NumericLiteral\" || node.type === \"RegExpLiteral\" || node.type === \"StringLiteral\" || node.type === \"TemplateLiteral\" || node.type === \"TSTypeLiteral\" || node.type === \"JSXText\";\n}\n\nfunction isStringPropSafeToCoerceToIdentifier(node, options) {\n  return isStringLiteral(node.key) && isIdentifierName(node.key.value) && options.parser !== \"json\" && !(options.parser === \"typescript\" && node.type === \"ClassProperty\");\n}\n\nfunction isNumericLiteral(node) {\n  return node.type === \"NumericLiteral\" || node.type === \"Literal\" && typeof node.value === \"number\";\n}\n\nfunction isStringLiteral(node) {\n  return node.type === \"StringLiteral\" || node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\nfunction isObjectType(n) {\n  return n.type === \"ObjectTypeAnnotation\" || n.type === \"TSTypeLiteral\";\n}\n\nvar unitTestRe = /^(skip|[fx]?(it|describe|test))$/; // eg; `describe(\"some string\", (done) => {})`\n\nfunction isTestCall(n, parent) {\n  if (n.type !== \"CallExpression\") {\n    return false;\n  }\n\n  if (n.arguments.length === 1) {\n    if (isAngularTestWrapper(n) && parent && isTestCall(parent)) {\n      return isFunctionOrArrowExpression(n.arguments[0]);\n    }\n\n    if (isUnitTestSetUp(n)) {\n      return isAngularTestWrapper(n.arguments[0]);\n    }\n  } else if (n.arguments.length === 2 || n.arguments.length === 3) {\n    if ((n.callee.type === \"Identifier\" && unitTestRe.test(n.callee.name) || isSkipOrOnlyBlock(n)) && (isTemplateLiteral(n.arguments[0]) || isStringLiteral(n.arguments[0]))) {\n      // it(\"name\", () => { ... }, 2500)\n      if (n.arguments[2] && !isNumericLiteral(n.arguments[2])) {\n        return false;\n      }\n\n      return (n.arguments.length === 2 ? isFunctionOrArrowExpression(n.arguments[1]) : isFunctionOrArrowExpressionWithBody(n.arguments[1]) && n.arguments[1].params.length <= 1) || isAngularTestWrapper(n.arguments[1]);\n    }\n  }\n\n  return false;\n}\n\nfunction isSkipOrOnlyBlock(node) {\n  return (node.callee.type === \"MemberExpression\" || node.callee.type === \"OptionalMemberExpression\") && node.callee.object.type === \"Identifier\" && node.callee.property.type === \"Identifier\" && unitTestRe.test(node.callee.object.name) && (node.callee.property.name === \"only\" || node.callee.property.name === \"skip\");\n}\n\nfunction isTemplateLiteral(node) {\n  return node.type === \"TemplateLiteral\";\n} // `inject` is used in AngularJS 1.x, `async` in Angular 2+\n// example: https://docs.angularjs.org/guide/unit-testing#using-beforeall-\n\n\nfunction isAngularTestWrapper(node) {\n  return (node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\") && node.callee.type === \"Identifier\" && (node.callee.name === \"async\" || node.callee.name === \"inject\" || node.callee.name === \"fakeAsync\");\n}\n\nfunction isFunctionOrArrowExpression(node) {\n  return node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\n}\n\nfunction isFunctionOrArrowExpressionWithBody(node) {\n  return node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\" && node.body.type === \"BlockStatement\";\n}\n\nfunction isUnitTestSetUp(n) {\n  var unitTestSetUpRe = /^(before|after)(Each|All)$/;\n  return n.callee.type === \"Identifier\" && unitTestSetUpRe.test(n.callee.name) && n.arguments.length === 1;\n}\n\nfunction isTheOnlyJSXElementInMarkdown(options, path) {\n  if (options.parentParser !== \"markdown\" && options.parentParser !== \"mdx\") {\n    return false;\n  }\n\n  var node = path.getNode();\n\n  if (!node.expression || !isJSXNode(node.expression)) {\n    return false;\n  }\n\n  var parent = path.getParentNode();\n  return parent.type === \"Program\" && parent.body.length == 1;\n}\n\nfunction willPrintOwnComments(path\n/*, options */\n) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  return (node && (isJSXNode(node) || hasFlowShorthandAnnotationComment(node) || parent && parent.type === \"CallExpression\" && (hasFlowAnnotationComment(node.leadingComments) || hasFlowAnnotationComment(node.trailingComments))) || parent && (parent.type === \"JSXSpreadAttribute\" || parent.type === \"JSXSpreadChild\" || parent.type === \"UnionTypeAnnotation\" || parent.type === \"TSUnionType\" || (parent.type === \"ClassDeclaration\" || parent.type === \"ClassExpression\") && parent.superClass === node)) && !hasIgnoreComment(path);\n}\n\nfunction canAttachComment(node) {\n  return node.type && node.type !== \"CommentBlock\" && node.type !== \"CommentLine\" && node.type !== \"Line\" && node.type !== \"Block\" && node.type !== \"EmptyStatement\" && node.type !== \"TemplateElement\" && node.type !== \"Import\";\n}\n\nfunction printComment(commentPath, options) {\n  var comment = commentPath.getValue();\n\n  switch (comment.type) {\n    case \"CommentBlock\":\n    case \"Block\":\n      {\n        if (isIndentableBlockComment(comment)) {\n          var printed = printIndentableBlockComment(comment); // We need to prevent an edge case of a previous trailing comment\n          // printed as a `lineSuffix` which causes the comments to be\n          // interleaved. See https://github.com/prettier/prettier/issues/4412\n\n          if (comment.trailing && !hasNewline(options.originalText, options.locStart(comment), {\n            backwards: true\n          })) {\n            return concat([hardline, printed]);\n          }\n\n          return printed;\n        }\n\n        var isInsideFlowComment = options.originalText.substr(options.locEnd(comment) - 3, 3) === \"*-/\";\n        return \"/*\" + comment.value + (isInsideFlowComment ? \"*-/\" : \"*/\");\n      }\n\n    case \"CommentLine\":\n    case \"Line\":\n      // Print shebangs with the proper comment characters\n      if (options.originalText.slice(options.locStart(comment)).startsWith(\"#!\")) {\n        return \"#!\" + comment.value.trimRight();\n      }\n\n      return \"//\" + comment.value.trimRight();\n\n    default:\n      throw new Error(\"Not a comment: \" + JSON.stringify(comment));\n  }\n}\n\nfunction isIndentableBlockComment(comment) {\n  // If the comment has multiple lines and every line starts with a star\n  // we can fix the indentation of each line. The stars in the `/*` and\n  // `*/` delimiters are not included in the comment value, so add them\n  // back first.\n  var lines = \"*\".concat(comment.value, \"*\").split(\"\\n\");\n  return lines.length > 1 && lines.every(function (line) {\n    return line.trim()[0] === \"*\";\n  });\n}\n\nfunction printIndentableBlockComment(comment) {\n  var lines = comment.value.split(\"\\n\");\n  return concat([\"/*\", join(hardline, lines.map(function (line, index) {\n    return index === 0 ? line.trimRight() : \" \" + (index < lines.length - 1 ? line.trim() : line.trimLeft());\n  })), \"*/\"]);\n}\n\nfunction rawText(node) {\n  // our artifically created AST doesn't have extra property\n  //return node.extra ? node.extra.raw : node.raw;\n  return node.value;\n}\n\nfunction identity(x) {\n  return x;\n}\n\nmodule.exports = {\n  preprocess: preprocess,\n  print: genericPrint,\n  embed: embed,\n  insertPragma: insertPragma,\n  massageAstNode: clean,\n  hasPrettierIgnore: hasPrettierIgnore,\n  willPrintOwnComments: willPrintOwnComments,\n  canAttachComment: canAttachComment,\n  printComment: printComment,\n  isBlockComment: handleComments.isBlockComment,\n  handleComments: {\n    ownLine: handleComments.handleOwnLineComment,\n    endOfLine: handleComments.handleEndOfLineComment,\n    remaining: handleComments.handleRemainingComment\n  }\n};"]},"metadata":{},"sourceType":"script"}