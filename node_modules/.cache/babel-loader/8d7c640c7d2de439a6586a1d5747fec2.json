{"ast":null,"code":"\"use strict\";\n\nvar assert = require(\"assert\");\n\nvar util = require(\"../common/util\");\n\nvar comments = require(\"./comments\");\n\nvar _require = require(\"./utils\"),\n    getLeftSidePathName = _require.getLeftSidePathName,\n    hasNakedLeftSide = _require.hasNakedLeftSide,\n    hasFlowShorthandAnnotationComment = _require.hasFlowShorthandAnnotationComment;\n\nfunction hasClosureCompilerTypeCastComment(text, path) {\n  // https://github.com/google/closure-compiler/wiki/Annotating-Types#type-casts\n  // Syntax example: var x = /** @type {string} */ (fruit);\n  var n = path.getValue();\n  return isParenthesized(n) && (hasTypeCastComment(n) || hasAncestorTypeCastComment(0)); // for sub-item: /** @type {array} */ (numberOrString).map(x => x);\n\n  function hasAncestorTypeCastComment(index) {\n    var ancestor = path.getParentNode(index);\n    return ancestor && !isParenthesized(ancestor) ? hasTypeCastComment(ancestor) || hasAncestorTypeCastComment(index + 1) : false;\n  }\n\n  function hasTypeCastComment(node) {\n    return node.comments && node.comments.some(function (comment) {\n      return comment.leading && comments.isBlockComment(comment) && isTypeCastComment(comment.value);\n    });\n  }\n\n  function isParenthesized(node) {\n    // Closure typecast comments only really make sense when _not_ using\n    // typescript or flow parsers, so we take advantage of the babel parser's\n    // parenthesized expressions.\n    return node.extra && node.extra.parenthesized;\n  }\n\n  function isTypeCastComment(comment) {\n    var cleaned = comment.trim().split(\"\\n\").map(function (line) {\n      return line.replace(/^[\\s*]+/, \"\");\n    }).join(\" \").trim();\n\n    if (!/^@type\\s*\\{[^]+\\}$/.test(cleaned)) {\n      return false;\n    }\n\n    var isCompletelyClosed = false;\n    var unpairedBracketCount = 0;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = cleaned[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _char = _step.value;\n\n        if (_char === \"{\") {\n          if (isCompletelyClosed) {\n            return false;\n          }\n\n          unpairedBracketCount++;\n        } else if (_char === \"}\") {\n          if (unpairedBracketCount === 0) {\n            return false;\n          }\n\n          unpairedBracketCount--;\n\n          if (unpairedBracketCount === 0) {\n            isCompletelyClosed = true;\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return unpairedBracketCount === 0;\n  }\n}\n\nfunction needsParens(path, options) {\n  var parent = path.getParentNode();\n\n  if (!parent) {\n    return false;\n  }\n\n  var name = path.getName();\n  var node = path.getNode(); // If the value of this path is some child of a Node and not a Node\n  // itself, then it doesn't need parentheses. Only Node objects (in\n  // fact, only Expression nodes) need parentheses.\n\n  if (path.getValue() !== node) {\n    return false;\n  } // to avoid unexpected `}}` in HTML interpolations\n\n\n  if (options.__isInHtmlInterpolation && !options.bracketSpacing && endsWithRightBracket(node) && isFollowedByRightBracket(path)) {\n    return true;\n  } // Only statements don't need parentheses.\n\n\n  if (isStatement(node)) {\n    return false;\n  } // Closure compiler requires that type casted expressions to be surrounded by\n  // parentheses.\n\n\n  if (hasClosureCompilerTypeCastComment(options.originalText, path)) {\n    return true;\n  }\n\n  if ( // Preserve parens if we have a Flow annotation comment, unless we're using the Flow\n  // parser. The Flow parser turns Flow comments into type annotation nodes in its\n  // AST, which we handle separately.\n  options.parser !== \"flow\" && hasFlowShorthandAnnotationComment(path.getValue())) {\n    return true;\n  } // Identifiers never need parentheses.\n\n\n  if (node.type === \"Identifier\") {\n    // ...unless those identifiers are embed placeholders. They might be substituted by complex\n    // expressions, so the parens around them should not be dropped. Example (JS-in-HTML-in-JS):\n    //     let tpl = html`<script> f((${expr}) / 2); </script>`;\n    // If the inner JS formatter removes the parens, the expression might change its meaning:\n    //     f((a + b) / 2)  vs  f(a + b / 2)\n    if (node.extra && node.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(node.name)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (parent.type === \"ParenthesizedExpression\") {\n    return false;\n  } // Add parens around the extends clause of a class. It is needed for almost\n  // all expressions.\n\n\n  if ((parent.type === \"ClassDeclaration\" || parent.type === \"ClassExpression\") && parent.superClass === node && (node.type === \"ArrowFunctionExpression\" || node.type === \"AssignmentExpression\" || node.type === \"AwaitExpression\" || node.type === \"BinaryExpression\" || node.type === \"ConditionalExpression\" || node.type === \"LogicalExpression\" || node.type === \"NewExpression\" || node.type === \"ObjectExpression\" || node.type === \"ParenthesizedExpression\" || node.type === \"SequenceExpression\" || node.type === \"TaggedTemplateExpression\" || node.type === \"UnaryExpression\" || node.type === \"UpdateExpression\" || node.type === \"YieldExpression\")) {\n    return true;\n  } // `export default function` or `export default class` can't be followed by\n  // anything after. So an expression like `export default (function(){}).toString()`\n  // needs to be followed by a parentheses\n\n\n  if (parent.type === \"ExportDefaultDeclaration\") {\n    return shouldWrapFunctionForExportDefault(path, options);\n  }\n\n  if (parent.type === \"Decorator\" && parent.expression === node) {\n    var hasCallExpression = false;\n    var hasMemberExpression = false;\n    var current = node;\n\n    while (current) {\n      switch (current.type) {\n        case \"MemberExpression\":\n          hasMemberExpression = true;\n          current = current.object;\n          break;\n\n        case \"CallExpression\":\n          if (\n          /** @(x().y) */\n          hasMemberExpression ||\n          /** @(x().y()) */\n          hasCallExpression) {\n            return true;\n          }\n\n          hasCallExpression = true;\n          current = current.callee;\n          break;\n\n        case \"Identifier\":\n          return false;\n\n        default:\n          return true;\n      }\n    }\n\n    return true;\n  }\n\n  if (parent.type === \"ArrowFunctionExpression\" && parent.body === node && node.type !== \"SequenceExpression\" && // these have parens added anyway\n  util.startsWithNoLookaheadToken(node,\n  /* forbidFunctionClassAndDoExpr */\n  false) || parent.type === \"ExpressionStatement\" && util.startsWithNoLookaheadToken(node,\n  /* forbidFunctionClassAndDoExpr */\n  true)) {\n    return true;\n  }\n\n  switch (node.type) {\n    case \"SpreadElement\":\n    case \"SpreadProperty\":\n      return parent.type === \"MemberExpression\" && name === \"object\" && parent.object === node;\n\n    case \"UpdateExpression\":\n      if (parent.type === \"UnaryExpression\") {\n        return node.prefix && (node.operator === \"++\" && parent.operator === \"+\" || node.operator === \"--\" && parent.operator === \"-\");\n      }\n\n    // else fallthrough\n\n    case \"UnaryExpression\":\n      switch (parent.type) {\n        case \"UnaryExpression\":\n          return node.operator === parent.operator && (node.operator === \"+\" || node.operator === \"-\");\n\n        case \"BindExpression\":\n          return true;\n\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        case \"TaggedTemplateExpression\":\n          return true;\n\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"BinaryExpression\":\n          return parent.operator === \"**\" && name === \"left\";\n\n        case \"TSNonNullExpression\":\n          return true;\n\n        default:\n          return false;\n      }\n\n    case \"BinaryExpression\":\n      {\n        if (parent.type === \"UpdateExpression\") {\n          return true;\n        }\n\n        var isLeftOfAForStatement = function isLeftOfAForStatement(node) {\n          var i = 0;\n\n          while (node) {\n            var _parent = path.getParentNode(i++);\n\n            if (!_parent) {\n              return false;\n            }\n\n            if (_parent.type === \"ForStatement\" && _parent.init === node) {\n              return true;\n            }\n\n            node = _parent;\n          }\n\n          return false;\n        };\n\n        if (node.operator === \"in\" && isLeftOfAForStatement(node)) {\n          return true;\n        }\n      }\n    // fallthrough\n\n    case \"TSTypeAssertion\":\n    case \"TSAsExpression\":\n    case \"LogicalExpression\":\n      switch (parent.type) {\n        case \"ConditionalExpression\":\n          return node.type === \"TSAsExpression\";\n\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"ClassExpression\":\n        case \"ClassDeclaration\":\n          return name === \"superClass\" && parent.superClass === node;\n\n        case \"TSTypeAssertion\":\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"JSXSpreadAttribute\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"BindExpression\":\n        case \"AwaitExpression\":\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"UpdateExpression\":\n          return true;\n\n        case \"MemberExpression\":\n        case \"OptionalMemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        case \"AssignmentExpression\":\n          return parent.left === node && (node.type === \"TSTypeAssertion\" || node.type === \"TSAsExpression\");\n\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n          {\n            if (!node.operator && node.type !== \"TSTypeAssertion\") {\n              return true;\n            }\n\n            var po = parent.operator;\n            var pp = util.getPrecedence(po);\n            var no = node.operator;\n            var np = util.getPrecedence(no);\n\n            if (pp > np) {\n              return true;\n            }\n\n            if ((po === \"||\" || po === \"??\") && no === \"&&\") {\n              return true;\n            }\n\n            if (pp === np && name === \"right\") {\n              assert.strictEqual(parent.right, node);\n              return true;\n            }\n\n            if (pp === np && !util.shouldFlatten(po, no)) {\n              return true;\n            }\n\n            if (pp < np && no === \"%\") {\n              return po === \"+\" || po === \"-\";\n            } // Add parenthesis when working with bitwise operators\n            // It's not stricly needed but helps with code understanding\n\n\n            if (util.isBitwiseOperator(po)) {\n              return true;\n            }\n\n            return false;\n          }\n\n        default:\n          return false;\n      }\n\n    case \"TSParenthesizedType\":\n      {\n        var grandParent = path.getParentNode(1);\n        /**\n         * const foo = (): (() => void) => (): void => null;\n         *                 ^          ^\n         */\n\n        if (getUnparenthesizedNode(node).type === \"TSFunctionType\" && parent.type === \"TSTypeAnnotation\" && grandParent.type === \"ArrowFunctionExpression\" && grandParent.returnType === parent) {\n          return true;\n        }\n\n        if ((parent.type === \"TSTypeParameter\" || parent.type === \"TypeParameter\" || parent.type === \"TSTypeAliasDeclaration\" || parent.type === \"TSTypeAnnotation\" || parent.type === \"TSParenthesizedType\" || parent.type === \"TSTypeParameterInstantiation\") && grandParent.type !== \"TSTypeOperator\" && grandParent.type !== \"TSOptionalType\") {\n          return false;\n        } // Delegate to inner TSParenthesizedType\n\n\n        if (node.typeAnnotation.type === \"TSParenthesizedType\" && parent.type !== \"TSArrayType\") {\n          return false;\n        }\n\n        return true;\n      }\n\n    case \"SequenceExpression\":\n      switch (parent.type) {\n        case \"ReturnStatement\":\n          return false;\n\n        case \"ForStatement\":\n          // Although parentheses wouldn't hurt around sequence\n          // expressions in the head of for loops, traditional style\n          // dictates that e.g. i++, j++ should not be wrapped with\n          // parentheses.\n          return false;\n\n        case \"ExpressionStatement\":\n          return name !== \"expression\";\n\n        case \"ArrowFunctionExpression\":\n          // We do need parentheses, but SequenceExpressions are handled\n          // specially when printing bodies of arrow functions.\n          return name !== \"body\";\n\n        default:\n          // Otherwise err on the side of overparenthesization, adding\n          // explicit exceptions above if this proves overzealous.\n          return true;\n      }\n\n    case \"YieldExpression\":\n      if (parent.type === \"UnaryExpression\" || parent.type === \"AwaitExpression\" || parent.type === \"TSAsExpression\" || parent.type === \"TSNonNullExpression\") {\n        return true;\n      }\n\n    // else fallthrough\n\n    case \"AwaitExpression\":\n      switch (parent.type) {\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"BindExpression\":\n        case \"OptionalMemberExpression\":\n          return true;\n\n        case \"MemberExpression\":\n          return parent.object === node;\n\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return parent.callee === node;\n\n        case \"ConditionalExpression\":\n          return parent.test === node;\n\n        default:\n          return false;\n      }\n\n    case \"ArrayTypeAnnotation\":\n      return parent.type === \"NullableTypeAnnotation\";\n\n    case \"IntersectionTypeAnnotation\":\n    case \"UnionTypeAnnotation\":\n      return parent.type === \"ArrayTypeAnnotation\" || parent.type === \"NullableTypeAnnotation\" || parent.type === \"IntersectionTypeAnnotation\" || parent.type === \"UnionTypeAnnotation\";\n\n    case \"NullableTypeAnnotation\":\n      return parent.type === \"ArrayTypeAnnotation\";\n\n    case \"FunctionTypeAnnotation\":\n      {\n        var ancestor = parent.type === \"NullableTypeAnnotation\" ? path.getParentNode(1) : parent;\n        return ancestor.type === \"UnionTypeAnnotation\" || ancestor.type === \"IntersectionTypeAnnotation\" || ancestor.type === \"ArrayTypeAnnotation\" || // We should check ancestor's parent to know whether the parentheses\n        // are really needed, but since ??T doesn't make sense this check\n        // will almost never be true.\n        ancestor.type === \"NullableTypeAnnotation\";\n      }\n\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"Literal\":\n      if (typeof node.value === \"string\" && parent.type === \"ExpressionStatement\" && ( // TypeScript workaround for https://github.com/JamesHenry/typescript-estree/issues/2\n      // See corresponding workaround in printer.js case: \"Literal\"\n      options.parser !== \"typescript\" && !parent.directive || options.parser === \"typescript\" && options.originalText.substr(options.locStart(node) - 1, 1) === \"(\")) {\n        // To avoid becoming a directive\n        var _grandParent = path.getParentNode(1);\n\n        return _grandParent.type === \"Program\" || _grandParent.type === \"BlockStatement\";\n      }\n\n      return parent.type === \"MemberExpression\" && typeof node.value === \"number\" && name === \"object\" && parent.object === node;\n\n    case \"AssignmentExpression\":\n      {\n        var _grandParent2 = path.getParentNode(1);\n\n        if (parent.type === \"ArrowFunctionExpression\" && parent.body === node) {\n          return true;\n        } else if (parent.type === \"ClassProperty\" && parent.key === node && parent.computed) {\n          return false;\n        } else if (parent.type === \"TSPropertySignature\" && parent.name === node) {\n          return false;\n        } else if (parent.type === \"ForStatement\" && (parent.init === node || parent.update === node)) {\n          return false;\n        } else if (parent.type === \"ExpressionStatement\") {\n          return node.left.type === \"ObjectPattern\";\n        } else if (parent.type === \"TSPropertySignature\" && parent.key === node) {\n          return false;\n        } else if (parent.type === \"AssignmentExpression\") {\n          return false;\n        } else if (parent.type === \"SequenceExpression\" && _grandParent2 && _grandParent2.type === \"ForStatement\" && (_grandParent2.init === parent || _grandParent2.update === parent)) {\n          return false;\n        } else if (parent.type === \"Property\" && parent.value === node) {\n          return false;\n        } else if (parent.type === \"NGChainedExpression\") {\n          return false;\n        }\n\n        return true;\n      }\n\n    case \"ConditionalExpression\":\n      switch (parent.type) {\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n        case \"NGPipeExpression\":\n        case \"ExportDefaultDeclaration\":\n        case \"AwaitExpression\":\n        case \"JSXSpreadAttribute\":\n        case \"TSTypeAssertion\":\n        case \"TypeCastExpression\":\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"OptionalMemberExpression\":\n          return true;\n\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"ConditionalExpression\":\n          return name === \"test\" && parent.test === node;\n\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        default:\n          return false;\n      }\n\n    case \"FunctionExpression\":\n      switch (parent.type) {\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return name === \"callee\";\n        // Not strictly necessary, but it's clearer to the reader if IIFEs are wrapped in parentheses.\n\n        case \"TaggedTemplateExpression\":\n          return true;\n        // This is basically a kind of IIFE.\n\n        default:\n          return false;\n      }\n\n    case \"ArrowFunctionExpression\":\n      switch (parent.type) {\n        case \"CallExpression\":\n          return name === \"callee\";\n\n        case \"NewExpression\":\n          return name === \"callee\";\n\n        case \"MemberExpression\":\n          return name === \"object\";\n\n        case \"TSAsExpression\":\n        case \"BindExpression\":\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"LogicalExpression\":\n        case \"BinaryExpression\":\n        case \"AwaitExpression\":\n        case \"TSTypeAssertion\":\n          return true;\n\n        case \"ConditionalExpression\":\n          return name === \"test\";\n\n        default:\n          return false;\n      }\n\n    case \"ClassExpression\":\n      switch (parent.type) {\n        case \"NewExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        default:\n          return false;\n      }\n\n    case \"OptionalMemberExpression\":\n      return parent.type === \"MemberExpression\";\n\n    case \"CallExpression\":\n    case \"MemberExpression\":\n    case \"TaggedTemplateExpression\":\n    case \"TSNonNullExpression\":\n      if ((parent.type === \"BindExpression\" || parent.type === \"NewExpression\") && name === \"callee\" && parent.callee === node) {\n        var object = node;\n\n        while (object) {\n          switch (object.type) {\n            case \"CallExpression\":\n              return true;\n\n            case \"MemberExpression\":\n            case \"BindExpression\":\n              object = object.object;\n              break;\n            // tagged templates are basically member expressions from a grammar perspective\n            // see https://tc39.github.io/ecma262/#prod-MemberExpression\n\n            case \"TaggedTemplateExpression\":\n              object = object.tag;\n              break;\n\n            case \"TSNonNullExpression\":\n              object = object.expression;\n              break;\n\n            default:\n              return false;\n          }\n        }\n      }\n\n      return false;\n\n    case \"BindExpression\":\n      if (parent.type === \"BindExpression\" && name === \"callee\" && parent.callee === node || parent.type === \"MemberExpression\" && name === \"object\" && parent.object === node || parent.type === \"NewExpression\" && name === \"callee\" && parent.callee === node) {\n        return true;\n      }\n\n      return false;\n\n    case \"NGPipeExpression\":\n      if (parent.type === \"NGRoot\" || parent.type === \"NGMicrosyntaxExpression\" || parent.type === \"ObjectProperty\" || parent.type === \"ArrayExpression\" || (parent.type === \"CallExpression\" || parent.type === \"OptionalCallExpression\") && parent.arguments[name] === node || parent.type === \"NGPipeExpression\" && name === \"right\" || parent.type === \"MemberExpression\" && name === \"property\" || parent.type === \"AssignmentExpression\") {\n        return false;\n      }\n\n      return true;\n  }\n\n  return false;\n}\n\nfunction isStatement(node) {\n  return node.type === \"BlockStatement\" || node.type === \"BreakStatement\" || node.type === \"ClassBody\" || node.type === \"ClassDeclaration\" || node.type === \"ClassMethod\" || node.type === \"ClassProperty\" || node.type === \"ClassPrivateProperty\" || node.type === \"ContinueStatement\" || node.type === \"DebuggerStatement\" || node.type === \"DeclareClass\" || node.type === \"DeclareExportAllDeclaration\" || node.type === \"DeclareExportDeclaration\" || node.type === \"DeclareFunction\" || node.type === \"DeclareInterface\" || node.type === \"DeclareModule\" || node.type === \"DeclareModuleExports\" || node.type === \"DeclareVariable\" || node.type === \"DoWhileStatement\" || node.type === \"ExportAllDeclaration\" || node.type === \"ExportDefaultDeclaration\" || node.type === \"ExportNamedDeclaration\" || node.type === \"ExpressionStatement\" || node.type === \"ForAwaitStatement\" || node.type === \"ForInStatement\" || node.type === \"ForOfStatement\" || node.type === \"ForStatement\" || node.type === \"FunctionDeclaration\" || node.type === \"IfStatement\" || node.type === \"ImportDeclaration\" || node.type === \"InterfaceDeclaration\" || node.type === \"LabeledStatement\" || node.type === \"MethodDefinition\" || node.type === \"ReturnStatement\" || node.type === \"SwitchStatement\" || node.type === \"ThrowStatement\" || node.type === \"TryStatement\" || node.type === \"TSDeclareFunction\" || node.type === \"TSEnumDeclaration\" || node.type === \"TSImportEqualsDeclaration\" || node.type === \"TSInterfaceDeclaration\" || node.type === \"TSModuleDeclaration\" || node.type === \"TSNamespaceExportDeclaration\" || node.type === \"TypeAlias\" || node.type === \"VariableDeclaration\" || node.type === \"WhileStatement\" || node.type === \"WithStatement\";\n}\n\nfunction getUnparenthesizedNode(node) {\n  return node.type === \"TSParenthesizedType\" ? getUnparenthesizedNode(node.typeAnnotation) : node;\n}\n\nfunction endsWithRightBracket(node) {\n  switch (node.type) {\n    case \"ObjectExpression\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction isFollowedByRightBracket(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  var name = path.getName();\n\n  switch (parent.type) {\n    case \"NGPipeExpression\":\n      if (typeof name === \"number\" && parent.arguments[name] === node && parent.arguments.length - 1 === name) {\n        return path.callParent(isFollowedByRightBracket);\n      }\n\n      break;\n\n    case \"ObjectProperty\":\n      if (name === \"value\") {\n        var parentParent = path.getParentNode(1);\n        return parentParent.properties[parentParent.properties.length - 1] === parent;\n      }\n\n      break;\n\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n      if (name === \"right\") {\n        return path.callParent(isFollowedByRightBracket);\n      }\n\n      break;\n\n    case \"ConditionalExpression\":\n      if (name === \"alternate\") {\n        return path.callParent(isFollowedByRightBracket);\n      }\n\n      break;\n\n    case \"UnaryExpression\":\n      if (parent.prefix) {\n        return path.callParent(isFollowedByRightBracket);\n      }\n\n      break;\n  }\n\n  return false;\n}\n\nfunction shouldWrapFunctionForExportDefault(path, options) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n\n  if (node.type === \"FunctionExpression\" || node.type === \"ClassExpression\") {\n    return parent.type === \"ExportDefaultDeclaration\" || // in some cases the function is already wrapped\n    // (e.g. `export default (function() {})();`)\n    // in this case we don't need to add extra parens\n    !needsParens(path, options);\n  }\n\n  if (!hasNakedLeftSide(node) || parent.type !== \"ExportDefaultDeclaration\" && needsParens(path, options)) {\n    return false;\n  }\n\n  return path.call.apply(path, [function (childPath) {\n    return shouldWrapFunctionForExportDefault(childPath, options);\n  }].concat(getLeftSidePathName(path, node)));\n}\n\nmodule.exports = needsParens;","map":{"version":3,"sources":["/Users/pranamyavadlamani/Desktop/Research/PortFolio/portfolio-site/node_modules/@miksu/prettier/lib/language-js/needs-parens.js"],"names":["assert","require","util","comments","_require","getLeftSidePathName","hasNakedLeftSide","hasFlowShorthandAnnotationComment","hasClosureCompilerTypeCastComment","text","path","n","getValue","isParenthesized","hasTypeCastComment","hasAncestorTypeCastComment","index","ancestor","getParentNode","node","some","comment","leading","isBlockComment","isTypeCastComment","value","extra","parenthesized","cleaned","trim","split","map","line","replace","join","test","isCompletelyClosed","unpairedBracketCount","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","_char","err","needsParens","options","parent","name","getName","getNode","__isInHtmlInterpolation","bracketSpacing","endsWithRightBracket","isFollowedByRightBracket","isStatement","originalText","parser","type","superClass","shouldWrapFunctionForExportDefault","expression","hasCallExpression","hasMemberExpression","current","object","callee","body","startsWithNoLookaheadToken","prefix","operator","isLeftOfAForStatement","i","_parent","init","left","po","pp","getPrecedence","no","np","strictEqual","right","shouldFlatten","isBitwiseOperator","grandParent","getUnparenthesizedNode","returnType","typeAnnotation","directive","substr","locStart","_grandParent","_grandParent2","key","computed","update","tag","arguments","length","callParent","parentParent","properties","call","apply","childPath","concat","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar assert = require(\"assert\");\n\nvar util = require(\"../common/util\");\n\nvar comments = require(\"./comments\");\n\nvar _require = require(\"./utils\"),\n    getLeftSidePathName = _require.getLeftSidePathName,\n    hasNakedLeftSide = _require.hasNakedLeftSide,\n    hasFlowShorthandAnnotationComment = _require.hasFlowShorthandAnnotationComment;\n\nfunction hasClosureCompilerTypeCastComment(text, path) {\n  // https://github.com/google/closure-compiler/wiki/Annotating-Types#type-casts\n  // Syntax example: var x = /** @type {string} */ (fruit);\n  var n = path.getValue();\n  return isParenthesized(n) && (hasTypeCastComment(n) || hasAncestorTypeCastComment(0)); // for sub-item: /** @type {array} */ (numberOrString).map(x => x);\n\n  function hasAncestorTypeCastComment(index) {\n    var ancestor = path.getParentNode(index);\n    return ancestor && !isParenthesized(ancestor) ? hasTypeCastComment(ancestor) || hasAncestorTypeCastComment(index + 1) : false;\n  }\n\n  function hasTypeCastComment(node) {\n    return node.comments && node.comments.some(function (comment) {\n      return comment.leading && comments.isBlockComment(comment) && isTypeCastComment(comment.value);\n    });\n  }\n\n  function isParenthesized(node) {\n    // Closure typecast comments only really make sense when _not_ using\n    // typescript or flow parsers, so we take advantage of the babel parser's\n    // parenthesized expressions.\n    return node.extra && node.extra.parenthesized;\n  }\n\n  function isTypeCastComment(comment) {\n    var cleaned = comment.trim().split(\"\\n\").map(function (line) {\n      return line.replace(/^[\\s*]+/, \"\");\n    }).join(\" \").trim();\n\n    if (!/^@type\\s*\\{[^]+\\}$/.test(cleaned)) {\n      return false;\n    }\n\n    var isCompletelyClosed = false;\n    var unpairedBracketCount = 0;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = cleaned[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _char = _step.value;\n\n        if (_char === \"{\") {\n          if (isCompletelyClosed) {\n            return false;\n          }\n\n          unpairedBracketCount++;\n        } else if (_char === \"}\") {\n          if (unpairedBracketCount === 0) {\n            return false;\n          }\n\n          unpairedBracketCount--;\n\n          if (unpairedBracketCount === 0) {\n            isCompletelyClosed = true;\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return unpairedBracketCount === 0;\n  }\n}\n\nfunction needsParens(path, options) {\n  var parent = path.getParentNode();\n\n  if (!parent) {\n    return false;\n  }\n\n  var name = path.getName();\n  var node = path.getNode(); // If the value of this path is some child of a Node and not a Node\n  // itself, then it doesn't need parentheses. Only Node objects (in\n  // fact, only Expression nodes) need parentheses.\n\n  if (path.getValue() !== node) {\n    return false;\n  } // to avoid unexpected `}}` in HTML interpolations\n\n\n  if (options.__isInHtmlInterpolation && !options.bracketSpacing && endsWithRightBracket(node) && isFollowedByRightBracket(path)) {\n    return true;\n  } // Only statements don't need parentheses.\n\n\n  if (isStatement(node)) {\n    return false;\n  } // Closure compiler requires that type casted expressions to be surrounded by\n  // parentheses.\n\n\n  if (hasClosureCompilerTypeCastComment(options.originalText, path)) {\n    return true;\n  }\n\n  if ( // Preserve parens if we have a Flow annotation comment, unless we're using the Flow\n  // parser. The Flow parser turns Flow comments into type annotation nodes in its\n  // AST, which we handle separately.\n  options.parser !== \"flow\" && hasFlowShorthandAnnotationComment(path.getValue())) {\n    return true;\n  } // Identifiers never need parentheses.\n\n\n  if (node.type === \"Identifier\") {\n    // ...unless those identifiers are embed placeholders. They might be substituted by complex\n    // expressions, so the parens around them should not be dropped. Example (JS-in-HTML-in-JS):\n    //     let tpl = html`<script> f((${expr}) / 2); </script>`;\n    // If the inner JS formatter removes the parens, the expression might change its meaning:\n    //     f((a + b) / 2)  vs  f(a + b / 2)\n    if (node.extra && node.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(node.name)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (parent.type === \"ParenthesizedExpression\") {\n    return false;\n  } // Add parens around the extends clause of a class. It is needed for almost\n  // all expressions.\n\n\n  if ((parent.type === \"ClassDeclaration\" || parent.type === \"ClassExpression\") && parent.superClass === node && (node.type === \"ArrowFunctionExpression\" || node.type === \"AssignmentExpression\" || node.type === \"AwaitExpression\" || node.type === \"BinaryExpression\" || node.type === \"ConditionalExpression\" || node.type === \"LogicalExpression\" || node.type === \"NewExpression\" || node.type === \"ObjectExpression\" || node.type === \"ParenthesizedExpression\" || node.type === \"SequenceExpression\" || node.type === \"TaggedTemplateExpression\" || node.type === \"UnaryExpression\" || node.type === \"UpdateExpression\" || node.type === \"YieldExpression\")) {\n    return true;\n  } // `export default function` or `export default class` can't be followed by\n  // anything after. So an expression like `export default (function(){}).toString()`\n  // needs to be followed by a parentheses\n\n\n  if (parent.type === \"ExportDefaultDeclaration\") {\n    return shouldWrapFunctionForExportDefault(path, options);\n  }\n\n  if (parent.type === \"Decorator\" && parent.expression === node) {\n    var hasCallExpression = false;\n    var hasMemberExpression = false;\n    var current = node;\n\n    while (current) {\n      switch (current.type) {\n        case \"MemberExpression\":\n          hasMemberExpression = true;\n          current = current.object;\n          break;\n\n        case \"CallExpression\":\n          if (\n          /** @(x().y) */\n          hasMemberExpression ||\n          /** @(x().y()) */\n          hasCallExpression) {\n            return true;\n          }\n\n          hasCallExpression = true;\n          current = current.callee;\n          break;\n\n        case \"Identifier\":\n          return false;\n\n        default:\n          return true;\n      }\n    }\n\n    return true;\n  }\n\n  if (parent.type === \"ArrowFunctionExpression\" && parent.body === node && node.type !== \"SequenceExpression\" && // these have parens added anyway\n  util.startsWithNoLookaheadToken(node,\n  /* forbidFunctionClassAndDoExpr */\n  false) || parent.type === \"ExpressionStatement\" && util.startsWithNoLookaheadToken(node,\n  /* forbidFunctionClassAndDoExpr */\n  true)) {\n    return true;\n  }\n\n  switch (node.type) {\n    case \"SpreadElement\":\n    case \"SpreadProperty\":\n      return parent.type === \"MemberExpression\" && name === \"object\" && parent.object === node;\n\n    case \"UpdateExpression\":\n      if (parent.type === \"UnaryExpression\") {\n        return node.prefix && (node.operator === \"++\" && parent.operator === \"+\" || node.operator === \"--\" && parent.operator === \"-\");\n      }\n\n    // else fallthrough\n\n    case \"UnaryExpression\":\n      switch (parent.type) {\n        case \"UnaryExpression\":\n          return node.operator === parent.operator && (node.operator === \"+\" || node.operator === \"-\");\n\n        case \"BindExpression\":\n          return true;\n\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        case \"TaggedTemplateExpression\":\n          return true;\n\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"BinaryExpression\":\n          return parent.operator === \"**\" && name === \"left\";\n\n        case \"TSNonNullExpression\":\n          return true;\n\n        default:\n          return false;\n      }\n\n    case \"BinaryExpression\":\n      {\n        if (parent.type === \"UpdateExpression\") {\n          return true;\n        }\n\n        var isLeftOfAForStatement = function isLeftOfAForStatement(node) {\n          var i = 0;\n\n          while (node) {\n            var _parent = path.getParentNode(i++);\n\n            if (!_parent) {\n              return false;\n            }\n\n            if (_parent.type === \"ForStatement\" && _parent.init === node) {\n              return true;\n            }\n\n            node = _parent;\n          }\n\n          return false;\n        };\n\n        if (node.operator === \"in\" && isLeftOfAForStatement(node)) {\n          return true;\n        }\n      }\n    // fallthrough\n\n    case \"TSTypeAssertion\":\n    case \"TSAsExpression\":\n    case \"LogicalExpression\":\n      switch (parent.type) {\n        case \"ConditionalExpression\":\n          return node.type === \"TSAsExpression\";\n\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"ClassExpression\":\n        case \"ClassDeclaration\":\n          return name === \"superClass\" && parent.superClass === node;\n\n        case \"TSTypeAssertion\":\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"JSXSpreadAttribute\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"BindExpression\":\n        case \"AwaitExpression\":\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"UpdateExpression\":\n          return true;\n\n        case \"MemberExpression\":\n        case \"OptionalMemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        case \"AssignmentExpression\":\n          return parent.left === node && (node.type === \"TSTypeAssertion\" || node.type === \"TSAsExpression\");\n\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n          {\n            if (!node.operator && node.type !== \"TSTypeAssertion\") {\n              return true;\n            }\n\n            var po = parent.operator;\n            var pp = util.getPrecedence(po);\n            var no = node.operator;\n            var np = util.getPrecedence(no);\n\n            if (pp > np) {\n              return true;\n            }\n\n            if ((po === \"||\" || po === \"??\") && no === \"&&\") {\n              return true;\n            }\n\n            if (pp === np && name === \"right\") {\n              assert.strictEqual(parent.right, node);\n              return true;\n            }\n\n            if (pp === np && !util.shouldFlatten(po, no)) {\n              return true;\n            }\n\n            if (pp < np && no === \"%\") {\n              return po === \"+\" || po === \"-\";\n            } // Add parenthesis when working with bitwise operators\n            // It's not stricly needed but helps with code understanding\n\n\n            if (util.isBitwiseOperator(po)) {\n              return true;\n            }\n\n            return false;\n          }\n\n        default:\n          return false;\n      }\n\n    case \"TSParenthesizedType\":\n      {\n        var grandParent = path.getParentNode(1);\n        /**\n         * const foo = (): (() => void) => (): void => null;\n         *                 ^          ^\n         */\n\n        if (getUnparenthesizedNode(node).type === \"TSFunctionType\" && parent.type === \"TSTypeAnnotation\" && grandParent.type === \"ArrowFunctionExpression\" && grandParent.returnType === parent) {\n          return true;\n        }\n\n        if ((parent.type === \"TSTypeParameter\" || parent.type === \"TypeParameter\" || parent.type === \"TSTypeAliasDeclaration\" || parent.type === \"TSTypeAnnotation\" || parent.type === \"TSParenthesizedType\" || parent.type === \"TSTypeParameterInstantiation\") && grandParent.type !== \"TSTypeOperator\" && grandParent.type !== \"TSOptionalType\") {\n          return false;\n        } // Delegate to inner TSParenthesizedType\n\n\n        if (node.typeAnnotation.type === \"TSParenthesizedType\" && parent.type !== \"TSArrayType\") {\n          return false;\n        }\n\n        return true;\n      }\n\n    case \"SequenceExpression\":\n      switch (parent.type) {\n        case \"ReturnStatement\":\n          return false;\n\n        case \"ForStatement\":\n          // Although parentheses wouldn't hurt around sequence\n          // expressions in the head of for loops, traditional style\n          // dictates that e.g. i++, j++ should not be wrapped with\n          // parentheses.\n          return false;\n\n        case \"ExpressionStatement\":\n          return name !== \"expression\";\n\n        case \"ArrowFunctionExpression\":\n          // We do need parentheses, but SequenceExpressions are handled\n          // specially when printing bodies of arrow functions.\n          return name !== \"body\";\n\n        default:\n          // Otherwise err on the side of overparenthesization, adding\n          // explicit exceptions above if this proves overzealous.\n          return true;\n      }\n\n    case \"YieldExpression\":\n      if (parent.type === \"UnaryExpression\" || parent.type === \"AwaitExpression\" || parent.type === \"TSAsExpression\" || parent.type === \"TSNonNullExpression\") {\n        return true;\n      }\n\n    // else fallthrough\n\n    case \"AwaitExpression\":\n      switch (parent.type) {\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"BindExpression\":\n        case \"OptionalMemberExpression\":\n          return true;\n\n        case \"MemberExpression\":\n          return parent.object === node;\n\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return parent.callee === node;\n\n        case \"ConditionalExpression\":\n          return parent.test === node;\n\n        default:\n          return false;\n      }\n\n    case \"ArrayTypeAnnotation\":\n      return parent.type === \"NullableTypeAnnotation\";\n\n    case \"IntersectionTypeAnnotation\":\n    case \"UnionTypeAnnotation\":\n      return parent.type === \"ArrayTypeAnnotation\" || parent.type === \"NullableTypeAnnotation\" || parent.type === \"IntersectionTypeAnnotation\" || parent.type === \"UnionTypeAnnotation\";\n\n    case \"NullableTypeAnnotation\":\n      return parent.type === \"ArrayTypeAnnotation\";\n\n    case \"FunctionTypeAnnotation\":\n      {\n        var ancestor = parent.type === \"NullableTypeAnnotation\" ? path.getParentNode(1) : parent;\n        return ancestor.type === \"UnionTypeAnnotation\" || ancestor.type === \"IntersectionTypeAnnotation\" || ancestor.type === \"ArrayTypeAnnotation\" || // We should check ancestor's parent to know whether the parentheses\n        // are really needed, but since ??T doesn't make sense this check\n        // will almost never be true.\n        ancestor.type === \"NullableTypeAnnotation\";\n      }\n\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"Literal\":\n      if (typeof node.value === \"string\" && parent.type === \"ExpressionStatement\" && ( // TypeScript workaround for https://github.com/JamesHenry/typescript-estree/issues/2\n      // See corresponding workaround in printer.js case: \"Literal\"\n      options.parser !== \"typescript\" && !parent.directive || options.parser === \"typescript\" && options.originalText.substr(options.locStart(node) - 1, 1) === \"(\")) {\n        // To avoid becoming a directive\n        var _grandParent = path.getParentNode(1);\n\n        return _grandParent.type === \"Program\" || _grandParent.type === \"BlockStatement\";\n      }\n\n      return parent.type === \"MemberExpression\" && typeof node.value === \"number\" && name === \"object\" && parent.object === node;\n\n    case \"AssignmentExpression\":\n      {\n        var _grandParent2 = path.getParentNode(1);\n\n        if (parent.type === \"ArrowFunctionExpression\" && parent.body === node) {\n          return true;\n        } else if (parent.type === \"ClassProperty\" && parent.key === node && parent.computed) {\n          return false;\n        } else if (parent.type === \"TSPropertySignature\" && parent.name === node) {\n          return false;\n        } else if (parent.type === \"ForStatement\" && (parent.init === node || parent.update === node)) {\n          return false;\n        } else if (parent.type === \"ExpressionStatement\") {\n          return node.left.type === \"ObjectPattern\";\n        } else if (parent.type === \"TSPropertySignature\" && parent.key === node) {\n          return false;\n        } else if (parent.type === \"AssignmentExpression\") {\n          return false;\n        } else if (parent.type === \"SequenceExpression\" && _grandParent2 && _grandParent2.type === \"ForStatement\" && (_grandParent2.init === parent || _grandParent2.update === parent)) {\n          return false;\n        } else if (parent.type === \"Property\" && parent.value === node) {\n          return false;\n        } else if (parent.type === \"NGChainedExpression\") {\n          return false;\n        }\n\n        return true;\n      }\n\n    case \"ConditionalExpression\":\n      switch (parent.type) {\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n        case \"NGPipeExpression\":\n        case \"ExportDefaultDeclaration\":\n        case \"AwaitExpression\":\n        case \"JSXSpreadAttribute\":\n        case \"TSTypeAssertion\":\n        case \"TypeCastExpression\":\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"OptionalMemberExpression\":\n          return true;\n\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"ConditionalExpression\":\n          return name === \"test\" && parent.test === node;\n\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        default:\n          return false;\n      }\n\n    case \"FunctionExpression\":\n      switch (parent.type) {\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return name === \"callee\";\n        // Not strictly necessary, but it's clearer to the reader if IIFEs are wrapped in parentheses.\n\n        case \"TaggedTemplateExpression\":\n          return true;\n        // This is basically a kind of IIFE.\n\n        default:\n          return false;\n      }\n\n    case \"ArrowFunctionExpression\":\n      switch (parent.type) {\n        case \"CallExpression\":\n          return name === \"callee\";\n\n        case \"NewExpression\":\n          return name === \"callee\";\n\n        case \"MemberExpression\":\n          return name === \"object\";\n\n        case \"TSAsExpression\":\n        case \"BindExpression\":\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"LogicalExpression\":\n        case \"BinaryExpression\":\n        case \"AwaitExpression\":\n        case \"TSTypeAssertion\":\n          return true;\n\n        case \"ConditionalExpression\":\n          return name === \"test\";\n\n        default:\n          return false;\n      }\n\n    case \"ClassExpression\":\n      switch (parent.type) {\n        case \"NewExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        default:\n          return false;\n      }\n\n    case \"OptionalMemberExpression\":\n      return parent.type === \"MemberExpression\";\n\n    case \"CallExpression\":\n    case \"MemberExpression\":\n    case \"TaggedTemplateExpression\":\n    case \"TSNonNullExpression\":\n      if ((parent.type === \"BindExpression\" || parent.type === \"NewExpression\") && name === \"callee\" && parent.callee === node) {\n        var object = node;\n\n        while (object) {\n          switch (object.type) {\n            case \"CallExpression\":\n              return true;\n\n            case \"MemberExpression\":\n            case \"BindExpression\":\n              object = object.object;\n              break;\n            // tagged templates are basically member expressions from a grammar perspective\n            // see https://tc39.github.io/ecma262/#prod-MemberExpression\n\n            case \"TaggedTemplateExpression\":\n              object = object.tag;\n              break;\n\n            case \"TSNonNullExpression\":\n              object = object.expression;\n              break;\n\n            default:\n              return false;\n          }\n        }\n      }\n\n      return false;\n\n    case \"BindExpression\":\n      if (parent.type === \"BindExpression\" && name === \"callee\" && parent.callee === node || parent.type === \"MemberExpression\" && name === \"object\" && parent.object === node || parent.type === \"NewExpression\" && name === \"callee\" && parent.callee === node) {\n        return true;\n      }\n\n      return false;\n\n    case \"NGPipeExpression\":\n      if (parent.type === \"NGRoot\" || parent.type === \"NGMicrosyntaxExpression\" || parent.type === \"ObjectProperty\" || parent.type === \"ArrayExpression\" || (parent.type === \"CallExpression\" || parent.type === \"OptionalCallExpression\") && parent.arguments[name] === node || parent.type === \"NGPipeExpression\" && name === \"right\" || parent.type === \"MemberExpression\" && name === \"property\" || parent.type === \"AssignmentExpression\") {\n        return false;\n      }\n\n      return true;\n  }\n\n  return false;\n}\n\nfunction isStatement(node) {\n  return node.type === \"BlockStatement\" || node.type === \"BreakStatement\" || node.type === \"ClassBody\" || node.type === \"ClassDeclaration\" || node.type === \"ClassMethod\" || node.type === \"ClassProperty\" || node.type === \"ClassPrivateProperty\" || node.type === \"ContinueStatement\" || node.type === \"DebuggerStatement\" || node.type === \"DeclareClass\" || node.type === \"DeclareExportAllDeclaration\" || node.type === \"DeclareExportDeclaration\" || node.type === \"DeclareFunction\" || node.type === \"DeclareInterface\" || node.type === \"DeclareModule\" || node.type === \"DeclareModuleExports\" || node.type === \"DeclareVariable\" || node.type === \"DoWhileStatement\" || node.type === \"ExportAllDeclaration\" || node.type === \"ExportDefaultDeclaration\" || node.type === \"ExportNamedDeclaration\" || node.type === \"ExpressionStatement\" || node.type === \"ForAwaitStatement\" || node.type === \"ForInStatement\" || node.type === \"ForOfStatement\" || node.type === \"ForStatement\" || node.type === \"FunctionDeclaration\" || node.type === \"IfStatement\" || node.type === \"ImportDeclaration\" || node.type === \"InterfaceDeclaration\" || node.type === \"LabeledStatement\" || node.type === \"MethodDefinition\" || node.type === \"ReturnStatement\" || node.type === \"SwitchStatement\" || node.type === \"ThrowStatement\" || node.type === \"TryStatement\" || node.type === \"TSDeclareFunction\" || node.type === \"TSEnumDeclaration\" || node.type === \"TSImportEqualsDeclaration\" || node.type === \"TSInterfaceDeclaration\" || node.type === \"TSModuleDeclaration\" || node.type === \"TSNamespaceExportDeclaration\" || node.type === \"TypeAlias\" || node.type === \"VariableDeclaration\" || node.type === \"WhileStatement\" || node.type === \"WithStatement\";\n}\n\nfunction getUnparenthesizedNode(node) {\n  return node.type === \"TSParenthesizedType\" ? getUnparenthesizedNode(node.typeAnnotation) : node;\n}\n\nfunction endsWithRightBracket(node) {\n  switch (node.type) {\n    case \"ObjectExpression\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction isFollowedByRightBracket(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  var name = path.getName();\n\n  switch (parent.type) {\n    case \"NGPipeExpression\":\n      if (typeof name === \"number\" && parent.arguments[name] === node && parent.arguments.length - 1 === name) {\n        return path.callParent(isFollowedByRightBracket);\n      }\n\n      break;\n\n    case \"ObjectProperty\":\n      if (name === \"value\") {\n        var parentParent = path.getParentNode(1);\n        return parentParent.properties[parentParent.properties.length - 1] === parent;\n      }\n\n      break;\n\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n      if (name === \"right\") {\n        return path.callParent(isFollowedByRightBracket);\n      }\n\n      break;\n\n    case \"ConditionalExpression\":\n      if (name === \"alternate\") {\n        return path.callParent(isFollowedByRightBracket);\n      }\n\n      break;\n\n    case \"UnaryExpression\":\n      if (parent.prefix) {\n        return path.callParent(isFollowedByRightBracket);\n      }\n\n      break;\n  }\n\n  return false;\n}\n\nfunction shouldWrapFunctionForExportDefault(path, options) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n\n  if (node.type === \"FunctionExpression\" || node.type === \"ClassExpression\") {\n    return parent.type === \"ExportDefaultDeclaration\" || // in some cases the function is already wrapped\n    // (e.g. `export default (function() {})();`)\n    // in this case we don't need to add extra parens\n    !needsParens(path, options);\n  }\n\n  if (!hasNakedLeftSide(node) || parent.type !== \"ExportDefaultDeclaration\" && needsParens(path, options)) {\n    return false;\n  }\n\n  return path.call.apply(path, [function (childPath) {\n    return shouldWrapFunctionForExportDefault(childPath, options);\n  }].concat(getLeftSidePathName(path, node)));\n}\n\nmodule.exports = needsParens;"]},"metadata":{},"sourceType":"script"}