{"ast":null,"code":"\"use strict\";\n\nvar _require = require(\"../common/util\"),\n    getStringWidth = _require.getStringWidth;\n\nvar _require2 = require(\"../common/end-of-line\"),\n    convertEndOfLineToChars = _require2.convertEndOfLineToChars;\n\nvar _require3 = require(\"./doc-builders\"),\n    concat = _require3.concat,\n    fill = _require3.fill,\n    cursor = _require3.cursor;\n/** @type {{[groupId: PropertyKey]: MODE}} */\n\n\nvar groupModeMap;\nvar MODE_BREAK = 1;\nvar MODE_FLAT = 2;\n\nfunction rootIndent() {\n  return {\n    value: \"\",\n    length: 0,\n    queue: []\n  };\n}\n\nfunction makeIndent(ind, options) {\n  return generateInd(ind, {\n    type: \"indent\"\n  }, options);\n}\n\nfunction makeAlign(ind, n, options) {\n  return n === -Infinity ? ind.root || rootIndent() : n < 0 ? generateInd(ind, {\n    type: \"dedent\"\n  }, options) : !n ? ind : n.type === \"root\" ? Object.assign({}, ind, {\n    root: ind\n  }) : typeof n === \"string\" ? generateInd(ind, {\n    type: \"stringAlign\",\n    n: n\n  }, options) : generateInd(ind, {\n    type: \"numberAlign\",\n    n: n\n  }, options);\n}\n\nfunction generateInd(ind, newPart, options) {\n  var queue = newPart.type === \"dedent\" ? ind.queue.slice(0, -1) : ind.queue.concat(newPart);\n  var value = \"\";\n  var length = 0;\n  var lastTabs = 0;\n  var lastSpaces = 0;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = queue[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var part = _step.value;\n\n      switch (part.type) {\n        case \"indent\":\n          flush();\n\n          if (options.useTabs) {\n            addTabs(1);\n          } else {\n            addSpaces(options.tabWidth);\n          }\n\n          break;\n\n        case \"stringAlign\":\n          flush();\n          value += part.n;\n          length += part.n.length;\n          break;\n\n        case \"numberAlign\":\n          lastTabs += 1;\n          lastSpaces += part.n;\n          break;\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error(\"Unexpected type '\".concat(part.type, \"'\"));\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  flushSpaces();\n  return Object.assign({}, ind, {\n    value: value,\n    length: length,\n    queue: queue\n  });\n\n  function addTabs(count) {\n    value += \"\\t\".repeat(count);\n    length += options.tabWidth * count;\n  }\n\n  function addSpaces(count) {\n    value += \" \".repeat(count);\n    length += count;\n  }\n\n  function flush() {\n    if (options.useTabs) {\n      flushTabs();\n    } else {\n      flushSpaces();\n    }\n  }\n\n  function flushTabs() {\n    if (lastTabs > 0) {\n      addTabs(lastTabs);\n    }\n\n    resetLast();\n  }\n\n  function flushSpaces() {\n    if (lastSpaces > 0) {\n      addSpaces(lastSpaces);\n    }\n\n    resetLast();\n  }\n\n  function resetLast() {\n    lastTabs = 0;\n    lastSpaces = 0;\n  }\n}\n\nfunction trim(out) {\n  if (out.length === 0) {\n    return 0;\n  }\n\n  var trimCount = 0; // Trim whitespace at the end of line\n\n  while (out.length > 0 && typeof out[out.length - 1] === \"string\" && out[out.length - 1].match(/^[ \\t]*$/)) {\n    trimCount += out.pop().length;\n  }\n\n  if (out.length && typeof out[out.length - 1] === \"string\") {\n    var trimmed = out[out.length - 1].replace(/[ \\t]*$/, \"\");\n    trimCount += out[out.length - 1].length - trimmed.length;\n    out[out.length - 1] = trimmed;\n  }\n\n  return trimCount;\n}\n\nfunction fits(next, restCommands, width, options, mustBeFlat) {\n  var restIdx = restCommands.length;\n  var cmds = [next]; // `out` is only used for width counting because `trim` requires to look\n  // backwards for space characters.\n\n  var out = [];\n\n  while (width >= 0) {\n    if (cmds.length === 0) {\n      if (restIdx === 0) {\n        return true;\n      }\n\n      cmds.push(restCommands[restIdx - 1]);\n      restIdx--;\n      continue;\n    }\n\n    var x = cmds.pop();\n    var ind = x[0];\n    var mode = x[1];\n    var doc = x[2];\n\n    if (typeof doc === \"string\") {\n      out.push(doc);\n      width -= getStringWidth(doc);\n    } else {\n      switch (doc.type) {\n        case \"concat\":\n          for (var i = doc.parts.length - 1; i >= 0; i--) {\n            cmds.push([ind, mode, doc.parts[i]]);\n          }\n\n          break;\n\n        case \"indent\":\n          cmds.push([makeIndent(ind, options), mode, doc.contents]);\n          break;\n\n        case \"align\":\n          cmds.push([makeAlign(ind, doc.n, options), mode, doc.contents]);\n          break;\n\n        case \"trim\":\n          width += trim(out);\n          break;\n\n        case \"group\":\n          if (mustBeFlat && doc[\"break\"]) {\n            return false;\n          }\n\n          cmds.push([ind, doc[\"break\"] ? MODE_BREAK : mode, doc.contents]);\n\n          if (doc.id) {\n            groupModeMap[doc.id] = cmds[cmds.length - 1][1];\n          }\n\n          break;\n\n        case \"fill\":\n          for (var _i = doc.parts.length - 1; _i >= 0; _i--) {\n            cmds.push([ind, mode, doc.parts[_i]]);\n          }\n\n          break;\n\n        case \"if-break\":\n          {\n            var groupMode = doc.groupId ? groupModeMap[doc.groupId] : mode;\n\n            if (groupMode === MODE_BREAK) {\n              if (doc.breakContents) {\n                cmds.push([ind, mode, doc.breakContents]);\n              }\n            }\n\n            if (groupMode === MODE_FLAT) {\n              if (doc.flatContents) {\n                cmds.push([ind, mode, doc.flatContents]);\n              }\n            }\n\n            break;\n          }\n\n        case \"line\":\n          switch (mode) {\n            // fallthrough\n            case MODE_FLAT:\n              if (!doc.hard) {\n                if (!doc.soft) {\n                  out.push(\" \");\n                  width -= 1;\n                }\n\n                break;\n              }\n\n              return true;\n\n            case MODE_BREAK:\n              return true;\n          }\n\n          break;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction printDocToString(doc, options) {\n  groupModeMap = {};\n  var width = options.printWidth;\n  var newLine = convertEndOfLineToChars(options.endOfLine);\n  var pos = 0; // cmds is basically a stack. We've turned a recursive call into a\n  // while loop which is much faster. The while loop below adds new\n  // cmds to the array instead of recursively calling `print`.\n\n  var cmds = [[rootIndent(), MODE_BREAK, doc]];\n  var out = [];\n  var shouldRemeasure = false;\n  var lineSuffix = [];\n\n  while (cmds.length !== 0) {\n    var x = cmds.pop();\n    var ind = x[0];\n    var mode = x[1];\n    var _doc = x[2];\n\n    if (typeof _doc === \"string\") {\n      out.push(_doc);\n      pos += getStringWidth(_doc);\n    } else {\n      switch (_doc.type) {\n        case \"cursor\":\n          out.push(cursor.placeholder);\n          break;\n\n        case \"concat\":\n          for (var i = _doc.parts.length - 1; i >= 0; i--) {\n            cmds.push([ind, mode, _doc.parts[i]]);\n          }\n\n          break;\n\n        case \"indent\":\n          cmds.push([makeIndent(ind, options), mode, _doc.contents]);\n          break;\n\n        case \"align\":\n          cmds.push([makeAlign(ind, _doc.n, options), mode, _doc.contents]);\n          break;\n\n        case \"trim\":\n          pos -= trim(out);\n          break;\n\n        case \"group\":\n          switch (mode) {\n            case MODE_FLAT:\n              if (!shouldRemeasure) {\n                cmds.push([ind, _doc[\"break\"] ? MODE_BREAK : MODE_FLAT, _doc.contents]);\n                break;\n              }\n\n            // fallthrough\n\n            case MODE_BREAK:\n              {\n                shouldRemeasure = false;\n                var next = [ind, MODE_FLAT, _doc.contents];\n                var rem = width - pos;\n\n                if (!_doc[\"break\"] && fits(next, cmds, rem, options)) {\n                  cmds.push(next);\n                } else {\n                  // Expanded states are a rare case where a document\n                  // can manually provide multiple representations of\n                  // itself. It provides an array of documents\n                  // going from the least expanded (most flattened)\n                  // representation first to the most expanded. If a\n                  // group has these, we need to manually go through\n                  // these states and find the first one that fits.\n                  if (_doc.expandedStates) {\n                    var mostExpanded = _doc.expandedStates[_doc.expandedStates.length - 1];\n\n                    if (_doc[\"break\"]) {\n                      cmds.push([ind, MODE_BREAK, mostExpanded]);\n                      break;\n                    } else {\n                      for (var _i2 = 1; _i2 < _doc.expandedStates.length + 1; _i2++) {\n                        if (_i2 >= _doc.expandedStates.length) {\n                          cmds.push([ind, MODE_BREAK, mostExpanded]);\n                          break;\n                        } else {\n                          var state = _doc.expandedStates[_i2];\n                          var cmd = [ind, MODE_FLAT, state];\n\n                          if (fits(cmd, cmds, rem, options)) {\n                            cmds.push(cmd);\n                            break;\n                          }\n                        }\n                      }\n                    }\n                  } else {\n                    cmds.push([ind, MODE_BREAK, _doc.contents]);\n                  }\n                }\n\n                break;\n              }\n          }\n\n          if (_doc.id) {\n            groupModeMap[_doc.id] = cmds[cmds.length - 1][1];\n          }\n\n          break;\n        // Fills each line with as much code as possible before moving to a new\n        // line with the same indentation.\n        //\n        // Expects doc.parts to be an array of alternating content and\n        // whitespace. The whitespace contains the linebreaks.\n        //\n        // For example:\n        //   [\"I\", line, \"love\", line, \"monkeys\"]\n        // or\n        //   [{ type: group, ... }, softline, { type: group, ... }]\n        //\n        // It uses this parts structure to handle three main layout cases:\n        // * The first two content items fit on the same line without\n        //   breaking\n        //   -> output the first content item and the whitespace \"flat\".\n        // * Only the first content item fits on the line without breaking\n        //   -> output the first content item \"flat\" and the whitespace with\n        //   \"break\".\n        // * Neither content item fits on the line without breaking\n        //   -> output the first content item and the whitespace with \"break\".\n\n        case \"fill\":\n          {\n            var _rem = width - pos;\n\n            var parts = _doc.parts;\n\n            if (parts.length === 0) {\n              break;\n            }\n\n            var content = parts[0];\n            var contentFlatCmd = [ind, MODE_FLAT, content];\n            var contentBreakCmd = [ind, MODE_BREAK, content];\n            var contentFits = fits(contentFlatCmd, [], _rem, options, true);\n\n            if (parts.length === 1) {\n              if (contentFits) {\n                cmds.push(contentFlatCmd);\n              } else {\n                cmds.push(contentBreakCmd);\n              }\n\n              break;\n            }\n\n            var whitespace = parts[1];\n            var whitespaceFlatCmd = [ind, MODE_FLAT, whitespace];\n            var whitespaceBreakCmd = [ind, MODE_BREAK, whitespace];\n\n            if (parts.length === 2) {\n              if (contentFits) {\n                cmds.push(whitespaceFlatCmd);\n                cmds.push(contentFlatCmd);\n              } else {\n                cmds.push(whitespaceBreakCmd);\n                cmds.push(contentBreakCmd);\n              }\n\n              break;\n            } // At this point we've handled the first pair (context, separator)\n            // and will create a new fill doc for the rest of the content.\n            // Ideally we wouldn't mutate the array here but coping all the\n            // elements to a new array would make this algorithm quadratic,\n            // which is unusable for large arrays (e.g. large texts in JSX).\n\n\n            parts.splice(0, 2);\n            var remainingCmd = [ind, mode, fill(parts)];\n            var secondContent = parts[0];\n            var firstAndSecondContentFlatCmd = [ind, MODE_FLAT, concat([content, whitespace, secondContent])];\n            var firstAndSecondContentFits = fits(firstAndSecondContentFlatCmd, [], _rem, options, true);\n\n            if (firstAndSecondContentFits) {\n              cmds.push(remainingCmd);\n              cmds.push(whitespaceFlatCmd);\n              cmds.push(contentFlatCmd);\n            } else if (contentFits) {\n              cmds.push(remainingCmd);\n              cmds.push(whitespaceBreakCmd);\n              cmds.push(contentFlatCmd);\n            } else {\n              cmds.push(remainingCmd);\n              cmds.push(whitespaceBreakCmd);\n              cmds.push(contentBreakCmd);\n            }\n\n            break;\n          }\n\n        case \"if-break\":\n          {\n            var groupMode = _doc.groupId ? groupModeMap[_doc.groupId] : mode;\n\n            if (groupMode === MODE_BREAK) {\n              if (_doc.breakContents) {\n                cmds.push([ind, mode, _doc.breakContents]);\n              }\n            }\n\n            if (groupMode === MODE_FLAT) {\n              if (_doc.flatContents) {\n                cmds.push([ind, mode, _doc.flatContents]);\n              }\n            }\n\n            break;\n          }\n\n        case \"line-suffix\":\n          lineSuffix.push([ind, mode, _doc.contents]);\n          break;\n\n        case \"line-suffix-boundary\":\n          if (lineSuffix.length > 0) {\n            cmds.push([ind, mode, {\n              type: \"line\",\n              hard: true\n            }]);\n          }\n\n          break;\n\n        case \"line\":\n          switch (mode) {\n            case MODE_FLAT:\n              if (!_doc.hard) {\n                if (!_doc.soft) {\n                  out.push(\" \");\n                  pos += 1;\n                }\n\n                break;\n              } else {\n                // This line was forced into the output even if we\n                // were in flattened mode, so we need to tell the next\n                // group that no matter what, it needs to remeasure\n                // because the previous measurement didn't accurately\n                // capture the entire expression (this is necessary\n                // for nested groups)\n                shouldRemeasure = true;\n              }\n\n            // fallthrough\n\n            case MODE_BREAK:\n              if (lineSuffix.length) {\n                cmds.push([ind, mode, _doc]);\n                [].push.apply(cmds, lineSuffix.reverse());\n                lineSuffix = [];\n                break;\n              }\n\n              if (_doc.literal) {\n                if (ind.root) {\n                  out.push(newLine, ind.root.value);\n                  pos = ind.root.length;\n                } else {\n                  out.push(newLine);\n                  pos = 0;\n                }\n              } else {\n                pos -= trim(out);\n                out.push(newLine + ind.value);\n                pos = ind.length;\n              }\n\n              break;\n          }\n\n          break;\n\n        default:\n      }\n    }\n  }\n\n  var cursorPlaceholderIndex = out.indexOf(cursor.placeholder);\n\n  if (cursorPlaceholderIndex !== -1) {\n    var otherCursorPlaceholderIndex = out.indexOf(cursor.placeholder, cursorPlaceholderIndex + 1);\n    var beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");\n    var aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join(\"\");\n    var afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");\n    return {\n      formatted: beforeCursor + aroundCursor + afterCursor,\n      cursorNodeStart: beforeCursor.length,\n      cursorNodeText: aroundCursor\n    };\n  }\n\n  return {\n    formatted: out.join(\"\")\n  };\n}\n\nmodule.exports = {\n  printDocToString: printDocToString\n};","map":{"version":3,"sources":["/Users/pranamyavadlamani/Desktop/Research/PortFolio/portfolio-site/node_modules/@miksu/prettier/lib/doc/doc-printer.js"],"names":["_require","require","getStringWidth","_require2","convertEndOfLineToChars","_require3","concat","fill","cursor","groupModeMap","MODE_BREAK","MODE_FLAT","rootIndent","value","length","queue","makeIndent","ind","options","generateInd","type","makeAlign","n","Infinity","root","Object","assign","newPart","slice","lastTabs","lastSpaces","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","part","flush","useTabs","addTabs","addSpaces","tabWidth","Error","err","flushSpaces","count","repeat","flushTabs","resetLast","trim","out","trimCount","match","pop","trimmed","replace","fits","restCommands","width","mustBeFlat","restIdx","cmds","push","x","mode","doc","i","parts","contents","id","_i","groupMode","groupId","breakContents","flatContents","hard","soft","printDocToString","printWidth","newLine","endOfLine","pos","shouldRemeasure","lineSuffix","_doc","placeholder","rem","expandedStates","mostExpanded","_i2","state","cmd","_rem","content","contentFlatCmd","contentBreakCmd","contentFits","whitespace","whitespaceFlatCmd","whitespaceBreakCmd","splice","remainingCmd","secondContent","firstAndSecondContentFlatCmd","firstAndSecondContentFits","apply","reverse","literal","cursorPlaceholderIndex","indexOf","otherCursorPlaceholderIndex","beforeCursor","join","aroundCursor","afterCursor","formatted","cursorNodeStart","cursorNodeText","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _require = require(\"../common/util\"),\n    getStringWidth = _require.getStringWidth;\n\nvar _require2 = require(\"../common/end-of-line\"),\n    convertEndOfLineToChars = _require2.convertEndOfLineToChars;\n\nvar _require3 = require(\"./doc-builders\"),\n    concat = _require3.concat,\n    fill = _require3.fill,\n    cursor = _require3.cursor;\n/** @type {{[groupId: PropertyKey]: MODE}} */\n\n\nvar groupModeMap;\nvar MODE_BREAK = 1;\nvar MODE_FLAT = 2;\n\nfunction rootIndent() {\n  return {\n    value: \"\",\n    length: 0,\n    queue: []\n  };\n}\n\nfunction makeIndent(ind, options) {\n  return generateInd(ind, {\n    type: \"indent\"\n  }, options);\n}\n\nfunction makeAlign(ind, n, options) {\n  return n === -Infinity ? ind.root || rootIndent() : n < 0 ? generateInd(ind, {\n    type: \"dedent\"\n  }, options) : !n ? ind : n.type === \"root\" ? Object.assign({}, ind, {\n    root: ind\n  }) : typeof n === \"string\" ? generateInd(ind, {\n    type: \"stringAlign\",\n    n: n\n  }, options) : generateInd(ind, {\n    type: \"numberAlign\",\n    n: n\n  }, options);\n}\n\nfunction generateInd(ind, newPart, options) {\n  var queue = newPart.type === \"dedent\" ? ind.queue.slice(0, -1) : ind.queue.concat(newPart);\n  var value = \"\";\n  var length = 0;\n  var lastTabs = 0;\n  var lastSpaces = 0;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = queue[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var part = _step.value;\n\n      switch (part.type) {\n        case \"indent\":\n          flush();\n\n          if (options.useTabs) {\n            addTabs(1);\n          } else {\n            addSpaces(options.tabWidth);\n          }\n\n          break;\n\n        case \"stringAlign\":\n          flush();\n          value += part.n;\n          length += part.n.length;\n          break;\n\n        case \"numberAlign\":\n          lastTabs += 1;\n          lastSpaces += part.n;\n          break;\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error(\"Unexpected type '\".concat(part.type, \"'\"));\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  flushSpaces();\n  return Object.assign({}, ind, {\n    value: value,\n    length: length,\n    queue: queue\n  });\n\n  function addTabs(count) {\n    value += \"\\t\".repeat(count);\n    length += options.tabWidth * count;\n  }\n\n  function addSpaces(count) {\n    value += \" \".repeat(count);\n    length += count;\n  }\n\n  function flush() {\n    if (options.useTabs) {\n      flushTabs();\n    } else {\n      flushSpaces();\n    }\n  }\n\n  function flushTabs() {\n    if (lastTabs > 0) {\n      addTabs(lastTabs);\n    }\n\n    resetLast();\n  }\n\n  function flushSpaces() {\n    if (lastSpaces > 0) {\n      addSpaces(lastSpaces);\n    }\n\n    resetLast();\n  }\n\n  function resetLast() {\n    lastTabs = 0;\n    lastSpaces = 0;\n  }\n}\n\nfunction trim(out) {\n  if (out.length === 0) {\n    return 0;\n  }\n\n  var trimCount = 0; // Trim whitespace at the end of line\n\n  while (out.length > 0 && typeof out[out.length - 1] === \"string\" && out[out.length - 1].match(/^[ \\t]*$/)) {\n    trimCount += out.pop().length;\n  }\n\n  if (out.length && typeof out[out.length - 1] === \"string\") {\n    var trimmed = out[out.length - 1].replace(/[ \\t]*$/, \"\");\n    trimCount += out[out.length - 1].length - trimmed.length;\n    out[out.length - 1] = trimmed;\n  }\n\n  return trimCount;\n}\n\nfunction fits(next, restCommands, width, options, mustBeFlat) {\n  var restIdx = restCommands.length;\n  var cmds = [next]; // `out` is only used for width counting because `trim` requires to look\n  // backwards for space characters.\n\n  var out = [];\n\n  while (width >= 0) {\n    if (cmds.length === 0) {\n      if (restIdx === 0) {\n        return true;\n      }\n\n      cmds.push(restCommands[restIdx - 1]);\n      restIdx--;\n      continue;\n    }\n\n    var x = cmds.pop();\n    var ind = x[0];\n    var mode = x[1];\n    var doc = x[2];\n\n    if (typeof doc === \"string\") {\n      out.push(doc);\n      width -= getStringWidth(doc);\n    } else {\n      switch (doc.type) {\n        case \"concat\":\n          for (var i = doc.parts.length - 1; i >= 0; i--) {\n            cmds.push([ind, mode, doc.parts[i]]);\n          }\n\n          break;\n\n        case \"indent\":\n          cmds.push([makeIndent(ind, options), mode, doc.contents]);\n          break;\n\n        case \"align\":\n          cmds.push([makeAlign(ind, doc.n, options), mode, doc.contents]);\n          break;\n\n        case \"trim\":\n          width += trim(out);\n          break;\n\n        case \"group\":\n          if (mustBeFlat && doc[\"break\"]) {\n            return false;\n          }\n\n          cmds.push([ind, doc[\"break\"] ? MODE_BREAK : mode, doc.contents]);\n\n          if (doc.id) {\n            groupModeMap[doc.id] = cmds[cmds.length - 1][1];\n          }\n\n          break;\n\n        case \"fill\":\n          for (var _i = doc.parts.length - 1; _i >= 0; _i--) {\n            cmds.push([ind, mode, doc.parts[_i]]);\n          }\n\n          break;\n\n        case \"if-break\":\n          {\n            var groupMode = doc.groupId ? groupModeMap[doc.groupId] : mode;\n\n            if (groupMode === MODE_BREAK) {\n              if (doc.breakContents) {\n                cmds.push([ind, mode, doc.breakContents]);\n              }\n            }\n\n            if (groupMode === MODE_FLAT) {\n              if (doc.flatContents) {\n                cmds.push([ind, mode, doc.flatContents]);\n              }\n            }\n\n            break;\n          }\n\n        case \"line\":\n          switch (mode) {\n            // fallthrough\n            case MODE_FLAT:\n              if (!doc.hard) {\n                if (!doc.soft) {\n                  out.push(\" \");\n                  width -= 1;\n                }\n\n                break;\n              }\n\n              return true;\n\n            case MODE_BREAK:\n              return true;\n          }\n\n          break;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction printDocToString(doc, options) {\n  groupModeMap = {};\n  var width = options.printWidth;\n  var newLine = convertEndOfLineToChars(options.endOfLine);\n  var pos = 0; // cmds is basically a stack. We've turned a recursive call into a\n  // while loop which is much faster. The while loop below adds new\n  // cmds to the array instead of recursively calling `print`.\n\n  var cmds = [[rootIndent(), MODE_BREAK, doc]];\n  var out = [];\n  var shouldRemeasure = false;\n  var lineSuffix = [];\n\n  while (cmds.length !== 0) {\n    var x = cmds.pop();\n    var ind = x[0];\n    var mode = x[1];\n    var _doc = x[2];\n\n    if (typeof _doc === \"string\") {\n      out.push(_doc);\n      pos += getStringWidth(_doc);\n    } else {\n      switch (_doc.type) {\n        case \"cursor\":\n          out.push(cursor.placeholder);\n          break;\n\n        case \"concat\":\n          for (var i = _doc.parts.length - 1; i >= 0; i--) {\n            cmds.push([ind, mode, _doc.parts[i]]);\n          }\n\n          break;\n\n        case \"indent\":\n          cmds.push([makeIndent(ind, options), mode, _doc.contents]);\n          break;\n\n        case \"align\":\n          cmds.push([makeAlign(ind, _doc.n, options), mode, _doc.contents]);\n          break;\n\n        case \"trim\":\n          pos -= trim(out);\n          break;\n\n        case \"group\":\n          switch (mode) {\n            case MODE_FLAT:\n              if (!shouldRemeasure) {\n                cmds.push([ind, _doc[\"break\"] ? MODE_BREAK : MODE_FLAT, _doc.contents]);\n                break;\n              }\n\n            // fallthrough\n\n            case MODE_BREAK:\n              {\n                shouldRemeasure = false;\n                var next = [ind, MODE_FLAT, _doc.contents];\n                var rem = width - pos;\n\n                if (!_doc[\"break\"] && fits(next, cmds, rem, options)) {\n                  cmds.push(next);\n                } else {\n                  // Expanded states are a rare case where a document\n                  // can manually provide multiple representations of\n                  // itself. It provides an array of documents\n                  // going from the least expanded (most flattened)\n                  // representation first to the most expanded. If a\n                  // group has these, we need to manually go through\n                  // these states and find the first one that fits.\n                  if (_doc.expandedStates) {\n                    var mostExpanded = _doc.expandedStates[_doc.expandedStates.length - 1];\n\n                    if (_doc[\"break\"]) {\n                      cmds.push([ind, MODE_BREAK, mostExpanded]);\n                      break;\n                    } else {\n                      for (var _i2 = 1; _i2 < _doc.expandedStates.length + 1; _i2++) {\n                        if (_i2 >= _doc.expandedStates.length) {\n                          cmds.push([ind, MODE_BREAK, mostExpanded]);\n                          break;\n                        } else {\n                          var state = _doc.expandedStates[_i2];\n                          var cmd = [ind, MODE_FLAT, state];\n\n                          if (fits(cmd, cmds, rem, options)) {\n                            cmds.push(cmd);\n                            break;\n                          }\n                        }\n                      }\n                    }\n                  } else {\n                    cmds.push([ind, MODE_BREAK, _doc.contents]);\n                  }\n                }\n\n                break;\n              }\n          }\n\n          if (_doc.id) {\n            groupModeMap[_doc.id] = cmds[cmds.length - 1][1];\n          }\n\n          break;\n        // Fills each line with as much code as possible before moving to a new\n        // line with the same indentation.\n        //\n        // Expects doc.parts to be an array of alternating content and\n        // whitespace. The whitespace contains the linebreaks.\n        //\n        // For example:\n        //   [\"I\", line, \"love\", line, \"monkeys\"]\n        // or\n        //   [{ type: group, ... }, softline, { type: group, ... }]\n        //\n        // It uses this parts structure to handle three main layout cases:\n        // * The first two content items fit on the same line without\n        //   breaking\n        //   -> output the first content item and the whitespace \"flat\".\n        // * Only the first content item fits on the line without breaking\n        //   -> output the first content item \"flat\" and the whitespace with\n        //   \"break\".\n        // * Neither content item fits on the line without breaking\n        //   -> output the first content item and the whitespace with \"break\".\n\n        case \"fill\":\n          {\n            var _rem = width - pos;\n\n            var parts = _doc.parts;\n\n            if (parts.length === 0) {\n              break;\n            }\n\n            var content = parts[0];\n            var contentFlatCmd = [ind, MODE_FLAT, content];\n            var contentBreakCmd = [ind, MODE_BREAK, content];\n            var contentFits = fits(contentFlatCmd, [], _rem, options, true);\n\n            if (parts.length === 1) {\n              if (contentFits) {\n                cmds.push(contentFlatCmd);\n              } else {\n                cmds.push(contentBreakCmd);\n              }\n\n              break;\n            }\n\n            var whitespace = parts[1];\n            var whitespaceFlatCmd = [ind, MODE_FLAT, whitespace];\n            var whitespaceBreakCmd = [ind, MODE_BREAK, whitespace];\n\n            if (parts.length === 2) {\n              if (contentFits) {\n                cmds.push(whitespaceFlatCmd);\n                cmds.push(contentFlatCmd);\n              } else {\n                cmds.push(whitespaceBreakCmd);\n                cmds.push(contentBreakCmd);\n              }\n\n              break;\n            } // At this point we've handled the first pair (context, separator)\n            // and will create a new fill doc for the rest of the content.\n            // Ideally we wouldn't mutate the array here but coping all the\n            // elements to a new array would make this algorithm quadratic,\n            // which is unusable for large arrays (e.g. large texts in JSX).\n\n\n            parts.splice(0, 2);\n            var remainingCmd = [ind, mode, fill(parts)];\n            var secondContent = parts[0];\n            var firstAndSecondContentFlatCmd = [ind, MODE_FLAT, concat([content, whitespace, secondContent])];\n            var firstAndSecondContentFits = fits(firstAndSecondContentFlatCmd, [], _rem, options, true);\n\n            if (firstAndSecondContentFits) {\n              cmds.push(remainingCmd);\n              cmds.push(whitespaceFlatCmd);\n              cmds.push(contentFlatCmd);\n            } else if (contentFits) {\n              cmds.push(remainingCmd);\n              cmds.push(whitespaceBreakCmd);\n              cmds.push(contentFlatCmd);\n            } else {\n              cmds.push(remainingCmd);\n              cmds.push(whitespaceBreakCmd);\n              cmds.push(contentBreakCmd);\n            }\n\n            break;\n          }\n\n        case \"if-break\":\n          {\n            var groupMode = _doc.groupId ? groupModeMap[_doc.groupId] : mode;\n\n            if (groupMode === MODE_BREAK) {\n              if (_doc.breakContents) {\n                cmds.push([ind, mode, _doc.breakContents]);\n              }\n            }\n\n            if (groupMode === MODE_FLAT) {\n              if (_doc.flatContents) {\n                cmds.push([ind, mode, _doc.flatContents]);\n              }\n            }\n\n            break;\n          }\n\n        case \"line-suffix\":\n          lineSuffix.push([ind, mode, _doc.contents]);\n          break;\n\n        case \"line-suffix-boundary\":\n          if (lineSuffix.length > 0) {\n            cmds.push([ind, mode, {\n              type: \"line\",\n              hard: true\n            }]);\n          }\n\n          break;\n\n        case \"line\":\n          switch (mode) {\n            case MODE_FLAT:\n              if (!_doc.hard) {\n                if (!_doc.soft) {\n                  out.push(\" \");\n                  pos += 1;\n                }\n\n                break;\n              } else {\n                // This line was forced into the output even if we\n                // were in flattened mode, so we need to tell the next\n                // group that no matter what, it needs to remeasure\n                // because the previous measurement didn't accurately\n                // capture the entire expression (this is necessary\n                // for nested groups)\n                shouldRemeasure = true;\n              }\n\n            // fallthrough\n\n            case MODE_BREAK:\n              if (lineSuffix.length) {\n                cmds.push([ind, mode, _doc]);\n                [].push.apply(cmds, lineSuffix.reverse());\n                lineSuffix = [];\n                break;\n              }\n\n              if (_doc.literal) {\n                if (ind.root) {\n                  out.push(newLine, ind.root.value);\n                  pos = ind.root.length;\n                } else {\n                  out.push(newLine);\n                  pos = 0;\n                }\n              } else {\n                pos -= trim(out);\n                out.push(newLine + ind.value);\n                pos = ind.length;\n              }\n\n              break;\n          }\n\n          break;\n\n        default:\n      }\n    }\n  }\n\n  var cursorPlaceholderIndex = out.indexOf(cursor.placeholder);\n\n  if (cursorPlaceholderIndex !== -1) {\n    var otherCursorPlaceholderIndex = out.indexOf(cursor.placeholder, cursorPlaceholderIndex + 1);\n    var beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");\n    var aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join(\"\");\n    var afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");\n    return {\n      formatted: beforeCursor + aroundCursor + afterCursor,\n      cursorNodeStart: beforeCursor.length,\n      cursorNodeText: aroundCursor\n    };\n  }\n\n  return {\n    formatted: out.join(\"\")\n  };\n}\n\nmodule.exports = {\n  printDocToString: printDocToString\n};"]},"metadata":{},"sourceType":"script"}