{"ast":null,"code":"\"use strict\";\n\nvar _require = require(\"./comments\"),\n    isBlockComment = _require.isBlockComment,\n    hasLeadingComment = _require.hasLeadingComment;\n\nvar _require2 = require(\"../doc\"),\n    _require2$builders = _require2.builders,\n    indent = _require2$builders.indent,\n    join = _require2$builders.join,\n    hardline = _require2$builders.hardline,\n    softline = _require2$builders.softline,\n    literalline = _require2$builders.literalline,\n    concat = _require2$builders.concat,\n    group = _require2$builders.group,\n    dedentToRoot = _require2$builders.dedentToRoot,\n    _require2$utils = _require2.utils,\n    mapDoc = _require2$utils.mapDoc,\n    stripTrailingHardline = _require2$utils.stripTrailingHardline;\n\nfunction embed(path, print, textToDoc, options) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  var parentParent = path.getParentNode(1);\n\n  switch (node.type) {\n    case \"TemplateLiteral\":\n      {\n        var isCss = [isStyledJsx, isStyledComponents, isCssProp, isAngularComponentStyles].some(function (isIt) {\n          return isIt(path);\n        });\n\n        if (isCss) {\n          // Get full template literal with expressions replaced by placeholders\n          var rawQuasis = node.quasis.map(function (q) {\n            return q.value.raw;\n          });\n          var placeholderID = 0;\n          var text = rawQuasis.reduce(function (prevVal, currVal, idx) {\n            return idx == 0 ? currVal : prevVal + \"@prettier-placeholder-\" + placeholderID++ + \"-id\" + currVal;\n          }, \"\");\n          var doc = textToDoc(text, {\n            parser: \"css\"\n          });\n          return transformCssDoc(doc, path, print);\n        }\n        /*\n         * react-relay and graphql-tag\n         * graphql`...`\n         * graphql.experimental`...`\n         * gql`...`\n         *\n         * This intentionally excludes Relay Classic tags, as Prettier does not\n         * support Relay Classic formatting.\n         */\n\n\n        if (isGraphQL(path)) {\n          var expressionDocs = node.expressions ? path.map(print, \"expressions\") : [];\n          var numQuasis = node.quasis.length;\n\n          if (numQuasis === 1 && node.quasis[0].value.raw.trim() === \"\") {\n            return \"``\";\n          }\n\n          var parts = [];\n\n          for (var i = 0; i < numQuasis; i++) {\n            var templateElement = node.quasis[i];\n            var isFirst = i === 0;\n            var isLast = i === numQuasis - 1;\n            var _text = templateElement.value.cooked; // Bail out if any of the quasis have an invalid escape sequence\n            // (which would make the `cooked` value be `null` or `undefined`)\n\n            if (typeof _text !== \"string\") {\n              return null;\n            }\n\n            var lines = _text.split(\"\\n\");\n\n            var numLines = lines.length;\n            var expressionDoc = expressionDocs[i];\n            var startsWithBlankLine = numLines > 2 && lines[0].trim() === \"\" && lines[1].trim() === \"\";\n            var endsWithBlankLine = numLines > 2 && lines[numLines - 1].trim() === \"\" && lines[numLines - 2].trim() === \"\";\n            var commentsAndWhitespaceOnly = lines.every(function (line) {\n              return /^\\s*(?:#[^\\r\\n]*)?$/.test(line);\n            }); // Bail out if an interpolation occurs within a comment.\n\n            if (!isLast && /#[^\\r\\n]*$/.test(lines[numLines - 1])) {\n              return null;\n            }\n\n            var _doc = null;\n\n            if (commentsAndWhitespaceOnly) {\n              _doc = printGraphqlComments(lines);\n            } else {\n              _doc = stripTrailingHardline(textToDoc(_text, {\n                parser: \"graphql\"\n              }));\n            }\n\n            if (_doc) {\n              _doc = escapeTemplateCharacters(_doc, false);\n\n              if (!isFirst && startsWithBlankLine) {\n                parts.push(\"\");\n              }\n\n              parts.push(_doc);\n\n              if (!isLast && endsWithBlankLine) {\n                parts.push(\"\");\n              }\n            } else if (!isFirst && !isLast && startsWithBlankLine) {\n              parts.push(\"\");\n            }\n\n            if (expressionDoc) {\n              parts.push(concat([\"${\", expressionDoc, \"}\"]));\n            }\n          }\n\n          return concat([\"`\", indent(concat([hardline, join(hardline, parts)])), hardline, \"`\"]);\n        }\n\n        var htmlParser = isHtml(path) ? \"html\" : isAngularComponentTemplate(path) ? \"angular\" : undefined;\n\n        if (htmlParser) {\n          return printHtmlTemplateLiteral(path, print, textToDoc, htmlParser, options.embeddedInHtml);\n        }\n\n        break;\n      }\n\n    case \"TemplateElement\":\n      {\n        /**\n         * md`...`\n         * markdown`...`\n         */\n        if (parentParent && parentParent.type === \"TaggedTemplateExpression\" && parent.quasis.length === 1 && parentParent.tag.type === \"Identifier\" && (parentParent.tag.name === \"md\" || parentParent.tag.name === \"markdown\")) {\n          var _text2 = parent.quasis[0].value.raw.replace(/((?:\\\\\\\\)*)\\\\`/g, function (_, backslashes) {\n            return \"\\\\\".repeat(backslashes.length / 2) + \"`\";\n          });\n\n          var indentation = getIndentation(_text2);\n          var hasIndent = indentation !== \"\";\n          return concat([hasIndent ? indent(concat([softline, printMarkdown(_text2.replace(new RegExp(\"^\".concat(indentation), \"gm\"), \"\"))])) : concat([literalline, dedentToRoot(printMarkdown(_text2))]), softline]);\n        }\n\n        break;\n      }\n  }\n\n  function printMarkdown(text) {\n    var doc = textToDoc(text, {\n      parser: \"markdown\",\n      __inJsTemplate: true\n    });\n    return stripTrailingHardline(escapeTemplateCharacters(doc, true));\n  }\n}\n\nfunction getIndentation(str) {\n  var firstMatchedIndent = str.match(/^([^\\S\\n]*)\\S/m);\n  return firstMatchedIndent === null ? \"\" : firstMatchedIndent[1];\n}\n\nfunction uncook(cookedValue) {\n  return cookedValue.replace(/([\\\\`]|\\$\\{)/g, \"\\\\$1\");\n}\n\nfunction escapeTemplateCharacters(doc, raw) {\n  return mapDoc(doc, function (currentDoc) {\n    if (!currentDoc.parts) {\n      return currentDoc;\n    }\n\n    var parts = [];\n    currentDoc.parts.forEach(function (part) {\n      if (typeof part === \"string\") {\n        parts.push(raw ? part.replace(/(\\\\*)`/g, \"$1$1\\\\`\") : uncook(part));\n      } else {\n        parts.push(part);\n      }\n    });\n    return Object.assign({}, currentDoc, {\n      parts: parts\n    });\n  });\n}\n\nfunction transformCssDoc(quasisDoc, path, print) {\n  var parentNode = path.getValue();\n  var isEmpty = parentNode.quasis.length === 1 && !parentNode.quasis[0].value.raw.trim();\n\n  if (isEmpty) {\n    return \"``\";\n  }\n\n  var expressionDocs = parentNode.expressions ? path.map(print, \"expressions\") : [];\n  var newDoc = replacePlaceholders(quasisDoc, expressionDocs);\n  /* istanbul ignore if */\n\n  if (!newDoc) {\n    throw new Error(\"Couldn't insert all the expressions\");\n  }\n\n  return concat([\"`\", indent(concat([hardline, stripTrailingHardline(newDoc)])), softline, \"`\"]);\n} // Search all the placeholders in the quasisDoc tree\n// and replace them with the expression docs one by one\n// returns a new doc with all the placeholders replaced,\n// or null if it couldn't replace any expression\n\n\nfunction replacePlaceholders(quasisDoc, expressionDocs) {\n  if (!expressionDocs || !expressionDocs.length) {\n    return quasisDoc;\n  }\n\n  var expressions = expressionDocs.slice();\n  var replaceCounter = 0;\n  var newDoc = mapDoc(quasisDoc, function (doc) {\n    if (!doc || !doc.parts || !doc.parts.length) {\n      return doc;\n    }\n\n    var parts = doc.parts;\n    var atIndex = parts.indexOf(\"@\");\n    var placeholderIndex = atIndex + 1;\n\n    if (atIndex > -1 && typeof parts[placeholderIndex] === \"string\" && parts[placeholderIndex].startsWith(\"prettier-placeholder\")) {\n      // If placeholder is split, join it\n      var at = parts[atIndex];\n      var placeholder = parts[placeholderIndex];\n      var rest = parts.slice(placeholderIndex + 1);\n      parts = parts.slice(0, atIndex).concat([at + placeholder]).concat(rest);\n    }\n\n    var atPlaceholderIndex = parts.findIndex(function (part) {\n      return typeof part === \"string\" && part.startsWith(\"@prettier-placeholder\");\n    });\n\n    if (atPlaceholderIndex > -1) {\n      var _placeholder = parts[atPlaceholderIndex];\n\n      var _rest = parts.slice(atPlaceholderIndex + 1);\n\n      var placeholderMatch = _placeholder.match(/@prettier-placeholder-(.+)-id([\\s\\S]*)/);\n\n      var placeholderID = placeholderMatch[1]; // When the expression has a suffix appended, like:\n      // animation: linear ${time}s ease-out;\n\n      var suffix = placeholderMatch[2];\n      var expression = expressions[placeholderID];\n      replaceCounter++;\n      parts = parts.slice(0, atPlaceholderIndex).concat([\"${\", expression, \"}\" + suffix]).concat(_rest);\n    }\n\n    return Object.assign({}, doc, {\n      parts: parts\n    });\n  });\n  return expressions.length === replaceCounter ? newDoc : null;\n}\n\nfunction printGraphqlComments(lines) {\n  var parts = [];\n  var seenComment = false;\n  lines.map(function (textLine) {\n    return textLine.trim();\n  }).forEach(function (textLine, i, array) {\n    // Lines are either whitespace only, or a comment (with poential whitespace\n    // around it). Drop whitespace-only lines.\n    if (textLine === \"\") {\n      return;\n    }\n\n    if (array[i - 1] === \"\" && seenComment) {\n      // If a non-first comment is preceded by a blank (whitespace only) line,\n      // add in a blank line.\n      parts.push(concat([hardline, textLine]));\n    } else {\n      parts.push(textLine);\n    }\n\n    seenComment = true;\n  }); // If `lines` was whitespace only, return `null`.\n\n  return parts.length === 0 ? null : join(hardline, parts);\n}\n/**\n * Template literal in these contexts:\n * <style jsx>{`div{color:red}`}</style>\n * css``\n * css.global``\n * css.resolve``\n */\n\n\nfunction isStyledJsx(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  var parentParent = path.getParentNode(1);\n  return parentParent && node.quasis && parent.type === \"JSXExpressionContainer\" && parentParent.type === \"JSXElement\" && parentParent.openingElement.name.name === \"style\" && parentParent.openingElement.attributes.some(function (attribute) {\n    return attribute.name.name === \"jsx\";\n  }) || parent && parent.type === \"TaggedTemplateExpression\" && parent.tag.type === \"Identifier\" && parent.tag.name === \"css\" || parent && parent.type === \"TaggedTemplateExpression\" && parent.tag.type === \"MemberExpression\" && parent.tag.object.name === \"css\" && (parent.tag.property.name === \"global\" || parent.tag.property.name === \"resolve\");\n}\n/**\n * Angular Components can have:\n * - Inline HTML template\n * - Inline CSS styles\n *\n * ...which are both within template literals somewhere\n * inside of the Component decorator factory.\n *\n * E.g.\n * @Component({\n *  template: `<div>...</div>`,\n *  styles: [`h1 { color: blue; }`]\n * })\n */\n\n\nfunction isAngularComponentStyles(path) {\n  return isPathMatch(path, [function (node) {\n    return node.type === \"TemplateLiteral\";\n  }, function (node, name) {\n    return node.type === \"ArrayExpression\" && name === \"elements\";\n  }, function (node, name) {\n    return node.type === \"Property\" && node.key.type === \"Identifier\" && node.key.name === \"styles\" && name === \"value\";\n  }].concat(getAngularComponentObjectExpressionPredicates()));\n}\n\nfunction isAngularComponentTemplate(path) {\n  return isPathMatch(path, [function (node) {\n    return node.type === \"TemplateLiteral\";\n  }, function (node, name) {\n    return node.type === \"Property\" && node.key.type === \"Identifier\" && node.key.name === \"template\" && name === \"value\";\n  }].concat(getAngularComponentObjectExpressionPredicates()));\n}\n\nfunction getAngularComponentObjectExpressionPredicates() {\n  return [function (node, name) {\n    return node.type === \"ObjectExpression\" && name === \"properties\";\n  }, function (node, name) {\n    return node.type === \"CallExpression\" && node.callee.type === \"Identifier\" && node.callee.name === \"Component\" && name === \"arguments\";\n  }, function (node, name) {\n    return node.type === \"Decorator\" && name === \"expression\";\n  }];\n}\n/**\n * styled-components template literals\n */\n\n\nfunction isStyledComponents(path) {\n  var parent = path.getParentNode();\n\n  if (!parent || parent.type !== \"TaggedTemplateExpression\") {\n    return false;\n  }\n\n  var tag = parent.tag;\n\n  switch (tag.type) {\n    case \"MemberExpression\":\n      return (// styled.foo``\n        isStyledIdentifier(tag.object) || // Component.extend``\n        isStyledExtend(tag)\n      );\n\n    case \"CallExpression\":\n      return (// styled(Component)``\n        isStyledIdentifier(tag.callee) || tag.callee.type === \"MemberExpression\" && (tag.callee.object.type === \"MemberExpression\" && ( // styled.foo.attrs({})``\n        isStyledIdentifier(tag.callee.object.object) || // Component.extend.attrs({})``\n        isStyledExtend(tag.callee.object)) || // styled(Component).attrs({})``\n        tag.callee.object.type === \"CallExpression\" && isStyledIdentifier(tag.callee.object.callee))\n      );\n\n    case \"Identifier\":\n      // css``\n      return tag.name === \"css\";\n\n    default:\n      return false;\n  }\n}\n/**\n * JSX element with CSS prop\n */\n\n\nfunction isCssProp(path) {\n  var parent = path.getParentNode();\n  var parentParent = path.getParentNode(1);\n  return parentParent && parent.type === \"JSXExpressionContainer\" && parentParent.type === \"JSXAttribute\" && parentParent.name.type === \"JSXIdentifier\" && parentParent.name.name === \"css\";\n}\n\nfunction isStyledIdentifier(node) {\n  return node.type === \"Identifier\" && node.name === \"styled\";\n}\n\nfunction isStyledExtend(node) {\n  return /^[A-Z]/.test(node.object.name) && node.property.name === \"extend\";\n}\n/*\n * react-relay and graphql-tag\n * graphql`...`\n * graphql.experimental`...`\n * gql`...`\n * GraphQL comment block\n *\n * This intentionally excludes Relay Classic tags, as Prettier does not\n * support Relay Classic formatting.\n */\n\n\nfunction isGraphQL(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  return hasLanguageComment(node, \"GraphQL\") || parent && (parent.type === \"TaggedTemplateExpression\" && (parent.tag.type === \"MemberExpression\" && parent.tag.object.name === \"graphql\" && parent.tag.property.name === \"experimental\" || parent.tag.type === \"Identifier\" && (parent.tag.name === \"gql\" || parent.tag.name === \"graphql\")) || parent.type === \"CallExpression\" && parent.callee.type === \"Identifier\" && parent.callee.name === \"graphql\");\n}\n\nfunction hasLanguageComment(node, languageName) {\n  // This checks for a leading comment that is exactly `/* GraphQL */`\n  // In order to be in line with other implementations of this comment tag\n  // we will not trim the comment value and we will expect exactly one space on\n  // either side of the GraphQL string\n  // Also see ./clean.js\n  return hasLeadingComment(node, function (comment) {\n    return isBlockComment(comment) && comment.value === \" \".concat(languageName, \" \");\n  });\n}\n\nfunction isPathMatch(path, predicateStack) {\n  var stack = path.stack.slice();\n  var name = null;\n  var node = stack.pop();\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = predicateStack[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var predicate = _step.value;\n\n      if (node === undefined) {\n        return false;\n      } // skip index/array\n\n\n      if (typeof name === \"number\") {\n        name = stack.pop();\n        node = stack.pop();\n      }\n\n      if (!predicate(node, name)) {\n        return false;\n      }\n\n      name = stack.pop();\n      node = stack.pop();\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n *     - html`...`\n *     - HTML comment block\n */\n\n\nfunction isHtml(path) {\n  var node = path.getValue();\n  return hasLanguageComment(node, \"HTML\") || isPathMatch(path, [function (node) {\n    return node.type === \"TemplateLiteral\";\n  }, function (node, name) {\n    return node.type === \"TaggedTemplateExpression\" && node.tag.type === \"Identifier\" && node.tag.name === \"html\" && name === \"quasi\";\n  }]);\n} // The counter is needed to distinguish nested embeds.\n\n\nvar htmlTemplateLiteralCounter = 0;\n\nfunction printHtmlTemplateLiteral(path, print, textToDoc, parser, escapeClosingScriptTag) {\n  var node = path.getValue();\n  var counter = htmlTemplateLiteralCounter;\n  htmlTemplateLiteralCounter = htmlTemplateLiteralCounter + 1 >>> 0;\n\n  var composePlaceholder = function composePlaceholder(index) {\n    return \"PRETTIER_HTML_PLACEHOLDER_\".concat(index, \"_\").concat(counter, \"_IN_JS\");\n  };\n\n  var text = node.quasis.map(function (quasi, index, quasis) {\n    return index === quasis.length - 1 ? quasi.value.cooked : quasi.value.cooked + composePlaceholder(index);\n  }).join(\"\");\n  var expressionDocs = path.map(print, \"expressions\");\n\n  if (expressionDocs.length === 0 && text.trim().length === 0) {\n    return \"``\";\n  }\n\n  var placeholderRegex = RegExp(composePlaceholder(\"(\\\\d+)\"), \"g\");\n  var contentDoc = mapDoc(stripTrailingHardline(textToDoc(text, {\n    parser: parser\n  })), function (doc) {\n    if (typeof doc !== \"string\") {\n      return doc;\n    }\n\n    var parts = [];\n    var components = doc.split(placeholderRegex);\n\n    for (var i = 0; i < components.length; i++) {\n      var component = components[i];\n\n      if (i % 2 === 0) {\n        if (component) {\n          component = uncook(component);\n\n          if (escapeClosingScriptTag) {\n            component = component.replace(/<\\/(script)\\b/gi, \"<\\\\/$1\");\n          }\n\n          parts.push(component);\n        }\n\n        continue;\n      }\n\n      var placeholderIndex = +component;\n      parts.push(concat([\"${\", group(expressionDocs[placeholderIndex]), \"}\"]));\n    }\n\n    return concat(parts);\n  });\n  return group(concat([\"`\", indent(concat([hardline, group(contentDoc)])), softline, \"`\"]));\n}\n\nmodule.exports = embed;","map":{"version":3,"sources":["/Users/pranamyavadlamani/Desktop/Research/PortFolio/portfolio-site/node_modules/@miksu/prettier/lib/language-js/embed.js"],"names":["_require","require","isBlockComment","hasLeadingComment","_require2","_require2$builders","builders","indent","join","hardline","softline","literalline","concat","group","dedentToRoot","_require2$utils","utils","mapDoc","stripTrailingHardline","embed","path","print","textToDoc","options","node","getValue","parent","getParentNode","parentParent","type","isCss","isStyledJsx","isStyledComponents","isCssProp","isAngularComponentStyles","some","isIt","rawQuasis","quasis","map","q","value","raw","placeholderID","text","reduce","prevVal","currVal","idx","doc","parser","transformCssDoc","isGraphQL","expressionDocs","expressions","numQuasis","length","trim","parts","i","templateElement","isFirst","isLast","_text","cooked","lines","split","numLines","expressionDoc","startsWithBlankLine","endsWithBlankLine","commentsAndWhitespaceOnly","every","line","test","_doc","printGraphqlComments","escapeTemplateCharacters","push","htmlParser","isHtml","isAngularComponentTemplate","undefined","printHtmlTemplateLiteral","embeddedInHtml","tag","name","_text2","replace","_","backslashes","repeat","indentation","getIndentation","hasIndent","printMarkdown","RegExp","__inJsTemplate","str","firstMatchedIndent","match","uncook","cookedValue","currentDoc","forEach","part","Object","assign","quasisDoc","parentNode","isEmpty","newDoc","replacePlaceholders","Error","slice","replaceCounter","atIndex","indexOf","placeholderIndex","startsWith","at","placeholder","rest","atPlaceholderIndex","findIndex","_placeholder","_rest","placeholderMatch","suffix","expression","seenComment","textLine","array","openingElement","attributes","attribute","object","property","isPathMatch","key","getAngularComponentObjectExpressionPredicates","callee","isStyledIdentifier","isStyledExtend","hasLanguageComment","languageName","comment","predicateStack","stack","pop","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","Symbol","iterator","_step","next","done","predicate","err","htmlTemplateLiteralCounter","escapeClosingScriptTag","counter","composePlaceholder","index","quasi","placeholderRegex","contentDoc","components","component","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _require = require(\"./comments\"),\n    isBlockComment = _require.isBlockComment,\n    hasLeadingComment = _require.hasLeadingComment;\n\nvar _require2 = require(\"../doc\"),\n    _require2$builders = _require2.builders,\n    indent = _require2$builders.indent,\n    join = _require2$builders.join,\n    hardline = _require2$builders.hardline,\n    softline = _require2$builders.softline,\n    literalline = _require2$builders.literalline,\n    concat = _require2$builders.concat,\n    group = _require2$builders.group,\n    dedentToRoot = _require2$builders.dedentToRoot,\n    _require2$utils = _require2.utils,\n    mapDoc = _require2$utils.mapDoc,\n    stripTrailingHardline = _require2$utils.stripTrailingHardline;\n\nfunction embed(path, print, textToDoc, options) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  var parentParent = path.getParentNode(1);\n\n  switch (node.type) {\n    case \"TemplateLiteral\":\n      {\n        var isCss = [isStyledJsx, isStyledComponents, isCssProp, isAngularComponentStyles].some(function (isIt) {\n          return isIt(path);\n        });\n\n        if (isCss) {\n          // Get full template literal with expressions replaced by placeholders\n          var rawQuasis = node.quasis.map(function (q) {\n            return q.value.raw;\n          });\n          var placeholderID = 0;\n          var text = rawQuasis.reduce(function (prevVal, currVal, idx) {\n            return idx == 0 ? currVal : prevVal + \"@prettier-placeholder-\" + placeholderID++ + \"-id\" + currVal;\n          }, \"\");\n          var doc = textToDoc(text, {\n            parser: \"css\"\n          });\n          return transformCssDoc(doc, path, print);\n        }\n        /*\n         * react-relay and graphql-tag\n         * graphql`...`\n         * graphql.experimental`...`\n         * gql`...`\n         *\n         * This intentionally excludes Relay Classic tags, as Prettier does not\n         * support Relay Classic formatting.\n         */\n\n\n        if (isGraphQL(path)) {\n          var expressionDocs = node.expressions ? path.map(print, \"expressions\") : [];\n          var numQuasis = node.quasis.length;\n\n          if (numQuasis === 1 && node.quasis[0].value.raw.trim() === \"\") {\n            return \"``\";\n          }\n\n          var parts = [];\n\n          for (var i = 0; i < numQuasis; i++) {\n            var templateElement = node.quasis[i];\n            var isFirst = i === 0;\n            var isLast = i === numQuasis - 1;\n            var _text = templateElement.value.cooked; // Bail out if any of the quasis have an invalid escape sequence\n            // (which would make the `cooked` value be `null` or `undefined`)\n\n            if (typeof _text !== \"string\") {\n              return null;\n            }\n\n            var lines = _text.split(\"\\n\");\n\n            var numLines = lines.length;\n            var expressionDoc = expressionDocs[i];\n            var startsWithBlankLine = numLines > 2 && lines[0].trim() === \"\" && lines[1].trim() === \"\";\n            var endsWithBlankLine = numLines > 2 && lines[numLines - 1].trim() === \"\" && lines[numLines - 2].trim() === \"\";\n            var commentsAndWhitespaceOnly = lines.every(function (line) {\n              return /^\\s*(?:#[^\\r\\n]*)?$/.test(line);\n            }); // Bail out if an interpolation occurs within a comment.\n\n            if (!isLast && /#[^\\r\\n]*$/.test(lines[numLines - 1])) {\n              return null;\n            }\n\n            var _doc = null;\n\n            if (commentsAndWhitespaceOnly) {\n              _doc = printGraphqlComments(lines);\n            } else {\n              _doc = stripTrailingHardline(textToDoc(_text, {\n                parser: \"graphql\"\n              }));\n            }\n\n            if (_doc) {\n              _doc = escapeTemplateCharacters(_doc, false);\n\n              if (!isFirst && startsWithBlankLine) {\n                parts.push(\"\");\n              }\n\n              parts.push(_doc);\n\n              if (!isLast && endsWithBlankLine) {\n                parts.push(\"\");\n              }\n            } else if (!isFirst && !isLast && startsWithBlankLine) {\n              parts.push(\"\");\n            }\n\n            if (expressionDoc) {\n              parts.push(concat([\"${\", expressionDoc, \"}\"]));\n            }\n          }\n\n          return concat([\"`\", indent(concat([hardline, join(hardline, parts)])), hardline, \"`\"]);\n        }\n\n        var htmlParser = isHtml(path) ? \"html\" : isAngularComponentTemplate(path) ? \"angular\" : undefined;\n\n        if (htmlParser) {\n          return printHtmlTemplateLiteral(path, print, textToDoc, htmlParser, options.embeddedInHtml);\n        }\n\n        break;\n      }\n\n    case \"TemplateElement\":\n      {\n        /**\n         * md`...`\n         * markdown`...`\n         */\n        if (parentParent && parentParent.type === \"TaggedTemplateExpression\" && parent.quasis.length === 1 && parentParent.tag.type === \"Identifier\" && (parentParent.tag.name === \"md\" || parentParent.tag.name === \"markdown\")) {\n          var _text2 = parent.quasis[0].value.raw.replace(/((?:\\\\\\\\)*)\\\\`/g, function (_, backslashes) {\n            return \"\\\\\".repeat(backslashes.length / 2) + \"`\";\n          });\n\n          var indentation = getIndentation(_text2);\n          var hasIndent = indentation !== \"\";\n          return concat([hasIndent ? indent(concat([softline, printMarkdown(_text2.replace(new RegExp(\"^\".concat(indentation), \"gm\"), \"\"))])) : concat([literalline, dedentToRoot(printMarkdown(_text2))]), softline]);\n        }\n\n        break;\n      }\n  }\n\n  function printMarkdown(text) {\n    var doc = textToDoc(text, {\n      parser: \"markdown\",\n      __inJsTemplate: true\n    });\n    return stripTrailingHardline(escapeTemplateCharacters(doc, true));\n  }\n}\n\nfunction getIndentation(str) {\n  var firstMatchedIndent = str.match(/^([^\\S\\n]*)\\S/m);\n  return firstMatchedIndent === null ? \"\" : firstMatchedIndent[1];\n}\n\nfunction uncook(cookedValue) {\n  return cookedValue.replace(/([\\\\`]|\\$\\{)/g, \"\\\\$1\");\n}\n\nfunction escapeTemplateCharacters(doc, raw) {\n  return mapDoc(doc, function (currentDoc) {\n    if (!currentDoc.parts) {\n      return currentDoc;\n    }\n\n    var parts = [];\n    currentDoc.parts.forEach(function (part) {\n      if (typeof part === \"string\") {\n        parts.push(raw ? part.replace(/(\\\\*)`/g, \"$1$1\\\\`\") : uncook(part));\n      } else {\n        parts.push(part);\n      }\n    });\n    return Object.assign({}, currentDoc, {\n      parts: parts\n    });\n  });\n}\n\nfunction transformCssDoc(quasisDoc, path, print) {\n  var parentNode = path.getValue();\n  var isEmpty = parentNode.quasis.length === 1 && !parentNode.quasis[0].value.raw.trim();\n\n  if (isEmpty) {\n    return \"``\";\n  }\n\n  var expressionDocs = parentNode.expressions ? path.map(print, \"expressions\") : [];\n  var newDoc = replacePlaceholders(quasisDoc, expressionDocs);\n  /* istanbul ignore if */\n\n  if (!newDoc) {\n    throw new Error(\"Couldn't insert all the expressions\");\n  }\n\n  return concat([\"`\", indent(concat([hardline, stripTrailingHardline(newDoc)])), softline, \"`\"]);\n} // Search all the placeholders in the quasisDoc tree\n// and replace them with the expression docs one by one\n// returns a new doc with all the placeholders replaced,\n// or null if it couldn't replace any expression\n\n\nfunction replacePlaceholders(quasisDoc, expressionDocs) {\n  if (!expressionDocs || !expressionDocs.length) {\n    return quasisDoc;\n  }\n\n  var expressions = expressionDocs.slice();\n  var replaceCounter = 0;\n  var newDoc = mapDoc(quasisDoc, function (doc) {\n    if (!doc || !doc.parts || !doc.parts.length) {\n      return doc;\n    }\n\n    var parts = doc.parts;\n    var atIndex = parts.indexOf(\"@\");\n    var placeholderIndex = atIndex + 1;\n\n    if (atIndex > -1 && typeof parts[placeholderIndex] === \"string\" && parts[placeholderIndex].startsWith(\"prettier-placeholder\")) {\n      // If placeholder is split, join it\n      var at = parts[atIndex];\n      var placeholder = parts[placeholderIndex];\n      var rest = parts.slice(placeholderIndex + 1);\n      parts = parts.slice(0, atIndex).concat([at + placeholder]).concat(rest);\n    }\n\n    var atPlaceholderIndex = parts.findIndex(function (part) {\n      return typeof part === \"string\" && part.startsWith(\"@prettier-placeholder\");\n    });\n\n    if (atPlaceholderIndex > -1) {\n      var _placeholder = parts[atPlaceholderIndex];\n\n      var _rest = parts.slice(atPlaceholderIndex + 1);\n\n      var placeholderMatch = _placeholder.match(/@prettier-placeholder-(.+)-id([\\s\\S]*)/);\n\n      var placeholderID = placeholderMatch[1]; // When the expression has a suffix appended, like:\n      // animation: linear ${time}s ease-out;\n\n      var suffix = placeholderMatch[2];\n      var expression = expressions[placeholderID];\n      replaceCounter++;\n      parts = parts.slice(0, atPlaceholderIndex).concat([\"${\", expression, \"}\" + suffix]).concat(_rest);\n    }\n\n    return Object.assign({}, doc, {\n      parts: parts\n    });\n  });\n  return expressions.length === replaceCounter ? newDoc : null;\n}\n\nfunction printGraphqlComments(lines) {\n  var parts = [];\n  var seenComment = false;\n  lines.map(function (textLine) {\n    return textLine.trim();\n  }).forEach(function (textLine, i, array) {\n    // Lines are either whitespace only, or a comment (with poential whitespace\n    // around it). Drop whitespace-only lines.\n    if (textLine === \"\") {\n      return;\n    }\n\n    if (array[i - 1] === \"\" && seenComment) {\n      // If a non-first comment is preceded by a blank (whitespace only) line,\n      // add in a blank line.\n      parts.push(concat([hardline, textLine]));\n    } else {\n      parts.push(textLine);\n    }\n\n    seenComment = true;\n  }); // If `lines` was whitespace only, return `null`.\n\n  return parts.length === 0 ? null : join(hardline, parts);\n}\n/**\n * Template literal in these contexts:\n * <style jsx>{`div{color:red}`}</style>\n * css``\n * css.global``\n * css.resolve``\n */\n\n\nfunction isStyledJsx(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  var parentParent = path.getParentNode(1);\n  return parentParent && node.quasis && parent.type === \"JSXExpressionContainer\" && parentParent.type === \"JSXElement\" && parentParent.openingElement.name.name === \"style\" && parentParent.openingElement.attributes.some(function (attribute) {\n    return attribute.name.name === \"jsx\";\n  }) || parent && parent.type === \"TaggedTemplateExpression\" && parent.tag.type === \"Identifier\" && parent.tag.name === \"css\" || parent && parent.type === \"TaggedTemplateExpression\" && parent.tag.type === \"MemberExpression\" && parent.tag.object.name === \"css\" && (parent.tag.property.name === \"global\" || parent.tag.property.name === \"resolve\");\n}\n/**\n * Angular Components can have:\n * - Inline HTML template\n * - Inline CSS styles\n *\n * ...which are both within template literals somewhere\n * inside of the Component decorator factory.\n *\n * E.g.\n * @Component({\n *  template: `<div>...</div>`,\n *  styles: [`h1 { color: blue; }`]\n * })\n */\n\n\nfunction isAngularComponentStyles(path) {\n  return isPathMatch(path, [function (node) {\n    return node.type === \"TemplateLiteral\";\n  }, function (node, name) {\n    return node.type === \"ArrayExpression\" && name === \"elements\";\n  }, function (node, name) {\n    return node.type === \"Property\" && node.key.type === \"Identifier\" && node.key.name === \"styles\" && name === \"value\";\n  }].concat(getAngularComponentObjectExpressionPredicates()));\n}\n\nfunction isAngularComponentTemplate(path) {\n  return isPathMatch(path, [function (node) {\n    return node.type === \"TemplateLiteral\";\n  }, function (node, name) {\n    return node.type === \"Property\" && node.key.type === \"Identifier\" && node.key.name === \"template\" && name === \"value\";\n  }].concat(getAngularComponentObjectExpressionPredicates()));\n}\n\nfunction getAngularComponentObjectExpressionPredicates() {\n  return [function (node, name) {\n    return node.type === \"ObjectExpression\" && name === \"properties\";\n  }, function (node, name) {\n    return node.type === \"CallExpression\" && node.callee.type === \"Identifier\" && node.callee.name === \"Component\" && name === \"arguments\";\n  }, function (node, name) {\n    return node.type === \"Decorator\" && name === \"expression\";\n  }];\n}\n/**\n * styled-components template literals\n */\n\n\nfunction isStyledComponents(path) {\n  var parent = path.getParentNode();\n\n  if (!parent || parent.type !== \"TaggedTemplateExpression\") {\n    return false;\n  }\n\n  var tag = parent.tag;\n\n  switch (tag.type) {\n    case \"MemberExpression\":\n      return (// styled.foo``\n        isStyledIdentifier(tag.object) || // Component.extend``\n        isStyledExtend(tag)\n      );\n\n    case \"CallExpression\":\n      return (// styled(Component)``\n        isStyledIdentifier(tag.callee) || tag.callee.type === \"MemberExpression\" && (tag.callee.object.type === \"MemberExpression\" && ( // styled.foo.attrs({})``\n        isStyledIdentifier(tag.callee.object.object) || // Component.extend.attrs({})``\n        isStyledExtend(tag.callee.object)) || // styled(Component).attrs({})``\n        tag.callee.object.type === \"CallExpression\" && isStyledIdentifier(tag.callee.object.callee))\n      );\n\n    case \"Identifier\":\n      // css``\n      return tag.name === \"css\";\n\n    default:\n      return false;\n  }\n}\n/**\n * JSX element with CSS prop\n */\n\n\nfunction isCssProp(path) {\n  var parent = path.getParentNode();\n  var parentParent = path.getParentNode(1);\n  return parentParent && parent.type === \"JSXExpressionContainer\" && parentParent.type === \"JSXAttribute\" && parentParent.name.type === \"JSXIdentifier\" && parentParent.name.name === \"css\";\n}\n\nfunction isStyledIdentifier(node) {\n  return node.type === \"Identifier\" && node.name === \"styled\";\n}\n\nfunction isStyledExtend(node) {\n  return /^[A-Z]/.test(node.object.name) && node.property.name === \"extend\";\n}\n/*\n * react-relay and graphql-tag\n * graphql`...`\n * graphql.experimental`...`\n * gql`...`\n * GraphQL comment block\n *\n * This intentionally excludes Relay Classic tags, as Prettier does not\n * support Relay Classic formatting.\n */\n\n\nfunction isGraphQL(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  return hasLanguageComment(node, \"GraphQL\") || parent && (parent.type === \"TaggedTemplateExpression\" && (parent.tag.type === \"MemberExpression\" && parent.tag.object.name === \"graphql\" && parent.tag.property.name === \"experimental\" || parent.tag.type === \"Identifier\" && (parent.tag.name === \"gql\" || parent.tag.name === \"graphql\")) || parent.type === \"CallExpression\" && parent.callee.type === \"Identifier\" && parent.callee.name === \"graphql\");\n}\n\nfunction hasLanguageComment(node, languageName) {\n  // This checks for a leading comment that is exactly `/* GraphQL */`\n  // In order to be in line with other implementations of this comment tag\n  // we will not trim the comment value and we will expect exactly one space on\n  // either side of the GraphQL string\n  // Also see ./clean.js\n  return hasLeadingComment(node, function (comment) {\n    return isBlockComment(comment) && comment.value === \" \".concat(languageName, \" \");\n  });\n}\n\nfunction isPathMatch(path, predicateStack) {\n  var stack = path.stack.slice();\n  var name = null;\n  var node = stack.pop();\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = predicateStack[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var predicate = _step.value;\n\n      if (node === undefined) {\n        return false;\n      } // skip index/array\n\n\n      if (typeof name === \"number\") {\n        name = stack.pop();\n        node = stack.pop();\n      }\n\n      if (!predicate(node, name)) {\n        return false;\n      }\n\n      name = stack.pop();\n      node = stack.pop();\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n *     - html`...`\n *     - HTML comment block\n */\n\n\nfunction isHtml(path) {\n  var node = path.getValue();\n  return hasLanguageComment(node, \"HTML\") || isPathMatch(path, [function (node) {\n    return node.type === \"TemplateLiteral\";\n  }, function (node, name) {\n    return node.type === \"TaggedTemplateExpression\" && node.tag.type === \"Identifier\" && node.tag.name === \"html\" && name === \"quasi\";\n  }]);\n} // The counter is needed to distinguish nested embeds.\n\n\nvar htmlTemplateLiteralCounter = 0;\n\nfunction printHtmlTemplateLiteral(path, print, textToDoc, parser, escapeClosingScriptTag) {\n  var node = path.getValue();\n  var counter = htmlTemplateLiteralCounter;\n  htmlTemplateLiteralCounter = htmlTemplateLiteralCounter + 1 >>> 0;\n\n  var composePlaceholder = function composePlaceholder(index) {\n    return \"PRETTIER_HTML_PLACEHOLDER_\".concat(index, \"_\").concat(counter, \"_IN_JS\");\n  };\n\n  var text = node.quasis.map(function (quasi, index, quasis) {\n    return index === quasis.length - 1 ? quasi.value.cooked : quasi.value.cooked + composePlaceholder(index);\n  }).join(\"\");\n  var expressionDocs = path.map(print, \"expressions\");\n\n  if (expressionDocs.length === 0 && text.trim().length === 0) {\n    return \"``\";\n  }\n\n  var placeholderRegex = RegExp(composePlaceholder(\"(\\\\d+)\"), \"g\");\n  var contentDoc = mapDoc(stripTrailingHardline(textToDoc(text, {\n    parser: parser\n  })), function (doc) {\n    if (typeof doc !== \"string\") {\n      return doc;\n    }\n\n    var parts = [];\n    var components = doc.split(placeholderRegex);\n\n    for (var i = 0; i < components.length; i++) {\n      var component = components[i];\n\n      if (i % 2 === 0) {\n        if (component) {\n          component = uncook(component);\n\n          if (escapeClosingScriptTag) {\n            component = component.replace(/<\\/(script)\\b/gi, \"<\\\\/$1\");\n          }\n\n          parts.push(component);\n        }\n\n        continue;\n      }\n\n      var placeholderIndex = +component;\n      parts.push(concat([\"${\", group(expressionDocs[placeholderIndex]), \"}\"]));\n    }\n\n    return concat(parts);\n  });\n  return group(concat([\"`\", indent(concat([hardline, group(contentDoc)])), softline, \"`\"]));\n}\n\nmodule.exports = embed;"]},"metadata":{},"sourceType":"script"}