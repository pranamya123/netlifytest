{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.helper = helper;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\n\nvar _helperAnnotateAsPure = _interopRequireDefault(require(\"@babel/helper-annotate-as-pure\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst DEFAULT = {\n  importSource: \"react\",\n  runtime: \"automatic\",\n  pragma: \"React.createElement\",\n  pragmaFrag: \"React.Fragment\"\n};\n\nfunction helper(babel, options) {\n  const FILE_NAME_VAR = \"_jsxFileName\";\n  const JSX_SOURCE_ANNOTATION_REGEX = /\\*?\\s*@jsxImportSource\\s+([^\\s]+)/;\n  const JSX_RUNTIME_ANNOTATION_REGEX = /\\*?\\s*@jsxRuntime\\s+([^\\s]+)/;\n  const JSX_ANNOTATION_REGEX = /\\*?\\s*@jsx\\s+([^\\s]+)/;\n  const JSX_FRAG_ANNOTATION_REGEX = /\\*?\\s*@jsxFrag\\s+([^\\s]+)/;\n  const IMPORT_NAME_SIZE = options.development ? 3 : 4;\n  const {\n    importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource,\n    runtime: RUNTIME_DEFAULT = DEFAULT.runtime,\n    pragma: PRAGMA_DEFAULT = DEFAULT.pragma,\n    pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag\n  } = options;\n  const injectMetaPropertiesVisitor = {\n    JSXOpeningElement(path, state) {\n      for (const attr of path.get(\"attributes\")) {\n        if (!attr.isJSXElement()) continue;\n        const {\n          name\n        } = attr.node.name;\n\n        if (name === \"__source\" || name === \"__self\") {\n          throw path.buildCodeFrameError(`__source and __self should not be defined in props and are reserved for internal usage.`);\n        }\n      }\n\n      const source = t.jsxAttribute(t.jsxIdentifier(\"__source\"), t.jsxExpressionContainer(makeSource(path, state)));\n      const self = t.jsxAttribute(t.jsxIdentifier(\"__self\"), t.jsxExpressionContainer(t.thisExpression()));\n      path.pushContainer(\"attributes\", [source, self]);\n    }\n\n  };\n  return {\n    JSXNamespacedName(path, state) {\n      const throwIfNamespace = state.opts.throwIfNamespace === undefined ? true : !!state.opts.throwIfNamespace;\n\n      if (throwIfNamespace) {\n        throw path.buildCodeFrameError(`Namespace tags are not supported by default. React's JSX doesn't support namespace tags. \\\nYou can set \\`throwIfNamespace: false\\` to bypass this warning.`);\n      }\n    },\n\n    JSXSpreadChild(path) {\n      throw path.buildCodeFrameError(\"Spread children are not supported in React.\");\n    },\n\n    JSXElement: {\n      exit(path, file) {\n        let callExpr;\n\n        if (file.get(\"@babel/plugin-react-jsx/runtime\") === \"classic\" || shouldUseCreateElement(path)) {\n          callExpr = buildCreateElementCall(path, file);\n        } else {\n          callExpr = buildJSXElementCall(path, file);\n        }\n\n        path.replaceWith(t.inherits(callExpr, path.node));\n      }\n\n    },\n    JSXFragment: {\n      exit(path, file) {\n        let callExpr;\n\n        if (file.get(\"@babel/plugin-react-jsx/runtime\") === \"classic\") {\n          callExpr = buildCreateElementFragmentCall(path, file);\n        } else {\n          callExpr = buildJSXFragmentCall(path, file);\n        }\n\n        path.replaceWith(t.inherits(callExpr, path.node));\n      }\n\n    },\n\n    JSXAttribute(path) {\n      if (t.isJSXElement(path.node.value)) {\n        path.node.value = t.jsxExpressionContainer(path.node.value);\n      }\n    },\n\n    Program: {\n      enter(path, state) {\n        if (hasJSX(path)) {\n          const {\n            file\n          } = state;\n          let runtime = RUNTIME_DEFAULT;\n          let source = IMPORT_SOURCE_DEFAULT;\n          let sourceSet = !!options.importSource;\n          let pragma = PRAGMA_DEFAULT;\n          let pragmaFrag = PRAGMA_FRAG_DEFAULT;\n          let pragmaSet = !!options.pragma;\n          let pragmaFragSet = !!options.pragmaFrag;\n\n          if (file.ast.comments) {\n            for (const comment of file.ast.comments) {\n              const sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);\n\n              if (sourceMatches) {\n                source = sourceMatches[1];\n                sourceSet = true;\n              }\n\n              const runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);\n\n              if (runtimeMatches) {\n                runtime = runtimeMatches[1];\n              }\n\n              const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n\n              if (jsxMatches) {\n                pragma = jsxMatches[1];\n                pragmaSet = true;\n              }\n\n              const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);\n\n              if (jsxFragMatches) {\n                pragmaFrag = jsxFragMatches[1];\n                pragmaFragSet = true;\n              }\n            }\n          }\n\n          state.set(\"@babel/plugin-react-jsx/runtime\", runtime);\n\n          if (runtime === \"classic\") {\n            if (sourceSet) {\n              throw path.buildCodeFrameError(`importSource cannot be set when runtime is classic.`);\n            }\n\n            state.set(\"@babel/plugin-react-jsx/createElementIdentifier\", createIdentifierParser(pragma));\n            state.set(\"@babel/plugin-react-jsx/jsxFragIdentifier\", createIdentifierParser(pragmaFrag));\n            state.set(\"@babel/plugin-react-jsx/usedFragment\", false);\n            state.set(\"@babel/plugin-react-jsx/pragmaSet\", pragma !== DEFAULT.pragma);\n            state.set(\"@babel/plugin-react-jsx/pragmaFragSet\", pragmaFrag !== DEFAULT.pragmaFrag);\n          } else if (runtime === \"automatic\") {\n            if (pragmaSet || pragmaFragSet) {\n              throw path.buildCodeFrameError(`pragma and pragmaFrag cannot be set when runtime is automatic.`);\n            }\n\n            const importName = addAutoImports(path, Object.assign({}, state.opts, {\n              source\n            }));\n            state.set(\"@babel/plugin-react-jsx/jsxIdentifier\", createIdentifierParser(createIdentifierName(path, options.development ? \"jsxDEV\" : \"jsx\", importName)));\n            state.set(\"@babel/plugin-react-jsx/jsxStaticIdentifier\", createIdentifierParser(createIdentifierName(path, options.development ? \"jsxDEV\" : \"jsxs\", importName)));\n            state.set(\"@babel/plugin-react-jsx/createElementIdentifier\", createIdentifierParser(createIdentifierName(path, \"createElement\", importName)));\n            state.set(\"@babel/plugin-react-jsx/jsxFragIdentifier\", createIdentifierParser(createIdentifierName(path, \"Fragment\", importName)));\n            state.set(\"@babel/plugin-react-jsx/importSourceSet\", source !== DEFAULT.importSource);\n          } else {\n            throw path.buildCodeFrameError(`Runtime must be either \"classic\" or \"automatic\".`);\n          }\n\n          if (options.development) {\n            path.traverse(injectMetaPropertiesVisitor, state);\n          }\n        }\n      },\n\n      exit(path, state) {\n        if (state.get(\"@babel/plugin-react-jsx/runtime\") === \"classic\" && state.get(\"@babel/plugin-react-jsx/pragmaSet\") && state.get(\"@babel/plugin-react-jsx/usedFragment\") && !state.get(\"@babel/plugin-react-jsx/pragmaFragSet\")) {\n          throw new Error(\"transform-react-jsx: pragma has been set but \" + \"pragmaFrag has not been set\");\n        }\n      }\n\n    }\n  };\n\n  function shouldUseCreateElement(path) {\n    const openingPath = path.get(\"openingElement\");\n    const attributes = openingPath.node.attributes;\n    let seenPropsSpread = false;\n\n    for (let i = 0; i < attributes.length; i++) {\n      const attr = attributes[i];\n\n      if (seenPropsSpread && t.isJSXAttribute(attr) && attr.name.name === \"key\") {\n        return true;\n      } else if (t.isJSXSpreadAttribute(attr)) {\n        seenPropsSpread = true;\n      }\n    }\n\n    return false;\n  }\n\n  function createIdentifierName(path, name, importName) {\n    if ((0, _helperModuleImports.isModule)(path)) {\n      const identifierName = `${importName[name]}`;\n      return identifierName;\n    } else {\n      return `${importName[name]}.${name}`;\n    }\n  }\n\n  function getImportNames(parentPath) {\n    const imports = new Set();\n    parentPath.traverse({\n      \"JSXElement|JSXFragment\"(path) {\n        if (path.type === \"JSXFragment\") imports.add(\"Fragment\");\n        const openingPath = path.get(\"openingElement\");\n        const validChildren = t.react.buildChildren(openingPath.parent);\n        let importName;\n\n        if (path.type === \"JSXElement\" && shouldUseCreateElement(path)) {\n          importName = \"createElement\";\n        } else if (options.development) {\n          importName = \"jsxDEV\";\n        } else if (validChildren.length > 1) {\n          importName = \"jsxs\";\n        } else {\n          importName = \"jsx\";\n        }\n\n        imports.add(importName);\n\n        if (imports.size === IMPORT_NAME_SIZE) {\n          path.stop();\n        }\n      }\n\n    });\n    return imports;\n  }\n\n  function hasJSX(parentPath) {\n    let fileHasJSX = false;\n    parentPath.traverse({\n      \"JSXElement|JSXFragment\"(path) {\n        fileHasJSX = true;\n        path.stop();\n      }\n\n    });\n    return fileHasJSX;\n  }\n\n  function getSource(source, importName) {\n    switch (importName) {\n      case \"Fragment\":\n        return `${source}/${options.development ? \"jsx-dev-runtime\" : \"jsx-runtime\"}`;\n\n      case \"jsxDEV\":\n        return `${source}/jsx-dev-runtime`;\n\n      case \"jsx\":\n      case \"jsxs\":\n        return `${source}/jsx-runtime`;\n\n      case \"createElement\":\n        return source;\n    }\n  }\n\n  function addAutoImports(path, state) {\n    const imports = getImportNames(path, state);\n\n    if ((0, _helperModuleImports.isModule)(path)) {\n      const importMap = {};\n      imports.forEach(importName => {\n        if (!importMap[importName]) {\n          importMap[importName] = (0, _helperModuleImports.addNamed)(path, importName, getSource(state.source, importName), {\n            importedInterop: \"uncompiled\",\n            ensureLiveReference: true\n          }).name;\n        }\n      });\n      return importMap;\n    } else {\n      const importMap = {};\n      const sourceMap = {};\n      imports.forEach(importName => {\n        const source = getSource(state.source, importName);\n\n        if (!importMap[importName]) {\n          if (!sourceMap[source]) {\n            sourceMap[source] = (0, _helperModuleImports.addNamespace)(path, source, {\n              importedInterop: \"uncompiled\",\n              ensureLiveReference: true\n            }).name;\n          }\n\n          importMap[importName] = sourceMap[source];\n        }\n      });\n      return importMap;\n    }\n  }\n\n  function createIdentifierParser(id) {\n    return () => {\n      return id.split(\".\").map(name => t.identifier(name)).reduce((object, property) => t.memberExpression(object, property));\n    };\n  }\n\n  function makeTrace(fileNameIdentifier, lineNumber, column0Based) {\n    const fileLineLiteral = lineNumber != null ? t.numericLiteral(lineNumber) : t.nullLiteral();\n    const fileColumnLiteral = column0Based != null ? t.numericLiteral(column0Based + 1) : t.nullLiteral();\n    const fileNameProperty = t.objectProperty(t.identifier(\"fileName\"), fileNameIdentifier);\n    const lineNumberProperty = t.objectProperty(t.identifier(\"lineNumber\"), fileLineLiteral);\n    const columnNumberProperty = t.objectProperty(t.identifier(\"columnNumber\"), fileColumnLiteral);\n    return t.objectExpression([fileNameProperty, lineNumberProperty, columnNumberProperty]);\n  }\n\n  function makeSource(path, state) {\n    const location = path.node.loc;\n\n    if (!location) {\n      return;\n    }\n\n    if (!state.fileNameIdentifier) {\n      const {\n        filename = \"\"\n      } = state;\n      const fileNameIdentifier = path.scope.generateUidIdentifier(FILE_NAME_VAR);\n      const scope = path.hub.getScope();\n\n      if (scope) {\n        scope.push({\n          id: fileNameIdentifier,\n          init: t.stringLiteral(filename)\n        });\n      }\n\n      state.fileNameIdentifier = fileNameIdentifier;\n    }\n\n    return makeTrace(t.cloneNode(state.fileNameIdentifier), location.start.line, location.start.column);\n  }\n\n  function convertJSXIdentifier(node, parent) {\n    if (t.isJSXIdentifier(node)) {\n      if (node.name === \"this\" && t.isReferenced(node, parent)) {\n        return t.thisExpression();\n      } else if (t.isValidIdentifier(node.name, false)) {\n        node.type = \"Identifier\";\n      } else {\n        return t.stringLiteral(node.name);\n      }\n    } else if (t.isJSXMemberExpression(node)) {\n      return t.memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));\n    } else if (t.isJSXNamespacedName(node)) {\n      return t.stringLiteral(`${node.namespace.name}:${node.name.name}`);\n    }\n\n    return node;\n  }\n\n  function convertAttributeValue(node) {\n    if (t.isJSXExpressionContainer(node)) {\n      return node.expression;\n    } else {\n      return node;\n    }\n  }\n\n  function convertAttribute(node) {\n    const value = convertAttributeValue(node.value || t.booleanLiteral(true));\n\n    if (t.isJSXSpreadAttribute(node)) {\n      return t.spreadElement(node.argument);\n    }\n\n    if (t.isStringLiteral(value) && !t.isJSXExpressionContainer(node.value)) {\n      value.value = value.value.replace(/\\n\\s+/g, \" \");\n\n      if (value.extra && value.extra.raw) {\n        delete value.extra.raw;\n      }\n    }\n\n    if (t.isJSXNamespacedName(node.name)) {\n      node.name = t.stringLiteral(node.name.namespace.name + \":\" + node.name.name.name);\n    } else if (t.isValidIdentifier(node.name.name, false)) {\n      node.name.type = \"Identifier\";\n    } else {\n      node.name = t.stringLiteral(node.name.name);\n    }\n\n    return t.inherits(t.objectProperty(node.name, value), node);\n  }\n\n  function buildJSXElementCall(path, file) {\n    const openingPath = path.get(\"openingElement\");\n    openingPath.parent.children = t.react.buildChildren(openingPath.parent);\n    const tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);\n    const args = [];\n    let tagName;\n\n    if (t.isIdentifier(tagExpr)) {\n      tagName = tagExpr.name;\n    } else if (t.isLiteral(tagExpr)) {\n      tagName = tagExpr.value;\n    }\n\n    const state = {\n      tagExpr: tagExpr,\n      tagName: tagName,\n      args: args,\n      pure: false\n    };\n\n    if (options.pre) {\n      options.pre(state, file);\n    }\n\n    let attribs = [];\n    const extracted = Object.create(null);\n\n    for (const attr of openingPath.get(\"attributes\")) {\n      if (attr.isJSXAttribute() && t.isJSXIdentifier(attr.node.name)) {\n        const {\n          name\n        } = attr.node.name;\n\n        switch (name) {\n          case \"__source\":\n          case \"__self\":\n            if (extracted[name]) throw sourceSelfError(path, name);\n\n          case \"key\":\n            extracted[name] = convertAttributeValue(attr.node.value);\n            break;\n\n          default:\n            attribs.push(attr.node);\n        }\n      } else {\n        attribs.push(attr.node);\n      }\n    }\n\n    if (attribs.length || path.node.children.length) {\n      attribs = buildJSXOpeningElementAttributes(attribs, file, path.node.children);\n    } else {\n      attribs = t.objectExpression([]);\n    }\n\n    args.push(attribs);\n\n    if (!options.development) {\n      if (extracted.key !== undefined) {\n        args.push(extracted.key);\n      }\n    } else {\n      var _extracted$key, _extracted$__source, _extracted$__self;\n\n      args.push((_extracted$key = extracted.key) != null ? _extracted$key : path.scope.buildUndefinedNode(), t.booleanLiteral(path.node.children.length > 1), (_extracted$__source = extracted.__source) != null ? _extracted$__source : path.scope.buildUndefinedNode(), (_extracted$__self = extracted.__self) != null ? _extracted$__self : t.thisExpression());\n    }\n\n    if (options.post) {\n      options.post(state, file);\n    }\n\n    const call = state.call || t.callExpression(path.node.children.length > 1 ? state.jsxStaticCallee : state.jsxCallee, args);\n    if (state.pure) (0, _helperAnnotateAsPure.default)(call);\n    return call;\n  }\n\n  function buildJSXOpeningElementAttributes(attribs, file, children) {\n    const props = attribs.map(convertAttribute);\n\n    if (children && children.length > 0) {\n      if (children.length === 1) {\n        props.push(t.objectProperty(t.identifier(\"children\"), children[0]));\n      } else {\n        props.push(t.objectProperty(t.identifier(\"children\"), t.arrayExpression(children)));\n      }\n    }\n\n    return t.objectExpression(props);\n  }\n\n  function buildJSXFragmentCall(path, file) {\n    const openingPath = path.get(\"openingElement\");\n    openingPath.parent.children = t.react.buildChildren(openingPath.parent);\n    const args = [];\n    const tagName = null;\n    const tagExpr = file.get(\"@babel/plugin-react-jsx/jsxFragIdentifier\")();\n    const state = {\n      tagExpr: tagExpr,\n      tagName: tagName,\n      args: args,\n      pure: false\n    };\n\n    if (options.pre) {\n      options.pre(state, file);\n    }\n\n    let childrenNode;\n\n    if (path.node.children.length > 0) {\n      if (path.node.children.length === 1) {\n        childrenNode = path.node.children[0];\n      } else {\n        childrenNode = t.arrayExpression(path.node.children);\n      }\n    }\n\n    args.push(t.objectExpression(childrenNode !== undefined ? [t.objectProperty(t.identifier(\"children\"), childrenNode)] : []));\n\n    if (options.development) {\n      args.push(path.scope.buildUndefinedNode(), t.booleanLiteral(path.node.children.length > 1));\n    }\n\n    if (options.post) {\n      options.post(state, file);\n    }\n\n    const call = state.call || t.callExpression(path.node.children.length > 1 ? state.jsxStaticCallee : state.jsxCallee, args);\n    if (state.pure) (0, _helperAnnotateAsPure.default)(call);\n    return call;\n  }\n\n  function buildCreateElementFragmentCall(path, file) {\n    if (options.filter && !options.filter(path.node, file)) {\n      return;\n    }\n\n    const openingPath = path.get(\"openingElement\");\n    openingPath.parent.children = t.react.buildChildren(openingPath.parent);\n    const args = [];\n    const tagName = null;\n    const tagExpr = file.get(\"@babel/plugin-react-jsx/jsxFragIdentifier\")();\n    const state = {\n      tagExpr: tagExpr,\n      tagName: tagName,\n      args: args,\n      pure: false\n    };\n\n    if (options.pre) {\n      options.pre(state, file);\n    }\n\n    args.push(t.nullLiteral(), ...path.node.children);\n\n    if (options.post) {\n      options.post(state, file);\n    }\n\n    file.set(\"@babel/plugin-react-jsx/usedFragment\", true);\n    const call = state.call || t.callExpression(state.createElementCallee, args);\n    if (state.pure) (0, _helperAnnotateAsPure.default)(call);\n    return call;\n  }\n\n  function buildCreateElementCall(path, file) {\n    const openingPath = path.get(\"openingElement\");\n    openingPath.parent.children = t.react.buildChildren(openingPath.parent);\n    const tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);\n    const args = [];\n    let tagName;\n\n    if (t.isIdentifier(tagExpr)) {\n      tagName = tagExpr.name;\n    } else if (t.isLiteral(tagExpr)) {\n      tagName = tagExpr.value;\n    }\n\n    const state = {\n      tagExpr: tagExpr,\n      tagName: tagName,\n      args: args,\n      pure: false\n    };\n\n    if (options.pre) {\n      options.pre(state, file);\n    }\n\n    const attribs = buildCreateElementOpeningElementAttributes(path, openingPath.node.attributes);\n    args.push(attribs, ...path.node.children);\n\n    if (options.post) {\n      options.post(state, file);\n    }\n\n    const call = state.call || t.callExpression(state.createElementCallee, args);\n    if (state.pure) (0, _helperAnnotateAsPure.default)(call);\n    return call;\n  }\n\n  function buildCreateElementOpeningElementAttributes(path, attribs) {\n    const props = [];\n    const found = Object.create(null);\n\n    for (const attr of attribs) {\n      const name = t.isJSXAttribute(attr) && t.isJSXIdentifier(attr.name) && attr.name.name;\n\n      if (name === \"__source\" || name === \"__self\") {\n        if (found[name]) throw sourceSelfError(path, name);\n        found[name] = true;\n        if (!options.development) continue;\n      }\n\n      props.push(convertAttribute(attr));\n    }\n\n    return props.length > 0 ? t.objectExpression(props) : t.nullLiteral();\n  }\n\n  function sourceSelfError(path, name) {\n    const pluginName = `transform-react-jsx-${name.slice(2)}`;\n    return path.buildCodeFrameError(`Duplicate ${name} prop found. You are most likely using the deprecated ${pluginName} Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.`);\n  }\n}","map":{"version":3,"sources":["/Users/pranamyavadlamani/Desktop/Research/PortFolio/portfolio-site/node_modules/@babel/helper-builder-react-jsx-experimental/lib/index.js"],"names":["Object","defineProperty","exports","value","helper","t","_interopRequireWildcard","require","_helperModuleImports","_helperAnnotateAsPure","_interopRequireDefault","obj","__esModule","default","_getRequireWildcardCache","WeakMap","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","DEFAULT","importSource","runtime","pragma","pragmaFrag","babel","options","FILE_NAME_VAR","JSX_SOURCE_ANNOTATION_REGEX","JSX_RUNTIME_ANNOTATION_REGEX","JSX_ANNOTATION_REGEX","JSX_FRAG_ANNOTATION_REGEX","IMPORT_NAME_SIZE","development","IMPORT_SOURCE_DEFAULT","RUNTIME_DEFAULT","PRAGMA_DEFAULT","PRAGMA_FRAG_DEFAULT","injectMetaPropertiesVisitor","JSXOpeningElement","path","state","attr","isJSXElement","name","node","buildCodeFrameError","source","jsxAttribute","jsxIdentifier","jsxExpressionContainer","makeSource","self","thisExpression","pushContainer","JSXNamespacedName","throwIfNamespace","opts","undefined","JSXSpreadChild","JSXElement","exit","file","callExpr","shouldUseCreateElement","buildCreateElementCall","buildJSXElementCall","replaceWith","inherits","JSXFragment","buildCreateElementFragmentCall","buildJSXFragmentCall","JSXAttribute","Program","enter","hasJSX","sourceSet","pragmaSet","pragmaFragSet","ast","comments","comment","sourceMatches","exec","runtimeMatches","jsxMatches","jsxFragMatches","createIdentifierParser","importName","addAutoImports","assign","createIdentifierName","traverse","Error","openingPath","attributes","seenPropsSpread","i","length","isJSXAttribute","isJSXSpreadAttribute","isModule","identifierName","getImportNames","parentPath","imports","Set","type","add","validChildren","react","buildChildren","parent","size","stop","fileHasJSX","getSource","importMap","forEach","addNamed","importedInterop","ensureLiveReference","sourceMap","addNamespace","id","split","map","identifier","reduce","object","property","memberExpression","makeTrace","fileNameIdentifier","lineNumber","column0Based","fileLineLiteral","numericLiteral","nullLiteral","fileColumnLiteral","fileNameProperty","objectProperty","lineNumberProperty","columnNumberProperty","objectExpression","location","loc","filename","scope","generateUidIdentifier","hub","getScope","push","init","stringLiteral","cloneNode","start","line","column","convertJSXIdentifier","isJSXIdentifier","isReferenced","isValidIdentifier","isJSXMemberExpression","isJSXNamespacedName","namespace","convertAttributeValue","isJSXExpressionContainer","expression","convertAttribute","booleanLiteral","spreadElement","argument","isStringLiteral","replace","extra","raw","children","tagExpr","args","tagName","isIdentifier","isLiteral","pure","pre","attribs","extracted","create","sourceSelfError","buildJSXOpeningElementAttributes","_extracted$key","_extracted$__source","_extracted$__self","buildUndefinedNode","__source","__self","post","callExpression","jsxStaticCallee","jsxCallee","props","arrayExpression","childrenNode","filter","createElementCallee","buildCreateElementOpeningElementAttributes","found","pluginName","slice"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.helper = helper;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\n\nvar _helperAnnotateAsPure = _interopRequireDefault(require(\"@babel/helper-annotate-as-pure\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst DEFAULT = {\n  importSource: \"react\",\n  runtime: \"automatic\",\n  pragma: \"React.createElement\",\n  pragmaFrag: \"React.Fragment\"\n};\n\nfunction helper(babel, options) {\n  const FILE_NAME_VAR = \"_jsxFileName\";\n  const JSX_SOURCE_ANNOTATION_REGEX = /\\*?\\s*@jsxImportSource\\s+([^\\s]+)/;\n  const JSX_RUNTIME_ANNOTATION_REGEX = /\\*?\\s*@jsxRuntime\\s+([^\\s]+)/;\n  const JSX_ANNOTATION_REGEX = /\\*?\\s*@jsx\\s+([^\\s]+)/;\n  const JSX_FRAG_ANNOTATION_REGEX = /\\*?\\s*@jsxFrag\\s+([^\\s]+)/;\n  const IMPORT_NAME_SIZE = options.development ? 3 : 4;\n  const {\n    importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource,\n    runtime: RUNTIME_DEFAULT = DEFAULT.runtime,\n    pragma: PRAGMA_DEFAULT = DEFAULT.pragma,\n    pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag\n  } = options;\n  const injectMetaPropertiesVisitor = {\n    JSXOpeningElement(path, state) {\n      for (const attr of path.get(\"attributes\")) {\n        if (!attr.isJSXElement()) continue;\n        const {\n          name\n        } = attr.node.name;\n\n        if (name === \"__source\" || name === \"__self\") {\n          throw path.buildCodeFrameError(`__source and __self should not be defined in props and are reserved for internal usage.`);\n        }\n      }\n\n      const source = t.jsxAttribute(t.jsxIdentifier(\"__source\"), t.jsxExpressionContainer(makeSource(path, state)));\n      const self = t.jsxAttribute(t.jsxIdentifier(\"__self\"), t.jsxExpressionContainer(t.thisExpression()));\n      path.pushContainer(\"attributes\", [source, self]);\n    }\n\n  };\n  return {\n    JSXNamespacedName(path, state) {\n      const throwIfNamespace = state.opts.throwIfNamespace === undefined ? true : !!state.opts.throwIfNamespace;\n\n      if (throwIfNamespace) {\n        throw path.buildCodeFrameError(`Namespace tags are not supported by default. React's JSX doesn't support namespace tags. \\\nYou can set \\`throwIfNamespace: false\\` to bypass this warning.`);\n      }\n    },\n\n    JSXSpreadChild(path) {\n      throw path.buildCodeFrameError(\"Spread children are not supported in React.\");\n    },\n\n    JSXElement: {\n      exit(path, file) {\n        let callExpr;\n\n        if (file.get(\"@babel/plugin-react-jsx/runtime\") === \"classic\" || shouldUseCreateElement(path)) {\n          callExpr = buildCreateElementCall(path, file);\n        } else {\n          callExpr = buildJSXElementCall(path, file);\n        }\n\n        path.replaceWith(t.inherits(callExpr, path.node));\n      }\n\n    },\n    JSXFragment: {\n      exit(path, file) {\n        let callExpr;\n\n        if (file.get(\"@babel/plugin-react-jsx/runtime\") === \"classic\") {\n          callExpr = buildCreateElementFragmentCall(path, file);\n        } else {\n          callExpr = buildJSXFragmentCall(path, file);\n        }\n\n        path.replaceWith(t.inherits(callExpr, path.node));\n      }\n\n    },\n\n    JSXAttribute(path) {\n      if (t.isJSXElement(path.node.value)) {\n        path.node.value = t.jsxExpressionContainer(path.node.value);\n      }\n    },\n\n    Program: {\n      enter(path, state) {\n        if (hasJSX(path)) {\n          const {\n            file\n          } = state;\n          let runtime = RUNTIME_DEFAULT;\n          let source = IMPORT_SOURCE_DEFAULT;\n          let sourceSet = !!options.importSource;\n          let pragma = PRAGMA_DEFAULT;\n          let pragmaFrag = PRAGMA_FRAG_DEFAULT;\n          let pragmaSet = !!options.pragma;\n          let pragmaFragSet = !!options.pragmaFrag;\n\n          if (file.ast.comments) {\n            for (const comment of file.ast.comments) {\n              const sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);\n\n              if (sourceMatches) {\n                source = sourceMatches[1];\n                sourceSet = true;\n              }\n\n              const runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);\n\n              if (runtimeMatches) {\n                runtime = runtimeMatches[1];\n              }\n\n              const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n\n              if (jsxMatches) {\n                pragma = jsxMatches[1];\n                pragmaSet = true;\n              }\n\n              const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);\n\n              if (jsxFragMatches) {\n                pragmaFrag = jsxFragMatches[1];\n                pragmaFragSet = true;\n              }\n            }\n          }\n\n          state.set(\"@babel/plugin-react-jsx/runtime\", runtime);\n\n          if (runtime === \"classic\") {\n            if (sourceSet) {\n              throw path.buildCodeFrameError(`importSource cannot be set when runtime is classic.`);\n            }\n\n            state.set(\"@babel/plugin-react-jsx/createElementIdentifier\", createIdentifierParser(pragma));\n            state.set(\"@babel/plugin-react-jsx/jsxFragIdentifier\", createIdentifierParser(pragmaFrag));\n            state.set(\"@babel/plugin-react-jsx/usedFragment\", false);\n            state.set(\"@babel/plugin-react-jsx/pragmaSet\", pragma !== DEFAULT.pragma);\n            state.set(\"@babel/plugin-react-jsx/pragmaFragSet\", pragmaFrag !== DEFAULT.pragmaFrag);\n          } else if (runtime === \"automatic\") {\n            if (pragmaSet || pragmaFragSet) {\n              throw path.buildCodeFrameError(`pragma and pragmaFrag cannot be set when runtime is automatic.`);\n            }\n\n            const importName = addAutoImports(path, Object.assign({}, state.opts, {\n              source\n            }));\n            state.set(\"@babel/plugin-react-jsx/jsxIdentifier\", createIdentifierParser(createIdentifierName(path, options.development ? \"jsxDEV\" : \"jsx\", importName)));\n            state.set(\"@babel/plugin-react-jsx/jsxStaticIdentifier\", createIdentifierParser(createIdentifierName(path, options.development ? \"jsxDEV\" : \"jsxs\", importName)));\n            state.set(\"@babel/plugin-react-jsx/createElementIdentifier\", createIdentifierParser(createIdentifierName(path, \"createElement\", importName)));\n            state.set(\"@babel/plugin-react-jsx/jsxFragIdentifier\", createIdentifierParser(createIdentifierName(path, \"Fragment\", importName)));\n            state.set(\"@babel/plugin-react-jsx/importSourceSet\", source !== DEFAULT.importSource);\n          } else {\n            throw path.buildCodeFrameError(`Runtime must be either \"classic\" or \"automatic\".`);\n          }\n\n          if (options.development) {\n            path.traverse(injectMetaPropertiesVisitor, state);\n          }\n        }\n      },\n\n      exit(path, state) {\n        if (state.get(\"@babel/plugin-react-jsx/runtime\") === \"classic\" && state.get(\"@babel/plugin-react-jsx/pragmaSet\") && state.get(\"@babel/plugin-react-jsx/usedFragment\") && !state.get(\"@babel/plugin-react-jsx/pragmaFragSet\")) {\n          throw new Error(\"transform-react-jsx: pragma has been set but \" + \"pragmaFrag has not been set\");\n        }\n      }\n\n    }\n  };\n\n  function shouldUseCreateElement(path) {\n    const openingPath = path.get(\"openingElement\");\n    const attributes = openingPath.node.attributes;\n    let seenPropsSpread = false;\n\n    for (let i = 0; i < attributes.length; i++) {\n      const attr = attributes[i];\n\n      if (seenPropsSpread && t.isJSXAttribute(attr) && attr.name.name === \"key\") {\n        return true;\n      } else if (t.isJSXSpreadAttribute(attr)) {\n        seenPropsSpread = true;\n      }\n    }\n\n    return false;\n  }\n\n  function createIdentifierName(path, name, importName) {\n    if ((0, _helperModuleImports.isModule)(path)) {\n      const identifierName = `${importName[name]}`;\n      return identifierName;\n    } else {\n      return `${importName[name]}.${name}`;\n    }\n  }\n\n  function getImportNames(parentPath) {\n    const imports = new Set();\n    parentPath.traverse({\n      \"JSXElement|JSXFragment\"(path) {\n        if (path.type === \"JSXFragment\") imports.add(\"Fragment\");\n        const openingPath = path.get(\"openingElement\");\n        const validChildren = t.react.buildChildren(openingPath.parent);\n        let importName;\n\n        if (path.type === \"JSXElement\" && shouldUseCreateElement(path)) {\n          importName = \"createElement\";\n        } else if (options.development) {\n          importName = \"jsxDEV\";\n        } else if (validChildren.length > 1) {\n          importName = \"jsxs\";\n        } else {\n          importName = \"jsx\";\n        }\n\n        imports.add(importName);\n\n        if (imports.size === IMPORT_NAME_SIZE) {\n          path.stop();\n        }\n      }\n\n    });\n    return imports;\n  }\n\n  function hasJSX(parentPath) {\n    let fileHasJSX = false;\n    parentPath.traverse({\n      \"JSXElement|JSXFragment\"(path) {\n        fileHasJSX = true;\n        path.stop();\n      }\n\n    });\n    return fileHasJSX;\n  }\n\n  function getSource(source, importName) {\n    switch (importName) {\n      case \"Fragment\":\n        return `${source}/${options.development ? \"jsx-dev-runtime\" : \"jsx-runtime\"}`;\n\n      case \"jsxDEV\":\n        return `${source}/jsx-dev-runtime`;\n\n      case \"jsx\":\n      case \"jsxs\":\n        return `${source}/jsx-runtime`;\n\n      case \"createElement\":\n        return source;\n    }\n  }\n\n  function addAutoImports(path, state) {\n    const imports = getImportNames(path, state);\n\n    if ((0, _helperModuleImports.isModule)(path)) {\n      const importMap = {};\n      imports.forEach(importName => {\n        if (!importMap[importName]) {\n          importMap[importName] = (0, _helperModuleImports.addNamed)(path, importName, getSource(state.source, importName), {\n            importedInterop: \"uncompiled\",\n            ensureLiveReference: true\n          }).name;\n        }\n      });\n      return importMap;\n    } else {\n      const importMap = {};\n      const sourceMap = {};\n      imports.forEach(importName => {\n        const source = getSource(state.source, importName);\n\n        if (!importMap[importName]) {\n          if (!sourceMap[source]) {\n            sourceMap[source] = (0, _helperModuleImports.addNamespace)(path, source, {\n              importedInterop: \"uncompiled\",\n              ensureLiveReference: true\n            }).name;\n          }\n\n          importMap[importName] = sourceMap[source];\n        }\n      });\n      return importMap;\n    }\n  }\n\n  function createIdentifierParser(id) {\n    return () => {\n      return id.split(\".\").map(name => t.identifier(name)).reduce((object, property) => t.memberExpression(object, property));\n    };\n  }\n\n  function makeTrace(fileNameIdentifier, lineNumber, column0Based) {\n    const fileLineLiteral = lineNumber != null ? t.numericLiteral(lineNumber) : t.nullLiteral();\n    const fileColumnLiteral = column0Based != null ? t.numericLiteral(column0Based + 1) : t.nullLiteral();\n    const fileNameProperty = t.objectProperty(t.identifier(\"fileName\"), fileNameIdentifier);\n    const lineNumberProperty = t.objectProperty(t.identifier(\"lineNumber\"), fileLineLiteral);\n    const columnNumberProperty = t.objectProperty(t.identifier(\"columnNumber\"), fileColumnLiteral);\n    return t.objectExpression([fileNameProperty, lineNumberProperty, columnNumberProperty]);\n  }\n\n  function makeSource(path, state) {\n    const location = path.node.loc;\n\n    if (!location) {\n      return;\n    }\n\n    if (!state.fileNameIdentifier) {\n      const {\n        filename = \"\"\n      } = state;\n      const fileNameIdentifier = path.scope.generateUidIdentifier(FILE_NAME_VAR);\n      const scope = path.hub.getScope();\n\n      if (scope) {\n        scope.push({\n          id: fileNameIdentifier,\n          init: t.stringLiteral(filename)\n        });\n      }\n\n      state.fileNameIdentifier = fileNameIdentifier;\n    }\n\n    return makeTrace(t.cloneNode(state.fileNameIdentifier), location.start.line, location.start.column);\n  }\n\n  function convertJSXIdentifier(node, parent) {\n    if (t.isJSXIdentifier(node)) {\n      if (node.name === \"this\" && t.isReferenced(node, parent)) {\n        return t.thisExpression();\n      } else if (t.isValidIdentifier(node.name, false)) {\n        node.type = \"Identifier\";\n      } else {\n        return t.stringLiteral(node.name);\n      }\n    } else if (t.isJSXMemberExpression(node)) {\n      return t.memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));\n    } else if (t.isJSXNamespacedName(node)) {\n      return t.stringLiteral(`${node.namespace.name}:${node.name.name}`);\n    }\n\n    return node;\n  }\n\n  function convertAttributeValue(node) {\n    if (t.isJSXExpressionContainer(node)) {\n      return node.expression;\n    } else {\n      return node;\n    }\n  }\n\n  function convertAttribute(node) {\n    const value = convertAttributeValue(node.value || t.booleanLiteral(true));\n\n    if (t.isJSXSpreadAttribute(node)) {\n      return t.spreadElement(node.argument);\n    }\n\n    if (t.isStringLiteral(value) && !t.isJSXExpressionContainer(node.value)) {\n      value.value = value.value.replace(/\\n\\s+/g, \" \");\n\n      if (value.extra && value.extra.raw) {\n        delete value.extra.raw;\n      }\n    }\n\n    if (t.isJSXNamespacedName(node.name)) {\n      node.name = t.stringLiteral(node.name.namespace.name + \":\" + node.name.name.name);\n    } else if (t.isValidIdentifier(node.name.name, false)) {\n      node.name.type = \"Identifier\";\n    } else {\n      node.name = t.stringLiteral(node.name.name);\n    }\n\n    return t.inherits(t.objectProperty(node.name, value), node);\n  }\n\n  function buildJSXElementCall(path, file) {\n    const openingPath = path.get(\"openingElement\");\n    openingPath.parent.children = t.react.buildChildren(openingPath.parent);\n    const tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);\n    const args = [];\n    let tagName;\n\n    if (t.isIdentifier(tagExpr)) {\n      tagName = tagExpr.name;\n    } else if (t.isLiteral(tagExpr)) {\n      tagName = tagExpr.value;\n    }\n\n    const state = {\n      tagExpr: tagExpr,\n      tagName: tagName,\n      args: args,\n      pure: false\n    };\n\n    if (options.pre) {\n      options.pre(state, file);\n    }\n\n    let attribs = [];\n    const extracted = Object.create(null);\n\n    for (const attr of openingPath.get(\"attributes\")) {\n      if (attr.isJSXAttribute() && t.isJSXIdentifier(attr.node.name)) {\n        const {\n          name\n        } = attr.node.name;\n\n        switch (name) {\n          case \"__source\":\n          case \"__self\":\n            if (extracted[name]) throw sourceSelfError(path, name);\n\n          case \"key\":\n            extracted[name] = convertAttributeValue(attr.node.value);\n            break;\n\n          default:\n            attribs.push(attr.node);\n        }\n      } else {\n        attribs.push(attr.node);\n      }\n    }\n\n    if (attribs.length || path.node.children.length) {\n      attribs = buildJSXOpeningElementAttributes(attribs, file, path.node.children);\n    } else {\n      attribs = t.objectExpression([]);\n    }\n\n    args.push(attribs);\n\n    if (!options.development) {\n      if (extracted.key !== undefined) {\n        args.push(extracted.key);\n      }\n    } else {\n      var _extracted$key, _extracted$__source, _extracted$__self;\n\n      args.push((_extracted$key = extracted.key) != null ? _extracted$key : path.scope.buildUndefinedNode(), t.booleanLiteral(path.node.children.length > 1), (_extracted$__source = extracted.__source) != null ? _extracted$__source : path.scope.buildUndefinedNode(), (_extracted$__self = extracted.__self) != null ? _extracted$__self : t.thisExpression());\n    }\n\n    if (options.post) {\n      options.post(state, file);\n    }\n\n    const call = state.call || t.callExpression(path.node.children.length > 1 ? state.jsxStaticCallee : state.jsxCallee, args);\n    if (state.pure) (0, _helperAnnotateAsPure.default)(call);\n    return call;\n  }\n\n  function buildJSXOpeningElementAttributes(attribs, file, children) {\n    const props = attribs.map(convertAttribute);\n\n    if (children && children.length > 0) {\n      if (children.length === 1) {\n        props.push(t.objectProperty(t.identifier(\"children\"), children[0]));\n      } else {\n        props.push(t.objectProperty(t.identifier(\"children\"), t.arrayExpression(children)));\n      }\n    }\n\n    return t.objectExpression(props);\n  }\n\n  function buildJSXFragmentCall(path, file) {\n    const openingPath = path.get(\"openingElement\");\n    openingPath.parent.children = t.react.buildChildren(openingPath.parent);\n    const args = [];\n    const tagName = null;\n    const tagExpr = file.get(\"@babel/plugin-react-jsx/jsxFragIdentifier\")();\n    const state = {\n      tagExpr: tagExpr,\n      tagName: tagName,\n      args: args,\n      pure: false\n    };\n\n    if (options.pre) {\n      options.pre(state, file);\n    }\n\n    let childrenNode;\n\n    if (path.node.children.length > 0) {\n      if (path.node.children.length === 1) {\n        childrenNode = path.node.children[0];\n      } else {\n        childrenNode = t.arrayExpression(path.node.children);\n      }\n    }\n\n    args.push(t.objectExpression(childrenNode !== undefined ? [t.objectProperty(t.identifier(\"children\"), childrenNode)] : []));\n\n    if (options.development) {\n      args.push(path.scope.buildUndefinedNode(), t.booleanLiteral(path.node.children.length > 1));\n    }\n\n    if (options.post) {\n      options.post(state, file);\n    }\n\n    const call = state.call || t.callExpression(path.node.children.length > 1 ? state.jsxStaticCallee : state.jsxCallee, args);\n    if (state.pure) (0, _helperAnnotateAsPure.default)(call);\n    return call;\n  }\n\n  function buildCreateElementFragmentCall(path, file) {\n    if (options.filter && !options.filter(path.node, file)) {\n      return;\n    }\n\n    const openingPath = path.get(\"openingElement\");\n    openingPath.parent.children = t.react.buildChildren(openingPath.parent);\n    const args = [];\n    const tagName = null;\n    const tagExpr = file.get(\"@babel/plugin-react-jsx/jsxFragIdentifier\")();\n    const state = {\n      tagExpr: tagExpr,\n      tagName: tagName,\n      args: args,\n      pure: false\n    };\n\n    if (options.pre) {\n      options.pre(state, file);\n    }\n\n    args.push(t.nullLiteral(), ...path.node.children);\n\n    if (options.post) {\n      options.post(state, file);\n    }\n\n    file.set(\"@babel/plugin-react-jsx/usedFragment\", true);\n    const call = state.call || t.callExpression(state.createElementCallee, args);\n    if (state.pure) (0, _helperAnnotateAsPure.default)(call);\n    return call;\n  }\n\n  function buildCreateElementCall(path, file) {\n    const openingPath = path.get(\"openingElement\");\n    openingPath.parent.children = t.react.buildChildren(openingPath.parent);\n    const tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);\n    const args = [];\n    let tagName;\n\n    if (t.isIdentifier(tagExpr)) {\n      tagName = tagExpr.name;\n    } else if (t.isLiteral(tagExpr)) {\n      tagName = tagExpr.value;\n    }\n\n    const state = {\n      tagExpr: tagExpr,\n      tagName: tagName,\n      args: args,\n      pure: false\n    };\n\n    if (options.pre) {\n      options.pre(state, file);\n    }\n\n    const attribs = buildCreateElementOpeningElementAttributes(path, openingPath.node.attributes);\n    args.push(attribs, ...path.node.children);\n\n    if (options.post) {\n      options.post(state, file);\n    }\n\n    const call = state.call || t.callExpression(state.createElementCallee, args);\n    if (state.pure) (0, _helperAnnotateAsPure.default)(call);\n    return call;\n  }\n\n  function buildCreateElementOpeningElementAttributes(path, attribs) {\n    const props = [];\n    const found = Object.create(null);\n\n    for (const attr of attribs) {\n      const name = t.isJSXAttribute(attr) && t.isJSXIdentifier(attr.name) && attr.name.name;\n\n      if (name === \"__source\" || name === \"__self\") {\n        if (found[name]) throw sourceSelfError(path, name);\n        found[name] = true;\n        if (!options.development) continue;\n      }\n\n      props.push(convertAttribute(attr));\n    }\n\n    return props.length > 0 ? t.objectExpression(props) : t.nullLiteral();\n  }\n\n  function sourceSelfError(path, name) {\n    const pluginName = `transform-react-jsx-${name.slice(2)}`;\n    return path.buildCodeFrameError(`Duplicate ${name} prop found. You are most likely using the deprecated ${pluginName} Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.`);\n  }\n}"]},"metadata":{},"sourceType":"script"}