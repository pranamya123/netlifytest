{"ast":null,"code":"\"use strict\";\n\nfunction assertDoc(val) {\n  /* istanbul ignore if */\n  if (!(typeof val === \"string\" || val != null && typeof val.type === \"string\")) {\n    throw new Error(\"Value \" + JSON.stringify(val) + \" is not a valid document\");\n  }\n}\n\nfunction concat(parts) {\n  if (process.env.NODE_ENV !== \"production\") {\n    parts.forEach(assertDoc);\n  } // We cannot do this until we change `printJSXElement` to not\n  // access the internals of a document directly.\n  // if(parts.length === 1) {\n  //   // If it's a single document, no need to concat it.\n  //   return parts[0];\n  // }\n\n\n  return {\n    type: \"concat\",\n    parts: parts\n  };\n}\n\nfunction indent(contents) {\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDoc(contents);\n  }\n\n  return {\n    type: \"indent\",\n    contents: contents\n  };\n}\n\nfunction align(n, contents) {\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDoc(contents);\n  }\n\n  return {\n    type: \"align\",\n    contents: contents,\n    n: n\n  };\n}\n\nfunction group(contents, opts) {\n  opts = opts || {};\n\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDoc(contents);\n  }\n\n  return {\n    type: \"group\",\n    id: opts.id,\n    contents: contents,\n    \"break\": !!opts.shouldBreak,\n    expandedStates: opts.expandedStates\n  };\n}\n\nfunction dedentToRoot(contents) {\n  return align(-Infinity, contents);\n}\n\nfunction markAsRoot(contents) {\n  return align({\n    type: \"root\"\n  }, contents);\n}\n\nfunction dedent(contents) {\n  return align(-1, contents);\n}\n\nfunction conditionalGroup(states, opts) {\n  return group(states[0], Object.assign(opts || {}, {\n    expandedStates: states\n  }));\n}\n\nfunction fill(parts) {\n  if (process.env.NODE_ENV !== \"production\") {\n    parts.forEach(assertDoc);\n  }\n\n  return {\n    type: \"fill\",\n    parts: parts\n  };\n}\n\nfunction ifBreak(breakContents, flatContents, opts) {\n  opts = opts || {};\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (breakContents) {\n      assertDoc(breakContents);\n    }\n\n    if (flatContents) {\n      assertDoc(flatContents);\n    }\n  }\n\n  return {\n    type: \"if-break\",\n    breakContents: breakContents,\n    flatContents: flatContents,\n    groupId: opts.groupId\n  };\n}\n\nfunction lineSuffix(contents) {\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDoc(contents);\n  }\n\n  return {\n    type: \"line-suffix\",\n    contents: contents\n  };\n}\n\nvar lineSuffixBoundary = {\n  type: \"line-suffix-boundary\"\n};\nvar breakParent = {\n  type: \"break-parent\"\n};\nvar trim = {\n  type: \"trim\"\n};\nvar line = {\n  type: \"line\"\n};\nvar softline = {\n  type: \"line\",\n  soft: true\n};\nvar hardline = concat([{\n  type: \"line\",\n  hard: true\n}, breakParent]);\nvar literalline = concat([{\n  type: \"line\",\n  hard: true,\n  literal: true\n}, breakParent]);\nvar cursor = {\n  type: \"cursor\",\n  placeholder: Symbol(\"cursor\")\n};\n\nfunction join(sep, arr) {\n  var res = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (i !== 0) {\n      res.push(sep);\n    }\n\n    res.push(arr[i]);\n  }\n\n  return concat(res);\n}\n\nfunction addAlignmentToDoc(doc, size, tabWidth) {\n  var aligned = doc;\n\n  if (size > 0) {\n    // Use indent to add tabs for all the levels of tabs we need\n    for (var i = 0; i < Math.floor(size / tabWidth); ++i) {\n      aligned = indent(aligned);\n    } // Use align for all the spaces that are needed\n\n\n    aligned = align(size % tabWidth, aligned); // size is absolute from 0 and not relative to the current\n    // indentation, so we use -Infinity to reset the indentation to 0\n\n    aligned = align(-Infinity, aligned);\n  }\n\n  return aligned;\n}\n\nmodule.exports = {\n  concat: concat,\n  join: join,\n  line: line,\n  softline: softline,\n  hardline: hardline,\n  literalline: literalline,\n  group: group,\n  conditionalGroup: conditionalGroup,\n  fill: fill,\n  lineSuffix: lineSuffix,\n  lineSuffixBoundary: lineSuffixBoundary,\n  cursor: cursor,\n  breakParent: breakParent,\n  ifBreak: ifBreak,\n  trim: trim,\n  indent: indent,\n  align: align,\n  addAlignmentToDoc: addAlignmentToDoc,\n  markAsRoot: markAsRoot,\n  dedentToRoot: dedentToRoot,\n  dedent: dedent\n};","map":{"version":3,"sources":["/Users/pranamyavadlamani/Desktop/Research/PortFolio/portfolio-site/node_modules/@miksu/prettier/lib/doc/doc-builders.js"],"names":["assertDoc","val","type","Error","JSON","stringify","concat","parts","process","env","NODE_ENV","forEach","indent","contents","align","n","group","opts","id","shouldBreak","expandedStates","dedentToRoot","Infinity","markAsRoot","dedent","conditionalGroup","states","Object","assign","fill","ifBreak","breakContents","flatContents","groupId","lineSuffix","lineSuffixBoundary","breakParent","trim","line","softline","soft","hardline","hard","literalline","literal","cursor","placeholder","Symbol","join","sep","arr","res","i","length","push","addAlignmentToDoc","doc","size","tabWidth","aligned","Math","floor","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction assertDoc(val) {\n  /* istanbul ignore if */\n  if (!(typeof val === \"string\" || val != null && typeof val.type === \"string\")) {\n    throw new Error(\"Value \" + JSON.stringify(val) + \" is not a valid document\");\n  }\n}\n\nfunction concat(parts) {\n  if (process.env.NODE_ENV !== \"production\") {\n    parts.forEach(assertDoc);\n  } // We cannot do this until we change `printJSXElement` to not\n  // access the internals of a document directly.\n  // if(parts.length === 1) {\n  //   // If it's a single document, no need to concat it.\n  //   return parts[0];\n  // }\n\n\n  return {\n    type: \"concat\",\n    parts: parts\n  };\n}\n\nfunction indent(contents) {\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDoc(contents);\n  }\n\n  return {\n    type: \"indent\",\n    contents: contents\n  };\n}\n\nfunction align(n, contents) {\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDoc(contents);\n  }\n\n  return {\n    type: \"align\",\n    contents: contents,\n    n: n\n  };\n}\n\nfunction group(contents, opts) {\n  opts = opts || {};\n\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDoc(contents);\n  }\n\n  return {\n    type: \"group\",\n    id: opts.id,\n    contents: contents,\n    \"break\": !!opts.shouldBreak,\n    expandedStates: opts.expandedStates\n  };\n}\n\nfunction dedentToRoot(contents) {\n  return align(-Infinity, contents);\n}\n\nfunction markAsRoot(contents) {\n  return align({\n    type: \"root\"\n  }, contents);\n}\n\nfunction dedent(contents) {\n  return align(-1, contents);\n}\n\nfunction conditionalGroup(states, opts) {\n  return group(states[0], Object.assign(opts || {}, {\n    expandedStates: states\n  }));\n}\n\nfunction fill(parts) {\n  if (process.env.NODE_ENV !== \"production\") {\n    parts.forEach(assertDoc);\n  }\n\n  return {\n    type: \"fill\",\n    parts: parts\n  };\n}\n\nfunction ifBreak(breakContents, flatContents, opts) {\n  opts = opts || {};\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (breakContents) {\n      assertDoc(breakContents);\n    }\n\n    if (flatContents) {\n      assertDoc(flatContents);\n    }\n  }\n\n  return {\n    type: \"if-break\",\n    breakContents: breakContents,\n    flatContents: flatContents,\n    groupId: opts.groupId\n  };\n}\n\nfunction lineSuffix(contents) {\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDoc(contents);\n  }\n\n  return {\n    type: \"line-suffix\",\n    contents: contents\n  };\n}\n\nvar lineSuffixBoundary = {\n  type: \"line-suffix-boundary\"\n};\nvar breakParent = {\n  type: \"break-parent\"\n};\nvar trim = {\n  type: \"trim\"\n};\nvar line = {\n  type: \"line\"\n};\nvar softline = {\n  type: \"line\",\n  soft: true\n};\nvar hardline = concat([{\n  type: \"line\",\n  hard: true\n}, breakParent]);\nvar literalline = concat([{\n  type: \"line\",\n  hard: true,\n  literal: true\n}, breakParent]);\nvar cursor = {\n  type: \"cursor\",\n  placeholder: Symbol(\"cursor\")\n};\n\nfunction join(sep, arr) {\n  var res = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (i !== 0) {\n      res.push(sep);\n    }\n\n    res.push(arr[i]);\n  }\n\n  return concat(res);\n}\n\nfunction addAlignmentToDoc(doc, size, tabWidth) {\n  var aligned = doc;\n\n  if (size > 0) {\n    // Use indent to add tabs for all the levels of tabs we need\n    for (var i = 0; i < Math.floor(size / tabWidth); ++i) {\n      aligned = indent(aligned);\n    } // Use align for all the spaces that are needed\n\n\n    aligned = align(size % tabWidth, aligned); // size is absolute from 0 and not relative to the current\n    // indentation, so we use -Infinity to reset the indentation to 0\n\n    aligned = align(-Infinity, aligned);\n  }\n\n  return aligned;\n}\n\nmodule.exports = {\n  concat: concat,\n  join: join,\n  line: line,\n  softline: softline,\n  hardline: hardline,\n  literalline: literalline,\n  group: group,\n  conditionalGroup: conditionalGroup,\n  fill: fill,\n  lineSuffix: lineSuffix,\n  lineSuffixBoundary: lineSuffixBoundary,\n  cursor: cursor,\n  breakParent: breakParent,\n  ifBreak: ifBreak,\n  trim: trim,\n  indent: indent,\n  align: align,\n  addAlignmentToDoc: addAlignmentToDoc,\n  markAsRoot: markAsRoot,\n  dedentToRoot: dedentToRoot,\n  dedent: dedent\n};"]},"metadata":{},"sourceType":"script"}