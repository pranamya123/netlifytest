{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar _require = require(\"../common/util\"),\n    getLast = _require.getLast; // fix unexpected locEnd caused by --no-semi style\n\n\nfunction postprocess(ast, options) {\n  visitNode(ast, function (node) {\n    switch (node.type) {\n      case \"VariableDeclaration\":\n        {\n          var lastDeclaration = getLast(node.declarations);\n\n          if (lastDeclaration && lastDeclaration.init) {\n            overrideLocEnd(node, lastDeclaration);\n          }\n\n          break;\n        }\n    }\n  });\n  return ast;\n  /**\n   * - `toOverrideNode` must be the last thing in `toBeOverriddenNode`\n   * - do nothing if there's a semicolon on `toOverrideNode.end` (no need to fix)\n   */\n\n  function overrideLocEnd(toBeOverriddenNode, toOverrideNode) {\n    if (options.originalText[locEnd(toOverrideNode)] === \";\") {\n      return;\n    }\n\n    if (options.parser === \"flow\") {\n      toBeOverriddenNode.range = [toBeOverriddenNode.range[0], toOverrideNode.range[1]];\n    } else {\n      toBeOverriddenNode.end = toOverrideNode.end;\n    }\n\n    toBeOverriddenNode.loc = Object.assign({}, toBeOverriddenNode.loc, {\n      end: toBeOverriddenNode.loc.end\n    });\n  }\n\n  function locEnd(node) {\n    return options.parser === \"flow\" ? node.range[1] : node.end;\n  }\n}\n\nfunction visitNode(node, fn) {\n  if (!node || _typeof(node) !== \"object\") {\n    return;\n  }\n\n  if (Array.isArray(node)) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = node[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var subNode = _step.value;\n        visitNode(subNode, fn);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return;\n  }\n\n  if (typeof node.type !== \"string\") {\n    return;\n  }\n\n  for (var _i = 0, _Object$keys = Object.keys(node); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    visitNode(node[key], fn);\n  }\n\n  fn(node);\n}\n\nmodule.exports = postprocess;","map":{"version":3,"sources":["/Users/pranamyavadlamani/Desktop/Research/PortFolio/portfolio-site/node_modules/@miksu/prettier/lib/language-js/postprocess.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_require","require","getLast","postprocess","ast","options","visitNode","node","type","lastDeclaration","declarations","init","overrideLocEnd","toBeOverriddenNode","toOverrideNode","originalText","locEnd","parser","range","end","loc","Object","assign","fn","Array","isArray","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","_step","next","done","subNode","value","err","_i","_Object$keys","keys","length","key","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar _require = require(\"../common/util\"),\n    getLast = _require.getLast; // fix unexpected locEnd caused by --no-semi style\n\n\nfunction postprocess(ast, options) {\n  visitNode(ast, function (node) {\n    switch (node.type) {\n      case \"VariableDeclaration\":\n        {\n          var lastDeclaration = getLast(node.declarations);\n\n          if (lastDeclaration && lastDeclaration.init) {\n            overrideLocEnd(node, lastDeclaration);\n          }\n\n          break;\n        }\n    }\n  });\n  return ast;\n  /**\n   * - `toOverrideNode` must be the last thing in `toBeOverriddenNode`\n   * - do nothing if there's a semicolon on `toOverrideNode.end` (no need to fix)\n   */\n\n  function overrideLocEnd(toBeOverriddenNode, toOverrideNode) {\n    if (options.originalText[locEnd(toOverrideNode)] === \";\") {\n      return;\n    }\n\n    if (options.parser === \"flow\") {\n      toBeOverriddenNode.range = [toBeOverriddenNode.range[0], toOverrideNode.range[1]];\n    } else {\n      toBeOverriddenNode.end = toOverrideNode.end;\n    }\n\n    toBeOverriddenNode.loc = Object.assign({}, toBeOverriddenNode.loc, {\n      end: toBeOverriddenNode.loc.end\n    });\n  }\n\n  function locEnd(node) {\n    return options.parser === \"flow\" ? node.range[1] : node.end;\n  }\n}\n\nfunction visitNode(node, fn) {\n  if (!node || _typeof(node) !== \"object\") {\n    return;\n  }\n\n  if (Array.isArray(node)) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = node[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var subNode = _step.value;\n        visitNode(subNode, fn);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return;\n  }\n\n  if (typeof node.type !== \"string\") {\n    return;\n  }\n\n  for (var _i = 0, _Object$keys = Object.keys(node); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    visitNode(node[key], fn);\n  }\n\n  fn(node);\n}\n\nmodule.exports = postprocess;"]},"metadata":{},"sourceType":"script"}