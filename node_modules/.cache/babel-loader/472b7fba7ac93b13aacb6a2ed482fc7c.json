{"ast":null,"code":"\"use strict\";\n\nvar comments = require(\"./comments\");\n\nfunction findSiblingAncestors(startNodeAndParents, endNodeAndParents, opts) {\n  var resultStartNode = startNodeAndParents.node;\n  var resultEndNode = endNodeAndParents.node;\n\n  if (resultStartNode === resultEndNode) {\n    return {\n      startNode: resultStartNode,\n      endNode: resultEndNode\n    };\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = endNodeAndParents.parentNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var endParent = _step.value;\n\n      if (endParent.type !== \"Program\" && endParent.type !== \"File\" && opts.locStart(endParent) >= opts.locStart(startNodeAndParents.node)) {\n        resultEndNode = endParent;\n      } else {\n        break;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = startNodeAndParents.parentNodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var startParent = _step2.value;\n\n      if (startParent.type !== \"Program\" && startParent.type !== \"File\" && opts.locEnd(startParent) <= opts.locEnd(endNodeAndParents.node)) {\n        resultStartNode = startParent;\n      } else {\n        break;\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n        _iterator2[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return {\n    startNode: resultStartNode,\n    endNode: resultEndNode\n  };\n}\n\nfunction findNodeAtOffset(node, offset, options, predicate, parentNodes) {\n  predicate = predicate || function () {\n    return true;\n  };\n\n  parentNodes = parentNodes || [];\n  var start = options.locStart(node, options.locStart);\n  var end = options.locEnd(node, options.locEnd);\n\n  if (start <= offset && offset <= end) {\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = comments.getSortedChildNodes(node, options)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var childNode = _step3.value;\n        var childResult = findNodeAtOffset(childNode, offset, options, predicate, [node].concat(parentNodes));\n\n        if (childResult) {\n          return childResult;\n        }\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n          _iterator3[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    if (predicate(node)) {\n      return {\n        node: node,\n        parentNodes: parentNodes\n      };\n    }\n  }\n} // See https://www.ecma-international.org/ecma-262/5.1/#sec-A.5\n\n\nfunction isSourceElement(opts, node) {\n  if (node == null) {\n    return false;\n  } // JS and JS like to avoid repetitions\n\n\n  var jsSourceElements = [\"FunctionDeclaration\", \"BlockStatement\", \"BreakStatement\", \"ContinueStatement\", \"DebuggerStatement\", \"DoWhileStatement\", \"EmptyStatement\", \"ExpressionStatement\", \"ForInStatement\", \"ForStatement\", \"IfStatement\", \"LabeledStatement\", \"ReturnStatement\", \"SwitchStatement\", \"ThrowStatement\", \"TryStatement\", \"VariableDeclaration\", \"WhileStatement\", \"WithStatement\", \"ClassDeclaration\", // ES 2015\n  \"ImportDeclaration\", // Module\n  \"ExportDefaultDeclaration\", // Module\n  \"ExportNamedDeclaration\", // Module\n  \"ExportAllDeclaration\", // Module\n  \"TypeAlias\", // Flow\n  \"InterfaceDeclaration\", // Flow, TypeScript\n  \"TypeAliasDeclaration\", // TypeScript\n  \"ExportAssignment\", // TypeScript\n  \"ExportDeclaration\" // TypeScript\n  ];\n  var jsonSourceElements = [\"ObjectExpression\", \"ArrayExpression\", \"StringLiteral\", \"NumericLiteral\", \"BooleanLiteral\", \"NullLiteral\"];\n  var graphqlSourceElements = [\"OperationDefinition\", \"FragmentDefinition\", \"VariableDefinition\", \"TypeExtensionDefinition\", \"ObjectTypeDefinition\", \"FieldDefinition\", \"DirectiveDefinition\", \"EnumTypeDefinition\", \"EnumValueDefinition\", \"InputValueDefinition\", \"InputObjectTypeDefinition\", \"SchemaDefinition\", \"OperationTypeDefinition\", \"InterfaceTypeDefinition\", \"UnionTypeDefinition\", \"ScalarTypeDefinition\"];\n\n  switch (opts.parser) {\n    case \"flow\":\n    case \"babel\":\n    case \"typescript\":\n      return jsSourceElements.indexOf(node.type) > -1;\n\n    case \"json\":\n      return jsonSourceElements.indexOf(node.type) > -1;\n\n    case \"graphql\":\n      return graphqlSourceElements.indexOf(node.kind) > -1;\n\n    case \"vue\":\n      return node.tag !== \"root\";\n  }\n\n  return false;\n}\n\nfunction calculateRange(text, opts, ast) {\n  // Contract the range so that it has non-whitespace characters at its endpoints.\n  // This ensures we can format a range that doesn't end on a node.\n  var rangeStringOrig = text.slice(opts.rangeStart, opts.rangeEnd);\n  var startNonWhitespace = Math.max(opts.rangeStart + rangeStringOrig.search(/\\S/), opts.rangeStart);\n  var endNonWhitespace;\n\n  for (endNonWhitespace = opts.rangeEnd; endNonWhitespace > opts.rangeStart; --endNonWhitespace) {\n    if (text[endNonWhitespace - 1].match(/\\S/)) {\n      break;\n    }\n  }\n\n  var startNodeAndParents = findNodeAtOffset(ast, startNonWhitespace, opts, function (node) {\n    return isSourceElement(opts, node);\n  });\n  var endNodeAndParents = findNodeAtOffset(ast, endNonWhitespace, opts, function (node) {\n    return isSourceElement(opts, node);\n  });\n\n  if (!startNodeAndParents || !endNodeAndParents) {\n    return {\n      rangeStart: 0,\n      rangeEnd: 0\n    };\n  }\n\n  var siblingAncestors = findSiblingAncestors(startNodeAndParents, endNodeAndParents, opts);\n  var startNode = siblingAncestors.startNode,\n      endNode = siblingAncestors.endNode;\n  var rangeStart = Math.min(opts.locStart(startNode, opts.locStart), opts.locStart(endNode, opts.locStart));\n  var rangeEnd = Math.max(opts.locEnd(startNode, opts.locEnd), opts.locEnd(endNode, opts.locEnd));\n  return {\n    rangeStart: rangeStart,\n    rangeEnd: rangeEnd\n  };\n}\n\nmodule.exports = {\n  calculateRange: calculateRange,\n  findNodeAtOffset: findNodeAtOffset\n};","map":{"version":3,"sources":["/Users/pranamyavadlamani/Desktop/Research/PortFolio/portfolio-site/node_modules/@miksu/prettier/lib/main/range-util.js"],"names":["comments","require","findSiblingAncestors","startNodeAndParents","endNodeAndParents","opts","resultStartNode","node","resultEndNode","startNode","endNode","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","parentNodes","Symbol","iterator","_step","next","done","endParent","value","type","locStart","err","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","startParent","locEnd","findNodeAtOffset","offset","options","predicate","start","end","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","getSortedChildNodes","_step3","childNode","childResult","concat","isSourceElement","jsSourceElements","jsonSourceElements","graphqlSourceElements","parser","indexOf","kind","tag","calculateRange","text","ast","rangeStringOrig","slice","rangeStart","rangeEnd","startNonWhitespace","Math","max","search","endNonWhitespace","match","siblingAncestors","min","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar comments = require(\"./comments\");\n\nfunction findSiblingAncestors(startNodeAndParents, endNodeAndParents, opts) {\n  var resultStartNode = startNodeAndParents.node;\n  var resultEndNode = endNodeAndParents.node;\n\n  if (resultStartNode === resultEndNode) {\n    return {\n      startNode: resultStartNode,\n      endNode: resultEndNode\n    };\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = endNodeAndParents.parentNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var endParent = _step.value;\n\n      if (endParent.type !== \"Program\" && endParent.type !== \"File\" && opts.locStart(endParent) >= opts.locStart(startNodeAndParents.node)) {\n        resultEndNode = endParent;\n      } else {\n        break;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = startNodeAndParents.parentNodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var startParent = _step2.value;\n\n      if (startParent.type !== \"Program\" && startParent.type !== \"File\" && opts.locEnd(startParent) <= opts.locEnd(endNodeAndParents.node)) {\n        resultStartNode = startParent;\n      } else {\n        break;\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n        _iterator2[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return {\n    startNode: resultStartNode,\n    endNode: resultEndNode\n  };\n}\n\nfunction findNodeAtOffset(node, offset, options, predicate, parentNodes) {\n  predicate = predicate || function () {\n    return true;\n  };\n\n  parentNodes = parentNodes || [];\n  var start = options.locStart(node, options.locStart);\n  var end = options.locEnd(node, options.locEnd);\n\n  if (start <= offset && offset <= end) {\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = comments.getSortedChildNodes(node, options)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var childNode = _step3.value;\n        var childResult = findNodeAtOffset(childNode, offset, options, predicate, [node].concat(parentNodes));\n\n        if (childResult) {\n          return childResult;\n        }\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n          _iterator3[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    if (predicate(node)) {\n      return {\n        node: node,\n        parentNodes: parentNodes\n      };\n    }\n  }\n} // See https://www.ecma-international.org/ecma-262/5.1/#sec-A.5\n\n\nfunction isSourceElement(opts, node) {\n  if (node == null) {\n    return false;\n  } // JS and JS like to avoid repetitions\n\n\n  var jsSourceElements = [\"FunctionDeclaration\", \"BlockStatement\", \"BreakStatement\", \"ContinueStatement\", \"DebuggerStatement\", \"DoWhileStatement\", \"EmptyStatement\", \"ExpressionStatement\", \"ForInStatement\", \"ForStatement\", \"IfStatement\", \"LabeledStatement\", \"ReturnStatement\", \"SwitchStatement\", \"ThrowStatement\", \"TryStatement\", \"VariableDeclaration\", \"WhileStatement\", \"WithStatement\", \"ClassDeclaration\", // ES 2015\n  \"ImportDeclaration\", // Module\n  \"ExportDefaultDeclaration\", // Module\n  \"ExportNamedDeclaration\", // Module\n  \"ExportAllDeclaration\", // Module\n  \"TypeAlias\", // Flow\n  \"InterfaceDeclaration\", // Flow, TypeScript\n  \"TypeAliasDeclaration\", // TypeScript\n  \"ExportAssignment\", // TypeScript\n  \"ExportDeclaration\" // TypeScript\n  ];\n  var jsonSourceElements = [\"ObjectExpression\", \"ArrayExpression\", \"StringLiteral\", \"NumericLiteral\", \"BooleanLiteral\", \"NullLiteral\"];\n  var graphqlSourceElements = [\"OperationDefinition\", \"FragmentDefinition\", \"VariableDefinition\", \"TypeExtensionDefinition\", \"ObjectTypeDefinition\", \"FieldDefinition\", \"DirectiveDefinition\", \"EnumTypeDefinition\", \"EnumValueDefinition\", \"InputValueDefinition\", \"InputObjectTypeDefinition\", \"SchemaDefinition\", \"OperationTypeDefinition\", \"InterfaceTypeDefinition\", \"UnionTypeDefinition\", \"ScalarTypeDefinition\"];\n\n  switch (opts.parser) {\n    case \"flow\":\n    case \"babel\":\n    case \"typescript\":\n      return jsSourceElements.indexOf(node.type) > -1;\n\n    case \"json\":\n      return jsonSourceElements.indexOf(node.type) > -1;\n\n    case \"graphql\":\n      return graphqlSourceElements.indexOf(node.kind) > -1;\n\n    case \"vue\":\n      return node.tag !== \"root\";\n  }\n\n  return false;\n}\n\nfunction calculateRange(text, opts, ast) {\n  // Contract the range so that it has non-whitespace characters at its endpoints.\n  // This ensures we can format a range that doesn't end on a node.\n  var rangeStringOrig = text.slice(opts.rangeStart, opts.rangeEnd);\n  var startNonWhitespace = Math.max(opts.rangeStart + rangeStringOrig.search(/\\S/), opts.rangeStart);\n  var endNonWhitespace;\n\n  for (endNonWhitespace = opts.rangeEnd; endNonWhitespace > opts.rangeStart; --endNonWhitespace) {\n    if (text[endNonWhitespace - 1].match(/\\S/)) {\n      break;\n    }\n  }\n\n  var startNodeAndParents = findNodeAtOffset(ast, startNonWhitespace, opts, function (node) {\n    return isSourceElement(opts, node);\n  });\n  var endNodeAndParents = findNodeAtOffset(ast, endNonWhitespace, opts, function (node) {\n    return isSourceElement(opts, node);\n  });\n\n  if (!startNodeAndParents || !endNodeAndParents) {\n    return {\n      rangeStart: 0,\n      rangeEnd: 0\n    };\n  }\n\n  var siblingAncestors = findSiblingAncestors(startNodeAndParents, endNodeAndParents, opts);\n  var startNode = siblingAncestors.startNode,\n      endNode = siblingAncestors.endNode;\n  var rangeStart = Math.min(opts.locStart(startNode, opts.locStart), opts.locStart(endNode, opts.locStart));\n  var rangeEnd = Math.max(opts.locEnd(startNode, opts.locEnd), opts.locEnd(endNode, opts.locEnd));\n  return {\n    rangeStart: rangeStart,\n    rangeEnd: rangeEnd\n  };\n}\n\nmodule.exports = {\n  calculateRange: calculateRange,\n  findNodeAtOffset: findNodeAtOffset\n};"]},"metadata":{},"sourceType":"script"}