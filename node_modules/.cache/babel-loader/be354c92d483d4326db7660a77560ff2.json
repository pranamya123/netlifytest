{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar assert = require(\"assert\");\n\nvar _require$builders = require(\"../doc\").builders,\n    concat = _require$builders.concat,\n    hardline = _require$builders.hardline,\n    breakParent = _require$builders.breakParent,\n    indent = _require$builders.indent,\n    lineSuffix = _require$builders.lineSuffix,\n    join = _require$builders.join,\n    cursor = _require$builders.cursor;\n\nvar _require = require(\"../common/util\"),\n    hasNewline = _require.hasNewline,\n    skipNewline = _require.skipNewline,\n    isPreviousLineEmpty = _require.isPreviousLineEmpty;\n\nvar _require2 = require(\"../common/util-shared\"),\n    addLeadingComment = _require2.addLeadingComment,\n    addDanglingComment = _require2.addDanglingComment,\n    addTrailingComment = _require2.addTrailingComment;\n\nvar childNodesCacheKey = Symbol(\"child-nodes\");\n\nfunction getSortedChildNodes(node, options, resultArray) {\n  if (!node) {\n    return;\n  }\n\n  var printer = options.printer,\n      locStart = options.locStart,\n      locEnd = options.locEnd;\n\n  if (resultArray) {\n    if (node && printer.canAttachComment && printer.canAttachComment(node)) {\n      // This reverse insertion sort almost always takes constant\n      // time because we almost always (maybe always?) append the\n      // nodes in order anyway.\n      var i;\n\n      for (i = resultArray.length - 1; i >= 0; --i) {\n        if (locStart(resultArray[i]) <= locStart(node) && locEnd(resultArray[i]) <= locEnd(node)) {\n          break;\n        }\n      }\n\n      resultArray.splice(i + 1, 0, node);\n      return;\n    }\n  } else if (node[childNodesCacheKey]) {\n    return node[childNodesCacheKey];\n  }\n\n  var childNodes;\n\n  if (printer.getCommentChildNodes) {\n    childNodes = printer.getCommentChildNodes(node);\n  } else if (node && _typeof(node) === \"object\") {\n    childNodes = Object.keys(node).filter(function (n) {\n      return n !== \"enclosingNode\" && n !== \"precedingNode\" && n !== \"followingNode\";\n    }).map(function (n) {\n      return node[n];\n    });\n  }\n\n  if (!childNodes) {\n    return;\n  }\n\n  if (!resultArray) {\n    Object.defineProperty(node, childNodesCacheKey, {\n      value: resultArray = [],\n      enumerable: false\n    });\n  }\n\n  childNodes.forEach(function (childNode) {\n    getSortedChildNodes(childNode, options, resultArray);\n  });\n  return resultArray;\n} // As efficiently as possible, decorate the comment object with\n// .precedingNode, .enclosingNode, and/or .followingNode properties, at\n// least one of which is guaranteed to be defined.\n\n\nfunction decorateComment(node, comment, options) {\n  var locStart = options.locStart,\n      locEnd = options.locEnd;\n  var childNodes = getSortedChildNodes(node, options);\n  var precedingNode;\n  var followingNode; // Time to dust off the old binary search robes and wizard hat.\n\n  var left = 0;\n  var right = childNodes.length;\n\n  while (left < right) {\n    var middle = left + right >> 1;\n    var child = childNodes[middle];\n\n    if (locStart(child) - locStart(comment) <= 0 && locEnd(comment) - locEnd(child) <= 0) {\n      // The comment is completely contained by this child node.\n      comment.enclosingNode = child;\n      decorateComment(child, comment, options);\n      return; // Abandon the binary search at this level.\n    }\n\n    if (locEnd(child) - locStart(comment) <= 0) {\n      // This child node falls completely before the comment.\n      // Because we will never consider this node or any nodes\n      // before it again, this node must be the closest preceding\n      // node we have encountered so far.\n      precedingNode = child;\n      left = middle + 1;\n      continue;\n    }\n\n    if (locEnd(comment) - locStart(child) <= 0) {\n      // This child node falls completely after the comment.\n      // Because we will never consider this node or any nodes after\n      // it again, this node must be the closest following node we\n      // have encountered so far.\n      followingNode = child;\n      right = middle;\n      continue;\n    }\n    /* istanbul ignore next */\n\n\n    throw new Error(\"Comment location overlaps with node location\");\n  } // We don't want comments inside of different expressions inside of the same\n  // template literal to move to another expression.\n\n\n  if (comment.enclosingNode && comment.enclosingNode.type === \"TemplateLiteral\") {\n    var quasis = comment.enclosingNode.quasis;\n    var commentIndex = findExpressionIndexForComment(quasis, comment, options);\n\n    if (precedingNode && findExpressionIndexForComment(quasis, precedingNode, options) !== commentIndex) {\n      precedingNode = null;\n    }\n\n    if (followingNode && findExpressionIndexForComment(quasis, followingNode, options) !== commentIndex) {\n      followingNode = null;\n    }\n  }\n\n  if (precedingNode) {\n    comment.precedingNode = precedingNode;\n  }\n\n  if (followingNode) {\n    comment.followingNode = followingNode;\n  }\n}\n\nfunction attach(comments, ast, text, options) {\n  if (!Array.isArray(comments)) {\n    return;\n  }\n\n  var tiesToBreak = [];\n  var locStart = options.locStart,\n      locEnd = options.locEnd;\n  comments.forEach(function (comment, i) {\n    if (options.parser === \"json\" || options.parser === \"json5\" || options.parser === \"__js_expression\" || options.parser === \"__vue_expression\") {\n      if (locStart(comment) - locStart(ast) <= 0) {\n        addLeadingComment(ast, comment);\n        return;\n      }\n\n      if (locEnd(comment) - locEnd(ast) >= 0) {\n        addTrailingComment(ast, comment);\n        return;\n      }\n    }\n\n    decorateComment(ast, comment, options);\n    var precedingNode = comment.precedingNode,\n        enclosingNode = comment.enclosingNode,\n        followingNode = comment.followingNode;\n    var pluginHandleOwnLineComment = options.printer.handleComments && options.printer.handleComments.ownLine ? options.printer.handleComments.ownLine : function () {\n      return false;\n    };\n    var pluginHandleEndOfLineComment = options.printer.handleComments && options.printer.handleComments.endOfLine ? options.printer.handleComments.endOfLine : function () {\n      return false;\n    };\n    var pluginHandleRemainingComment = options.printer.handleComments && options.printer.handleComments.remaining ? options.printer.handleComments.remaining : function () {\n      return false;\n    };\n    var isLastComment = comments.length - 1 === i;\n\n    if (hasNewline(text, locStart(comment), {\n      backwards: true\n    })) {\n      // If a comment exists on its own line, prefer a leading comment.\n      // We also need to check if it's the first line of the file.\n      if (pluginHandleOwnLineComment(comment, text, options, ast, isLastComment)) {// We're good\n      } else if (followingNode) {\n        // Always a leading comment.\n        addLeadingComment(followingNode, comment);\n      } else if (precedingNode) {\n        addTrailingComment(precedingNode, comment);\n      } else if (enclosingNode) {\n        addDanglingComment(enclosingNode, comment);\n      } else {\n        // There are no nodes, let's attach it to the root of the ast\n\n        /* istanbul ignore next */\n        addDanglingComment(ast, comment);\n      }\n    } else if (hasNewline(text, locEnd(comment))) {\n      if (pluginHandleEndOfLineComment(comment, text, options, ast, isLastComment)) {// We're good\n      } else if (precedingNode) {\n        // There is content before this comment on the same line, but\n        // none after it, so prefer a trailing comment of the previous node.\n        addTrailingComment(precedingNode, comment);\n      } else if (followingNode) {\n        addLeadingComment(followingNode, comment);\n      } else if (enclosingNode) {\n        addDanglingComment(enclosingNode, comment);\n      } else {\n        // There are no nodes, let's attach it to the root of the ast\n\n        /* istanbul ignore next */\n        addDanglingComment(ast, comment);\n      }\n    } else {\n      if (pluginHandleRemainingComment(comment, text, options, ast, isLastComment)) {// We're good\n      } else if (precedingNode && followingNode) {\n        // Otherwise, text exists both before and after the comment on\n        // the same line. If there is both a preceding and following\n        // node, use a tie-breaking algorithm to determine if it should\n        // be attached to the next or previous node. In the last case,\n        // simply attach the right node;\n        var tieCount = tiesToBreak.length;\n\n        if (tieCount > 0) {\n          var lastTie = tiesToBreak[tieCount - 1];\n\n          if (lastTie.followingNode !== comment.followingNode) {\n            breakTies(tiesToBreak, text, options);\n          }\n        }\n\n        tiesToBreak.push(comment);\n      } else if (precedingNode) {\n        addTrailingComment(precedingNode, comment);\n      } else if (followingNode) {\n        addLeadingComment(followingNode, comment);\n      } else if (enclosingNode) {\n        addDanglingComment(enclosingNode, comment);\n      } else {\n        // There are no nodes, let's attach it to the root of the ast\n\n        /* istanbul ignore next */\n        addDanglingComment(ast, comment);\n      }\n    }\n  });\n  breakTies(tiesToBreak, text, options);\n  comments.forEach(function (comment) {\n    // These node references were useful for breaking ties, but we\n    // don't need them anymore, and they create cycles in the AST that\n    // may lead to infinite recursion if we don't delete them here.\n    delete comment.precedingNode;\n    delete comment.enclosingNode;\n    delete comment.followingNode;\n  });\n}\n\nfunction breakTies(tiesToBreak, text, options) {\n  var tieCount = tiesToBreak.length;\n\n  if (tieCount === 0) {\n    return;\n  }\n\n  var _tiesToBreak$ = tiesToBreak[0],\n      precedingNode = _tiesToBreak$.precedingNode,\n      followingNode = _tiesToBreak$.followingNode;\n  var gapEndPos = options.locStart(followingNode); // Iterate backwards through tiesToBreak, examining the gaps\n  // between the tied comments. In order to qualify as leading, a\n  // comment must be separated from followingNode by an unbroken series of\n  // gaps (or other comments). Gaps should only contain whitespace or open\n  // parentheses.\n\n  var indexOfFirstLeadingComment;\n\n  for (indexOfFirstLeadingComment = tieCount; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {\n    var comment = tiesToBreak[indexOfFirstLeadingComment - 1];\n    assert.strictEqual(comment.precedingNode, precedingNode);\n    assert.strictEqual(comment.followingNode, followingNode);\n    var gap = text.slice(options.locEnd(comment), gapEndPos).trim();\n\n    if (gap === \"\" || /^\\(+$/.test(gap)) {\n      gapEndPos = options.locStart(comment);\n    } else {\n      // The gap string contained something other than whitespace or open\n      // parentheses.\n      break;\n    }\n  }\n\n  tiesToBreak.forEach(function (comment, i) {\n    if (i < indexOfFirstLeadingComment) {\n      addTrailingComment(precedingNode, comment);\n    } else {\n      addLeadingComment(followingNode, comment);\n    }\n  });\n  tiesToBreak.length = 0;\n}\n\nfunction printComment(commentPath, options) {\n  var comment = commentPath.getValue();\n  comment.printed = true;\n  return options.printer.printComment(commentPath, options);\n}\n\nfunction findExpressionIndexForComment(quasis, comment, options) {\n  var startPos = options.locStart(comment) - 1;\n\n  for (var i = 1; i < quasis.length; ++i) {\n    if (startPos < getQuasiRange(quasis[i]).start) {\n      return i - 1;\n    }\n  } // We haven't found it, it probably means that some of the locations are off.\n  // Let's just return the first one.\n\n  /* istanbul ignore next */\n\n\n  return 0;\n}\n\nfunction getQuasiRange(expr) {\n  if (expr.start !== undefined) {\n    // Babel\n    return {\n      start: expr.start,\n      end: expr.end\n    };\n  } // Flow\n\n\n  return {\n    start: expr.range[0],\n    end: expr.range[1]\n  };\n}\n\nfunction printLeadingComment(commentPath, print, options) {\n  var comment = commentPath.getValue();\n  var contents = printComment(commentPath, options);\n\n  if (!contents) {\n    return \"\";\n  }\n\n  var isBlock = options.printer.isBlockComment && options.printer.isBlockComment(comment); // Leading block comments should see if they need to stay on the\n  // same line or not.\n\n  if (isBlock) {\n    return concat([contents, hasNewline(options.originalText, options.locEnd(comment)) ? hardline : \" \"]);\n  }\n\n  return concat([contents, hardline]);\n}\n\nfunction printTrailingComment(commentPath, print, options) {\n  var comment = commentPath.getValue();\n  var contents = printComment(commentPath, options);\n\n  if (!contents) {\n    return \"\";\n  }\n\n  var isBlock = options.printer.isBlockComment && options.printer.isBlockComment(comment); // We don't want the line to break\n  // when the parentParentNode is a ClassDeclaration/-Expression\n  // And the parentNode is in the superClass property\n\n  var parentNode = commentPath.getNode(1);\n  var parentParentNode = commentPath.getNode(2);\n  var isParentSuperClass = parentParentNode && (parentParentNode.type === \"ClassDeclaration\" || parentParentNode.type === \"ClassExpression\") && parentParentNode.superClass === parentNode;\n\n  if (hasNewline(options.originalText, options.locStart(comment), {\n    backwards: true\n  })) {\n    // This allows comments at the end of nested structures:\n    // {\n    //   x: 1,\n    //   y: 2\n    //   // A comment\n    // }\n    // Those kinds of comments are almost always leading comments, but\n    // here it doesn't go \"outside\" the block and turns it into a\n    // trailing comment for `2`. We can simulate the above by checking\n    // if this a comment on its own line; normal trailing comments are\n    // always at the end of another expression.\n    var isLineBeforeEmpty = isPreviousLineEmpty(options.originalText, comment, options.locStart);\n    return lineSuffix(concat([hardline, isLineBeforeEmpty ? hardline : \"\", contents]));\n  } else if (isBlock || isParentSuperClass) {\n    // Trailing block comments never need a newline\n    return concat([\" \", contents]);\n  }\n\n  return concat([lineSuffix(concat([\" \", contents])), !isBlock ? breakParent : \"\"]);\n}\n\nfunction printDanglingComments(path, options, sameIndent, filter) {\n  var parts = [];\n  var node = path.getValue();\n\n  if (!node || !node.comments) {\n    return \"\";\n  }\n\n  path.each(function (commentPath) {\n    var comment = commentPath.getValue();\n\n    if (comment && !comment.leading && !comment.trailing && (!filter || filter(comment))) {\n      parts.push(printComment(commentPath, options));\n    }\n  }, \"comments\");\n\n  if (parts.length === 0) {\n    return \"\";\n  }\n\n  if (sameIndent) {\n    return join(hardline, parts);\n  }\n\n  return indent(concat([hardline, join(hardline, parts)]));\n}\n\nfunction prependCursorPlaceholder(path, options, printed) {\n  if (path.getNode() === options.cursorNode && path.getValue()) {\n    return concat([cursor, printed, cursor]);\n  }\n\n  return printed;\n}\n\nfunction printComments(path, print, options, needsSemi) {\n  var value = path.getValue();\n  var printed = print(path);\n  var comments = value && value.comments;\n\n  if (!comments || comments.length === 0) {\n    return prependCursorPlaceholder(path, options, printed);\n  }\n\n  var leadingParts = [];\n  var trailingParts = [needsSemi ? \";\" : \"\", printed];\n  path.each(function (commentPath) {\n    var comment = commentPath.getValue();\n    var leading = comment.leading,\n        trailing = comment.trailing;\n\n    if (leading) {\n      var contents = printLeadingComment(commentPath, print, options);\n\n      if (!contents) {\n        return;\n      }\n\n      leadingParts.push(contents);\n      var text = options.originalText;\n\n      if (hasNewline(text, skipNewline(text, options.locEnd(comment)))) {\n        leadingParts.push(hardline);\n      }\n    } else if (trailing) {\n      trailingParts.push(printTrailingComment(commentPath, print, options));\n    }\n  }, \"comments\");\n  return prependCursorPlaceholder(path, options, concat(leadingParts.concat(trailingParts)));\n}\n\nmodule.exports = {\n  attach: attach,\n  printComments: printComments,\n  printDanglingComments: printDanglingComments,\n  getSortedChildNodes: getSortedChildNodes\n};","map":{"version":3,"sources":["/Users/pranamyavadlamani/Desktop/Research/PortFolio/portfolio-site/node_modules/@miksu/prettier/lib/main/comments.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","assert","require","_require$builders","builders","concat","hardline","breakParent","indent","lineSuffix","join","cursor","_require","hasNewline","skipNewline","isPreviousLineEmpty","_require2","addLeadingComment","addDanglingComment","addTrailingComment","childNodesCacheKey","getSortedChildNodes","node","options","resultArray","printer","locStart","locEnd","canAttachComment","i","length","splice","childNodes","getCommentChildNodes","Object","keys","filter","n","map","defineProperty","value","enumerable","forEach","childNode","decorateComment","comment","precedingNode","followingNode","left","right","middle","child","enclosingNode","Error","type","quasis","commentIndex","findExpressionIndexForComment","attach","comments","ast","text","Array","isArray","tiesToBreak","parser","pluginHandleOwnLineComment","handleComments","ownLine","pluginHandleEndOfLineComment","endOfLine","pluginHandleRemainingComment","remaining","isLastComment","backwards","tieCount","lastTie","breakTies","push","_tiesToBreak$","gapEndPos","indexOfFirstLeadingComment","strictEqual","gap","slice","trim","test","printComment","commentPath","getValue","printed","startPos","getQuasiRange","start","expr","undefined","end","range","printLeadingComment","print","contents","isBlock","isBlockComment","originalText","printTrailingComment","parentNode","getNode","parentParentNode","isParentSuperClass","superClass","isLineBeforeEmpty","printDanglingComments","path","sameIndent","parts","each","leading","trailing","prependCursorPlaceholder","cursorNode","printComments","needsSemi","leadingParts","trailingParts","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar assert = require(\"assert\");\n\nvar _require$builders = require(\"../doc\").builders,\n    concat = _require$builders.concat,\n    hardline = _require$builders.hardline,\n    breakParent = _require$builders.breakParent,\n    indent = _require$builders.indent,\n    lineSuffix = _require$builders.lineSuffix,\n    join = _require$builders.join,\n    cursor = _require$builders.cursor;\n\nvar _require = require(\"../common/util\"),\n    hasNewline = _require.hasNewline,\n    skipNewline = _require.skipNewline,\n    isPreviousLineEmpty = _require.isPreviousLineEmpty;\n\nvar _require2 = require(\"../common/util-shared\"),\n    addLeadingComment = _require2.addLeadingComment,\n    addDanglingComment = _require2.addDanglingComment,\n    addTrailingComment = _require2.addTrailingComment;\n\nvar childNodesCacheKey = Symbol(\"child-nodes\");\n\nfunction getSortedChildNodes(node, options, resultArray) {\n  if (!node) {\n    return;\n  }\n\n  var printer = options.printer,\n      locStart = options.locStart,\n      locEnd = options.locEnd;\n\n  if (resultArray) {\n    if (node && printer.canAttachComment && printer.canAttachComment(node)) {\n      // This reverse insertion sort almost always takes constant\n      // time because we almost always (maybe always?) append the\n      // nodes in order anyway.\n      var i;\n\n      for (i = resultArray.length - 1; i >= 0; --i) {\n        if (locStart(resultArray[i]) <= locStart(node) && locEnd(resultArray[i]) <= locEnd(node)) {\n          break;\n        }\n      }\n\n      resultArray.splice(i + 1, 0, node);\n      return;\n    }\n  } else if (node[childNodesCacheKey]) {\n    return node[childNodesCacheKey];\n  }\n\n  var childNodes;\n\n  if (printer.getCommentChildNodes) {\n    childNodes = printer.getCommentChildNodes(node);\n  } else if (node && _typeof(node) === \"object\") {\n    childNodes = Object.keys(node).filter(function (n) {\n      return n !== \"enclosingNode\" && n !== \"precedingNode\" && n !== \"followingNode\";\n    }).map(function (n) {\n      return node[n];\n    });\n  }\n\n  if (!childNodes) {\n    return;\n  }\n\n  if (!resultArray) {\n    Object.defineProperty(node, childNodesCacheKey, {\n      value: resultArray = [],\n      enumerable: false\n    });\n  }\n\n  childNodes.forEach(function (childNode) {\n    getSortedChildNodes(childNode, options, resultArray);\n  });\n  return resultArray;\n} // As efficiently as possible, decorate the comment object with\n// .precedingNode, .enclosingNode, and/or .followingNode properties, at\n// least one of which is guaranteed to be defined.\n\n\nfunction decorateComment(node, comment, options) {\n  var locStart = options.locStart,\n      locEnd = options.locEnd;\n  var childNodes = getSortedChildNodes(node, options);\n  var precedingNode;\n  var followingNode; // Time to dust off the old binary search robes and wizard hat.\n\n  var left = 0;\n  var right = childNodes.length;\n\n  while (left < right) {\n    var middle = left + right >> 1;\n    var child = childNodes[middle];\n\n    if (locStart(child) - locStart(comment) <= 0 && locEnd(comment) - locEnd(child) <= 0) {\n      // The comment is completely contained by this child node.\n      comment.enclosingNode = child;\n      decorateComment(child, comment, options);\n      return; // Abandon the binary search at this level.\n    }\n\n    if (locEnd(child) - locStart(comment) <= 0) {\n      // This child node falls completely before the comment.\n      // Because we will never consider this node or any nodes\n      // before it again, this node must be the closest preceding\n      // node we have encountered so far.\n      precedingNode = child;\n      left = middle + 1;\n      continue;\n    }\n\n    if (locEnd(comment) - locStart(child) <= 0) {\n      // This child node falls completely after the comment.\n      // Because we will never consider this node or any nodes after\n      // it again, this node must be the closest following node we\n      // have encountered so far.\n      followingNode = child;\n      right = middle;\n      continue;\n    }\n    /* istanbul ignore next */\n\n\n    throw new Error(\"Comment location overlaps with node location\");\n  } // We don't want comments inside of different expressions inside of the same\n  // template literal to move to another expression.\n\n\n  if (comment.enclosingNode && comment.enclosingNode.type === \"TemplateLiteral\") {\n    var quasis = comment.enclosingNode.quasis;\n    var commentIndex = findExpressionIndexForComment(quasis, comment, options);\n\n    if (precedingNode && findExpressionIndexForComment(quasis, precedingNode, options) !== commentIndex) {\n      precedingNode = null;\n    }\n\n    if (followingNode && findExpressionIndexForComment(quasis, followingNode, options) !== commentIndex) {\n      followingNode = null;\n    }\n  }\n\n  if (precedingNode) {\n    comment.precedingNode = precedingNode;\n  }\n\n  if (followingNode) {\n    comment.followingNode = followingNode;\n  }\n}\n\nfunction attach(comments, ast, text, options) {\n  if (!Array.isArray(comments)) {\n    return;\n  }\n\n  var tiesToBreak = [];\n  var locStart = options.locStart,\n      locEnd = options.locEnd;\n  comments.forEach(function (comment, i) {\n    if (options.parser === \"json\" || options.parser === \"json5\" || options.parser === \"__js_expression\" || options.parser === \"__vue_expression\") {\n      if (locStart(comment) - locStart(ast) <= 0) {\n        addLeadingComment(ast, comment);\n        return;\n      }\n\n      if (locEnd(comment) - locEnd(ast) >= 0) {\n        addTrailingComment(ast, comment);\n        return;\n      }\n    }\n\n    decorateComment(ast, comment, options);\n    var precedingNode = comment.precedingNode,\n        enclosingNode = comment.enclosingNode,\n        followingNode = comment.followingNode;\n    var pluginHandleOwnLineComment = options.printer.handleComments && options.printer.handleComments.ownLine ? options.printer.handleComments.ownLine : function () {\n      return false;\n    };\n    var pluginHandleEndOfLineComment = options.printer.handleComments && options.printer.handleComments.endOfLine ? options.printer.handleComments.endOfLine : function () {\n      return false;\n    };\n    var pluginHandleRemainingComment = options.printer.handleComments && options.printer.handleComments.remaining ? options.printer.handleComments.remaining : function () {\n      return false;\n    };\n    var isLastComment = comments.length - 1 === i;\n\n    if (hasNewline(text, locStart(comment), {\n      backwards: true\n    })) {\n      // If a comment exists on its own line, prefer a leading comment.\n      // We also need to check if it's the first line of the file.\n      if (pluginHandleOwnLineComment(comment, text, options, ast, isLastComment)) {// We're good\n      } else if (followingNode) {\n        // Always a leading comment.\n        addLeadingComment(followingNode, comment);\n      } else if (precedingNode) {\n        addTrailingComment(precedingNode, comment);\n      } else if (enclosingNode) {\n        addDanglingComment(enclosingNode, comment);\n      } else {\n        // There are no nodes, let's attach it to the root of the ast\n\n        /* istanbul ignore next */\n        addDanglingComment(ast, comment);\n      }\n    } else if (hasNewline(text, locEnd(comment))) {\n      if (pluginHandleEndOfLineComment(comment, text, options, ast, isLastComment)) {// We're good\n      } else if (precedingNode) {\n        // There is content before this comment on the same line, but\n        // none after it, so prefer a trailing comment of the previous node.\n        addTrailingComment(precedingNode, comment);\n      } else if (followingNode) {\n        addLeadingComment(followingNode, comment);\n      } else if (enclosingNode) {\n        addDanglingComment(enclosingNode, comment);\n      } else {\n        // There are no nodes, let's attach it to the root of the ast\n\n        /* istanbul ignore next */\n        addDanglingComment(ast, comment);\n      }\n    } else {\n      if (pluginHandleRemainingComment(comment, text, options, ast, isLastComment)) {// We're good\n      } else if (precedingNode && followingNode) {\n        // Otherwise, text exists both before and after the comment on\n        // the same line. If there is both a preceding and following\n        // node, use a tie-breaking algorithm to determine if it should\n        // be attached to the next or previous node. In the last case,\n        // simply attach the right node;\n        var tieCount = tiesToBreak.length;\n\n        if (tieCount > 0) {\n          var lastTie = tiesToBreak[tieCount - 1];\n\n          if (lastTie.followingNode !== comment.followingNode) {\n            breakTies(tiesToBreak, text, options);\n          }\n        }\n\n        tiesToBreak.push(comment);\n      } else if (precedingNode) {\n        addTrailingComment(precedingNode, comment);\n      } else if (followingNode) {\n        addLeadingComment(followingNode, comment);\n      } else if (enclosingNode) {\n        addDanglingComment(enclosingNode, comment);\n      } else {\n        // There are no nodes, let's attach it to the root of the ast\n\n        /* istanbul ignore next */\n        addDanglingComment(ast, comment);\n      }\n    }\n  });\n  breakTies(tiesToBreak, text, options);\n  comments.forEach(function (comment) {\n    // These node references were useful for breaking ties, but we\n    // don't need them anymore, and they create cycles in the AST that\n    // may lead to infinite recursion if we don't delete them here.\n    delete comment.precedingNode;\n    delete comment.enclosingNode;\n    delete comment.followingNode;\n  });\n}\n\nfunction breakTies(tiesToBreak, text, options) {\n  var tieCount = tiesToBreak.length;\n\n  if (tieCount === 0) {\n    return;\n  }\n\n  var _tiesToBreak$ = tiesToBreak[0],\n      precedingNode = _tiesToBreak$.precedingNode,\n      followingNode = _tiesToBreak$.followingNode;\n  var gapEndPos = options.locStart(followingNode); // Iterate backwards through tiesToBreak, examining the gaps\n  // between the tied comments. In order to qualify as leading, a\n  // comment must be separated from followingNode by an unbroken series of\n  // gaps (or other comments). Gaps should only contain whitespace or open\n  // parentheses.\n\n  var indexOfFirstLeadingComment;\n\n  for (indexOfFirstLeadingComment = tieCount; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {\n    var comment = tiesToBreak[indexOfFirstLeadingComment - 1];\n    assert.strictEqual(comment.precedingNode, precedingNode);\n    assert.strictEqual(comment.followingNode, followingNode);\n    var gap = text.slice(options.locEnd(comment), gapEndPos).trim();\n\n    if (gap === \"\" || /^\\(+$/.test(gap)) {\n      gapEndPos = options.locStart(comment);\n    } else {\n      // The gap string contained something other than whitespace or open\n      // parentheses.\n      break;\n    }\n  }\n\n  tiesToBreak.forEach(function (comment, i) {\n    if (i < indexOfFirstLeadingComment) {\n      addTrailingComment(precedingNode, comment);\n    } else {\n      addLeadingComment(followingNode, comment);\n    }\n  });\n  tiesToBreak.length = 0;\n}\n\nfunction printComment(commentPath, options) {\n  var comment = commentPath.getValue();\n  comment.printed = true;\n  return options.printer.printComment(commentPath, options);\n}\n\nfunction findExpressionIndexForComment(quasis, comment, options) {\n  var startPos = options.locStart(comment) - 1;\n\n  for (var i = 1; i < quasis.length; ++i) {\n    if (startPos < getQuasiRange(quasis[i]).start) {\n      return i - 1;\n    }\n  } // We haven't found it, it probably means that some of the locations are off.\n  // Let's just return the first one.\n\n  /* istanbul ignore next */\n\n\n  return 0;\n}\n\nfunction getQuasiRange(expr) {\n  if (expr.start !== undefined) {\n    // Babel\n    return {\n      start: expr.start,\n      end: expr.end\n    };\n  } // Flow\n\n\n  return {\n    start: expr.range[0],\n    end: expr.range[1]\n  };\n}\n\nfunction printLeadingComment(commentPath, print, options) {\n  var comment = commentPath.getValue();\n  var contents = printComment(commentPath, options);\n\n  if (!contents) {\n    return \"\";\n  }\n\n  var isBlock = options.printer.isBlockComment && options.printer.isBlockComment(comment); // Leading block comments should see if they need to stay on the\n  // same line or not.\n\n  if (isBlock) {\n    return concat([contents, hasNewline(options.originalText, options.locEnd(comment)) ? hardline : \" \"]);\n  }\n\n  return concat([contents, hardline]);\n}\n\nfunction printTrailingComment(commentPath, print, options) {\n  var comment = commentPath.getValue();\n  var contents = printComment(commentPath, options);\n\n  if (!contents) {\n    return \"\";\n  }\n\n  var isBlock = options.printer.isBlockComment && options.printer.isBlockComment(comment); // We don't want the line to break\n  // when the parentParentNode is a ClassDeclaration/-Expression\n  // And the parentNode is in the superClass property\n\n  var parentNode = commentPath.getNode(1);\n  var parentParentNode = commentPath.getNode(2);\n  var isParentSuperClass = parentParentNode && (parentParentNode.type === \"ClassDeclaration\" || parentParentNode.type === \"ClassExpression\") && parentParentNode.superClass === parentNode;\n\n  if (hasNewline(options.originalText, options.locStart(comment), {\n    backwards: true\n  })) {\n    // This allows comments at the end of nested structures:\n    // {\n    //   x: 1,\n    //   y: 2\n    //   // A comment\n    // }\n    // Those kinds of comments are almost always leading comments, but\n    // here it doesn't go \"outside\" the block and turns it into a\n    // trailing comment for `2`. We can simulate the above by checking\n    // if this a comment on its own line; normal trailing comments are\n    // always at the end of another expression.\n    var isLineBeforeEmpty = isPreviousLineEmpty(options.originalText, comment, options.locStart);\n    return lineSuffix(concat([hardline, isLineBeforeEmpty ? hardline : \"\", contents]));\n  } else if (isBlock || isParentSuperClass) {\n    // Trailing block comments never need a newline\n    return concat([\" \", contents]);\n  }\n\n  return concat([lineSuffix(concat([\" \", contents])), !isBlock ? breakParent : \"\"]);\n}\n\nfunction printDanglingComments(path, options, sameIndent, filter) {\n  var parts = [];\n  var node = path.getValue();\n\n  if (!node || !node.comments) {\n    return \"\";\n  }\n\n  path.each(function (commentPath) {\n    var comment = commentPath.getValue();\n\n    if (comment && !comment.leading && !comment.trailing && (!filter || filter(comment))) {\n      parts.push(printComment(commentPath, options));\n    }\n  }, \"comments\");\n\n  if (parts.length === 0) {\n    return \"\";\n  }\n\n  if (sameIndent) {\n    return join(hardline, parts);\n  }\n\n  return indent(concat([hardline, join(hardline, parts)]));\n}\n\nfunction prependCursorPlaceholder(path, options, printed) {\n  if (path.getNode() === options.cursorNode && path.getValue()) {\n    return concat([cursor, printed, cursor]);\n  }\n\n  return printed;\n}\n\nfunction printComments(path, print, options, needsSemi) {\n  var value = path.getValue();\n  var printed = print(path);\n  var comments = value && value.comments;\n\n  if (!comments || comments.length === 0) {\n    return prependCursorPlaceholder(path, options, printed);\n  }\n\n  var leadingParts = [];\n  var trailingParts = [needsSemi ? \";\" : \"\", printed];\n  path.each(function (commentPath) {\n    var comment = commentPath.getValue();\n    var leading = comment.leading,\n        trailing = comment.trailing;\n\n    if (leading) {\n      var contents = printLeadingComment(commentPath, print, options);\n\n      if (!contents) {\n        return;\n      }\n\n      leadingParts.push(contents);\n      var text = options.originalText;\n\n      if (hasNewline(text, skipNewline(text, options.locEnd(comment)))) {\n        leadingParts.push(hardline);\n      }\n    } else if (trailing) {\n      trailingParts.push(printTrailingComment(commentPath, print, options));\n    }\n  }, \"comments\");\n  return prependCursorPlaceholder(path, options, concat(leadingParts.concat(trailingParts)));\n}\n\nmodule.exports = {\n  attach: attach,\n  printComments: printComments,\n  printDanglingComments: printDanglingComments,\n  getSortedChildNodes: getSortedChildNodes\n};"]},"metadata":{},"sourceType":"script"}