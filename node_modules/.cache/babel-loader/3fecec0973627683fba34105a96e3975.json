{"ast":null,"code":"/*\nCopyright (c) 2020 Uber Technologies, Inc.\n\nThis source code is licensed under the MIT license found in the\nLICENSE file in the root directory of this source tree.\n*/\nimport traverse from '@babel/traverse';\nimport generate from '@babel/generator';\nimport * as t from '@babel/types';\nimport { parse as babelParse } from '@babel/parser';\nimport { getAstJsxElement, formatAstAndPrint } from './code-generator';\nexport const parse = code => babelParse(code, {\n  sourceType: 'module',\n  plugins: ['jsx', 'flowComments', 'typescript', 'asyncGenerators', 'classProperties', 'classPrivateProperties', 'classPrivateMethods', ['decorators', {\n    decoratorsBeforeExport: true\n  }], 'doExpressions', 'dynamicImport', 'exportDefaultFrom', 'exportNamespaceFrom', 'functionBind', 'functionSent', 'importMeta', 'logicalAssignment', 'nullishCoalescingOperator', 'numericSeparator', 'objectRestSpread', 'optionalCatchBinding', 'optionalChaining', 'partialApplication', 'throwExpressions', 'topLevelAwait']\n}); // creates a call expression that synchronizes view state\n\nconst getInstrumentOnChange = (what, into) => t.callExpression(t.identifier('__reactViewOnChange'), [t.identifier(what), t.stringLiteral(into)]); // appends a call expression to a function body\n\n\nconst fnBodyAppend = (path, callExpression) => {\n  if (path.node.type !== 'JSXExpressionContainer') {\n    return;\n  }\n\n  const callbackBody = path.get('expression').get('body');\n\n  if (callbackBody.type === 'BlockStatement') {\n    // when the callback body is a block\n    // e.g.: e => { setValue(e.target.value) }\n    callbackBody.pushContainer('body', callExpression);\n  } else {\n    // when it is a single statement like e => setValue(e.target.value)\n    // we have to create a BlockStatement first\n    callbackBody.replaceWith(t.blockStatement([t.expressionStatement(callbackBody.node), t.expressionStatement(callExpression)]));\n  }\n}; // removing all imports, exports and top level\n// variable declaration, add __reactViewOnChange instrumentation when needed\n\n\nexport const transformBeforeCompilation = (ast, elementName, propsConfig) => {\n  try {\n    traverse(ast, {\n      VariableDeclaration(path) {\n        if (path.parent.type === 'Program') {\n          //@ts-ignore\n          path.replaceWith(path.node.declarations[0].init);\n        }\n      },\n\n      ImportDeclaration(path) {\n        path.remove();\n      },\n\n      ExportDefaultDeclaration(path) {\n        if (path.node.declaration.type === 'ArrowFunctionExpression' || path.node.declaration.type === 'FunctionDeclaration') {\n          path.replaceWith(path.node.declaration);\n        } else {\n          path.remove();\n        }\n      },\n\n      // adds internal state instrumentation through __reactViewOnChange callback\n      JSXElement(path) {\n        if (path.node.openingElement.type === 'JSXOpeningElement' && //@ts-ignore\n        path.node.openingElement.name.name === elementName) {\n          if (propsConfig['children'] && propsConfig['children'].propHook) {\n            const propHook = propsConfig['children'].propHook;\n            path.get('children').forEach(child => {\n              typeof propHook === 'object' ? fnBodyAppend(child, getInstrumentOnChange(propHook.what, propHook.into)) : child.traverse(propHook({\n                getInstrumentOnChange,\n                fnBodyAppend\n              }));\n            });\n          }\n\n          path.get('openingElement').get('attributes').forEach(attr => {\n            const name = attr.get('name').node.name;\n            const propHook = propsConfig[name].propHook;\n\n            if (typeof propHook !== 'undefined') {\n              typeof propHook === 'object' ? fnBodyAppend(attr.get('value'), getInstrumentOnChange(propHook.what, propHook.into)) : attr.traverse(propHook({\n                getInstrumentOnChange,\n                fnBodyAppend\n              }));\n            }\n          });\n        }\n      }\n\n    });\n  } catch (e) {}\n\n  return ast;\n};\nexport function parseCode(code, elementName, parseProvider) {\n  const propValues = {};\n  const stateValues = {};\n  let parsedProvider = undefined;\n\n  try {\n    const ast = parse(code);\n    traverse(ast, {\n      JSXElement(path) {\n        if (Object.keys(propValues).length === 0 && // process just the first element\n        path.node.openingElement.type === 'JSXOpeningElement' && //@ts-ignore\n        path.node.openingElement.name.name === elementName) {\n          path.node.openingElement.attributes.forEach(attr => {\n            const name = attr.name.name;\n            let value = null;\n\n            if (attr.value === null) {\n              //boolean prop without value\n              value = true;\n            } else {\n              if (attr.value.type === 'StringLiteral') {\n                value = attr.value.value;\n              } else if (attr.value.type === 'JSXExpressionContainer') {\n                if (attr.value.expression.type === 'BooleanLiteral') {\n                  value = attr.value.expression.value;\n                } else {\n                  value = formatAstAndPrint( //@ts-ignore\n                  t.program([t.expressionStatement(attr.value.expression)]), 30);\n\n                  if (attr.value.expression.type === 'ObjectExpression') {\n                    // the generated code is ({ .... }), this removes the brackets to\n                    // keep the input more readable\n                    value = value.slice(1, -1);\n                  }\n\n                  if (attr.value.expression.type === 'MemberExpression' && attr.value.expression.computed) {\n                    // turn a['hello-world'] into a.hello-world so we don't have to deal with two\n                    // variants in the enum knob UI\n                    value = `${attr.value.expression.object.name}.${attr.value.expression.property.value}`;\n                  }\n                }\n              }\n            }\n\n            propValues[name] = value;\n          });\n          propValues['children'] = formatAstAndPrint(getAstJsxElement('ViewRoot', [], path.node.children), 30).replace(/\\n  /g, '\\n').replace(/^<ViewRoot>\\n?/, '').replace(/<\\/ViewRoot>$/, '').replace(/\\s*<ViewRoot \\/>\\s*/, '');\n        }\n      },\n\n      VariableDeclarator(path) {\n        // looking for React.useState()\n        const node = path.node;\n\n        if (node.id.type === 'ArrayPattern' && node.init.type === 'CallExpression' && node.init.callee.property.name === 'useState') {\n          const name = node.id.elements[0].name;\n          const valueNode = node.init.arguments[0];\n\n          if (valueNode.type === 'StringLiteral' || valueNode.type === 'BooleanLiteral') {\n            stateValues[name] = valueNode.value;\n          } else {\n            stateValues[name] = generate(valueNode).code;\n          }\n        }\n      }\n\n    });\n\n    if (parseProvider) {\n      parsedProvider = parseProvider(ast);\n    }\n  } catch (e) {\n    throw new Error(\"Code is not valid and can't be parsed.\");\n  } // override props by local state (React hooks)\n\n\n  Object.keys(stateValues).forEach(stateValueKey => {\n    Object.keys(propValues).forEach(propValueKey => {\n      if (propValues[propValueKey] === stateValueKey) {\n        propValues[propValueKey] = stateValues[stateValueKey];\n      }\n    });\n  });\n  return {\n    parsedProps: propValues,\n    parsedProvider\n  };\n}","map":{"version":3,"sources":["../../src/ast.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\nCopyright (c) 2020 Uber Technologies, Inc.\n\nThis source code is licensed under the MIT license found in the\nLICENSE file in the root directory of this source tree.\n*/\nimport traverse from '@babel/traverse';\nimport generate from '@babel/generator';\nimport * as t from '@babel/types';\nimport { parse as babelParse } from '@babel/parser';\nimport { getAstJsxElement, formatAstAndPrint } from './code-generator';\nexport const parse = (code) => babelParse(code, {\n    sourceType: 'module',\n    plugins: [\n        'jsx',\n        'flowComments',\n        'typescript',\n        'asyncGenerators',\n        'classProperties',\n        'classPrivateProperties',\n        'classPrivateMethods',\n        [\n            'decorators',\n            {\n                decoratorsBeforeExport: true,\n            },\n        ],\n        'doExpressions',\n        'dynamicImport',\n        'exportDefaultFrom',\n        'exportNamespaceFrom',\n        'functionBind',\n        'functionSent',\n        'importMeta',\n        'logicalAssignment',\n        'nullishCoalescingOperator',\n        'numericSeparator',\n        'objectRestSpread',\n        'optionalCatchBinding',\n        'optionalChaining',\n        'partialApplication',\n        'throwExpressions',\n        'topLevelAwait',\n    ],\n});\n// creates a call expression that synchronizes view state\nconst getInstrumentOnChange = (what, into) => t.callExpression(t.identifier('__reactViewOnChange'), [\n    t.identifier(what),\n    t.stringLiteral(into),\n]);\n// appends a call expression to a function body\nconst fnBodyAppend = (path, callExpression) => {\n    if (path.node.type !== 'JSXExpressionContainer') {\n        return;\n    }\n    const callbackBody = path.get('expression').get('body');\n    if (callbackBody.type === 'BlockStatement') {\n        // when the callback body is a block\n        // e.g.: e => { setValue(e.target.value) }\n        callbackBody.pushContainer('body', callExpression);\n    }\n    else {\n        // when it is a single statement like e => setValue(e.target.value)\n        // we have to create a BlockStatement first\n        callbackBody.replaceWith(t.blockStatement([\n            t.expressionStatement(callbackBody.node),\n            t.expressionStatement(callExpression),\n        ]));\n    }\n};\n// removing all imports, exports and top level\n// variable declaration, add __reactViewOnChange instrumentation when needed\nexport const transformBeforeCompilation = (ast, elementName, propsConfig) => {\n    try {\n        traverse(ast, {\n            VariableDeclaration(path) {\n                if (path.parent.type === 'Program') {\n                    //@ts-ignore\n                    path.replaceWith(path.node.declarations[0].init);\n                }\n            },\n            ImportDeclaration(path) {\n                path.remove();\n            },\n            ExportDefaultDeclaration(path) {\n                if (path.node.declaration.type === 'ArrowFunctionExpression' ||\n                    path.node.declaration.type === 'FunctionDeclaration') {\n                    path.replaceWith(path.node.declaration);\n                }\n                else {\n                    path.remove();\n                }\n            },\n            // adds internal state instrumentation through __reactViewOnChange callback\n            JSXElement(path) {\n                if (path.node.openingElement.type === 'JSXOpeningElement' &&\n                    //@ts-ignore\n                    path.node.openingElement.name.name === elementName) {\n                    if (propsConfig['children'] && propsConfig['children'].propHook) {\n                        const propHook = propsConfig['children'].propHook;\n                        path.get('children').forEach(child => {\n                            typeof propHook === 'object'\n                                ? fnBodyAppend(child, getInstrumentOnChange(propHook.what, propHook.into))\n                                : child.traverse(propHook({ getInstrumentOnChange, fnBodyAppend }));\n                        });\n                    }\n                    path\n                        .get('openingElement')\n                        .get('attributes')\n                        .forEach(attr => {\n                        const name = attr.get('name').node.name;\n                        const propHook = propsConfig[name].propHook;\n                        if (typeof propHook !== 'undefined') {\n                            typeof propHook === 'object'\n                                ? fnBodyAppend(attr.get('value'), getInstrumentOnChange(propHook.what, propHook.into))\n                                : attr.traverse(propHook({ getInstrumentOnChange, fnBodyAppend }));\n                        }\n                    });\n                }\n            },\n        });\n    }\n    catch (e) { }\n    return ast;\n};\nexport function parseCode(code, elementName, parseProvider) {\n    const propValues = {};\n    const stateValues = {};\n    let parsedProvider = undefined;\n    try {\n        const ast = parse(code);\n        traverse(ast, {\n            JSXElement(path) {\n                if (Object.keys(propValues).length === 0 && // process just the first element\n                    path.node.openingElement.type === 'JSXOpeningElement' &&\n                    //@ts-ignore\n                    path.node.openingElement.name.name === elementName) {\n                    path.node.openingElement.attributes.forEach((attr) => {\n                        const name = attr.name.name;\n                        let value = null;\n                        if (attr.value === null) {\n                            //boolean prop without value\n                            value = true;\n                        }\n                        else {\n                            if (attr.value.type === 'StringLiteral') {\n                                value = attr.value.value;\n                            }\n                            else if (attr.value.type === 'JSXExpressionContainer') {\n                                if (attr.value.expression.type === 'BooleanLiteral') {\n                                    value = attr.value.expression.value;\n                                }\n                                else {\n                                    value = formatAstAndPrint(\n                                    //@ts-ignore\n                                    t.program([t.expressionStatement(attr.value.expression)]), 30);\n                                    if (attr.value.expression.type === 'ObjectExpression') {\n                                        // the generated code is ({ .... }), this removes the brackets to\n                                        // keep the input more readable\n                                        value = value.slice(1, -1);\n                                    }\n                                    if (attr.value.expression.type === 'MemberExpression' &&\n                                        attr.value.expression.computed) {\n                                        // turn a['hello-world'] into a.hello-world so we don't have to deal with two\n                                        // variants in the enum knob UI\n                                        value = `${attr.value.expression.object.name}.${attr.value.expression.property.value}`;\n                                    }\n                                }\n                            }\n                        }\n                        propValues[name] = value;\n                    });\n                    propValues['children'] = formatAstAndPrint(getAstJsxElement('ViewRoot', [], path.node.children), 30)\n                        .replace(/\\n  /g, '\\n')\n                        .replace(/^<ViewRoot>\\n?/, '')\n                        .replace(/<\\/ViewRoot>$/, '')\n                        .replace(/\\s*<ViewRoot \\/>\\s*/, '');\n                }\n            },\n            VariableDeclarator(path) {\n                // looking for React.useState()\n                const node = path.node;\n                if (node.id.type === 'ArrayPattern' &&\n                    node.init.type === 'CallExpression' &&\n                    node.init.callee.property.name === 'useState') {\n                    const name = node.id.elements[0].name;\n                    const valueNode = node.init.arguments[0];\n                    if (valueNode.type === 'StringLiteral' ||\n                        valueNode.type === 'BooleanLiteral') {\n                        stateValues[name] = valueNode.value;\n                    }\n                    else {\n                        stateValues[name] = generate(valueNode).code;\n                    }\n                }\n            },\n        });\n        if (parseProvider) {\n            parsedProvider = parseProvider(ast);\n        }\n    }\n    catch (e) {\n        throw new Error(\"Code is not valid and can't be parsed.\");\n    }\n    // override props by local state (React hooks)\n    Object.keys(stateValues).forEach(stateValueKey => {\n        Object.keys(propValues).forEach(propValueKey => {\n            if (propValues[propValueKey] === stateValueKey) {\n                propValues[propValueKey] = stateValues[stateValueKey];\n            }\n        });\n    });\n    return { parsedProps: propValues, parsedProvider };\n}\n//# sourceMappingURL=ast.js.map"]},"metadata":{},"sourceType":"module"}