"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = require("../common/util"),
    getLast = _require.getLast; // fix unexpected locEnd caused by --no-semi style


function postprocess(ast, options) {
  visitNode(ast, function (node) {
    switch (node.type) {
      case "VariableDeclaration":
        {
          var lastDeclaration = getLast(node.declarations);

          if (lastDeclaration && lastDeclaration.init) {
            overrideLocEnd(node, lastDeclaration);
          }

          break;
        }
    }
  });
  return ast;
  /**
   * - `toOverrideNode` must be the last thing in `toBeOverriddenNode`
   * - do nothing if there's a semicolon on `toOverrideNode.end` (no need to fix)
   */

  function overrideLocEnd(toBeOverriddenNode, toOverrideNode) {
    if (options.originalText[locEnd(toOverrideNode)] === ";") {
      return;
    }

    if (options.parser === "flow") {
      toBeOverriddenNode.range = [toBeOverriddenNode.range[0], toOverrideNode.range[1]];
    } else {
      toBeOverriddenNode.end = toOverrideNode.end;
    }

    toBeOverriddenNode.loc = Object.assign({}, toBeOverriddenNode.loc, {
      end: toBeOverriddenNode.loc.end
    });
  }

  function locEnd(node) {
    return options.parser === "flow" ? node.range[1] : node.end;
  }
}

function visitNode(node, fn) {
  if (!node || _typeof(node) !== "object") {
    return;
  }

  if (Array.isArray(node)) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = node[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var subNode = _step.value;
        visitNode(subNode, fn);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return;
  }

  if (typeof node.type !== "string") {
    return;
  }

  for (var _i = 0, _Object$keys = Object.keys(node); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    visitNode(node[key], fn);
  }

  fn(node);
}

module.exports = postprocess;