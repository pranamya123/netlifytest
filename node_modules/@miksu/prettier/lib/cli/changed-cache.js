"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var crypto = require("crypto"); // Generates a hash of the input string.


function hash(data) {
  return crypto.createHash("sha1").update(data).digest("base64");
} // Generates the cache key using the file path, options and the support info hash.


function calcKey(path, options, supportInfoHash) {
  return hash(path + JSON.stringify(options) + supportInfoHash);
}

var ChangedCache =
/*#__PURE__*/
function () {
  // Initializes the in-memory cache data from the configured location.
  // Also calculates the static support info hash used to compute file keys.
  // A missing cache file is not treated as an error because it is expected on first run.
  function ChangedCache(options) {
    _classCallCheck(this, ChangedCache);

    this.location = options.location;
    this.readFile = options.readFile;
    this.writeFile = options.writeFile;
    this.context = options.context;
    this.supportInfoHash = hash(JSON.stringify(options.supportInfo));
    this.cache = {};
    var contents;

    try {
      contents = this.readFile(this.location, "utf8");
    } catch (err) {
      if (err.code !== "ENOENT") {
        this.context.logger.error("Could not read cache file: ".concat(err));
      }

      return;
    }

    try {
      this.cache = JSON.parse(contents);
    } catch (err) {
      this.context.logger.error("Could not parse cache contents: ".concat(err));
    }
  } // Writes the in-memory cache data to the configured file.
  // Previous file contents are overwritten.


  _createClass(ChangedCache, [{
    key: "close",
    value: function close() {
      var contents;

      try {
        contents = JSON.stringify(this.cache);
      } catch (err) {
        this.context.logger.error("Could not serialize cache: ".concat(err));
        return;
      }

      try {
        this.writeFile(this.location, contents, "utf8");
      } catch (err) {
        this.context.logger.error("Could not write cache to file: ".concat(err));
      }
    } // Checks if the expected contents of the file path match the in-memory data.

  }, {
    key: "notChanged",
    value: function notChanged(path, options, content) {
      return this.cache[calcKey(path, options, this.supportInfoHash)] === hash(content);
    } // Updates the expected contents of the file path in the in-memory data.

  }, {
    key: "update",
    value: function update(path, options, content) {
      this.cache[calcKey(path, options, this.supportInfoHash)] = hash(content);
    }
  }]);

  return ChangedCache;
}();

module.exports = ChangedCache;