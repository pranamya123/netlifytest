"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var path = require("path");

var camelCase = require("camelcase");

var dashify = require("dashify");

var fs = require("fs");

var globby = require("globby");

var chalk = require("chalk");

var readline = require("readline");

var stringify = require("json-stable-stringify");

var findCacheDir = require("find-cache-dir");

var os = require("os");

var minimist = require("./minimist");

var prettier = require("../../index");

var createIgnorer = require("../common/create-ignorer");

var errors = require("../common/errors");

var constant = require("./constant");

var coreOptions = require("../main/core-options");

var optionsModule = require("../main/options");

var optionsNormalizer = require("../main/options-normalizer");

var thirdParty = require("../common/third-party");

var arrayify = require("../utils/arrayify");

var isTTY = require("../utils/is-tty");

var ChangedCache = require("./changed-cache");

var OPTION_USAGE_THRESHOLD = 25;
var CHOICE_USAGE_MARGIN = 3;
var CHOICE_USAGE_INDENTATION = 2;

function getOptions(argv, detailedOptions) {
  return detailedOptions.filter(function (option) {
    return option.forwardToApi;
  }).reduce(function (current, option) {
    return Object.assign(current, _defineProperty({}, option.forwardToApi, argv[option.name]));
  }, {});
}

function cliifyOptions(object, apiDetailedOptionMap) {
  return Object.keys(object || {}).reduce(function (output, key) {
    var apiOption = apiDetailedOptionMap[key];
    var cliKey = apiOption ? apiOption.name : key;
    output[dashify(cliKey)] = object[key];
    return output;
  }, {});
}

function diff(a, b) {
  return require("diff").createTwoFilesPatch("", "", a, b, "", "", {
    context: 2
  });
}

function handleError(context, filename, error) {
  if (error instanceof errors.UndefinedParserError) {
    if (context.argv["write"] && isTTY()) {
      readline.clearLine(process.stdout, 0);
      readline.cursorTo(process.stdout, 0, null);
    }

    if (!context.argv["check"] && !context.argv["list-different"]) {
      process.exitCode = 2;
    }

    context.logger.error(error.message);
    return;
  }

  if (context.argv["write"]) {
    // Add newline to split errors from filename line.
    process.stdout.write("\n");
  }

  var isParseError = Boolean(error && error.loc);
  var isValidationError = /Validation Error/.test(error && error.message); // For parse errors and validation errors, we only want to show the error
  // message formatted in a nice way. `String(error)` takes care of that. Other
  // (unexpected) errors are passed as-is as a separate argument to
  // `console.error`. That includes the stack trace (if any), and shows a nice
  // `util.inspect` of throws things that aren't `Error` objects. (The Flow
  // parser has mistakenly thrown arrays sometimes.)

  if (isParseError) {
    context.logger.error("".concat(filename, ": ").concat(String(error)));
  } else if (isValidationError || error instanceof errors.ConfigError) {
    context.logger.error(String(error)); // If validation fails for one file, it will fail for all of them.

    process.exit(1);
  } else if (error instanceof errors.DebugError) {
    context.logger.error("".concat(filename, ": ").concat(error.message));
  } else {
    context.logger.error(filename + ": " + (error.stack || error));
  } // Don't exit the process if one file failed


  process.exitCode = 2;
}

function logResolvedConfigPathOrDie(context) {
  var configFile = prettier.resolveConfigFile.sync(context.argv["find-config-path"]);

  if (configFile) {
    context.logger.log(path.relative(process.cwd(), configFile));
  } else {
    process.exit(1);
  }
}

function logFileInfoOrDie(context) {
  var options = {
    ignorePath: context.argv["ignore-path"],
    withNodeModules: context.argv["with-node-modules"],
    plugins: context.argv["plugin"],
    pluginSearchDirs: context.argv["plugin-search-dir"]
  };
  context.logger.log(prettier.format(stringify(prettier.getFileInfo.sync(context.argv["file-info"], options)), {
    parser: "json"
  }));
}

function writeOutput(context, result, options) {
  // Don't use `console.log` here since it adds an extra newline at the end.
  process.stdout.write(context.argv["debug-check"] ? result.filepath : result.formatted);

  if (options && options.cursorOffset >= 0) {
    process.stderr.write(result.cursorOffset + "\n");
  }
}

function listDifferent(context, input, options, filename) {
  if (!context.argv["check"] && !context.argv["list-different"]) {
    return;
  }

  try {
    if (!options.filepath && !options.parser) {
      throw new errors.UndefinedParserError("No parser and no file path given, couldn't infer a parser.");
    }

    if (!prettier.check(input, options)) {
      if (!context.argv["write"]) {
        context.logger.log(filename);
        process.exitCode = 1;
      }
    }
  } catch (error) {
    context.logger.error(error.message);
  }

  return true;
}

function format(context, input, opt) {
  if (!opt.parser && !opt.filepath) {
    throw new errors.UndefinedParserError("No parser and no file path given, couldn't infer a parser.");
  }

  if (context.argv["debug-print-doc"]) {
    var doc = prettier.__debug.printToDoc(input, opt);

    return {
      formatted: prettier.__debug.formatDoc(doc)
    };
  }

  if (context.argv["debug-check"]) {
    var pp = prettier.format(input, opt);
    var pppp = prettier.format(pp, opt);

    if (pp !== pppp) {
      throw new errors.DebugError("prettier(input) !== prettier(prettier(input))\n" + diff(pp, pppp));
    } else {
      var _stringify = function _stringify(obj) {
        return JSON.stringify(obj, null, 2);
      };

      var ast = _stringify(prettier.__debug.parse(input, opt,
      /* massage */
      true).ast);

      var past = _stringify(prettier.__debug.parse(pp, opt,
      /* massage */
      true).ast);

      if (ast !== past) {
        var MAX_AST_SIZE = 2097152; // 2MB

        var astDiff = ast.length > MAX_AST_SIZE || past.length > MAX_AST_SIZE ? "AST diff too large to render" : diff(ast, past);
        throw new errors.DebugError("ast(input) !== ast(prettier(input))\n" + astDiff + "\n" + diff(input, pp));
      }
    }

    return {
      formatted: pp,
      filepath: opt.filepath || "(stdin)\n"
    };
  }
  /* istanbul ignore if */


  if (context.argv["debug-benchmark"]) {
    var benchmark;

    try {
      benchmark = eval("require")("benchmark");
    } catch (err) {
      context.logger.debug("'--debug-benchmark' requires the 'benchmark' package to be installed.");
      process.exit(2);
    }

    context.logger.debug("'--debug-benchmark' option found, measuring formatWithCursor with 'benchmark' module.");
    var suite = new benchmark.Suite();
    suite.add("format", function () {
      prettier.formatWithCursor(input, opt);
    }).on("cycle", function (event) {
      var results = {
        benchmark: String(event.target),
        hz: event.target.hz,
        ms: event.target.times.cycle * 1000
      };
      context.logger.debug("'--debug-benchmark' measurements for formatWithCursor: " + JSON.stringify(results, null, 2));
    }).run({
      async: false
    });
  } else if (context.argv["debug-repeat"] > 0) {
    var repeat = context.argv["debug-repeat"];
    context.logger.debug("'--debug-repeat' option found, running formatWithCursor " + repeat + " times."); // should be using `performance.now()`, but only `Date` is cross-platform enough

    var now = Date.now ? function () {
      return Date.now();
    } : function () {
      return +new Date();
    };
    var totalMs = 0;

    for (var i = 0; i < repeat; ++i) {
      var startMs = now();
      prettier.formatWithCursor(input, opt);
      totalMs += now() - startMs;
    }

    var averageMs = totalMs / repeat;
    var results = {
      repeat: repeat,
      hz: 1000 / averageMs,
      ms: averageMs
    };
    context.logger.debug("'--debug-repeat' measurements for formatWithCursor: " + JSON.stringify(results, null, 2));
  }

  return prettier.formatWithCursor(input, opt);
}

function getOptionsOrDie(context, filePath) {
  try {
    if (context.argv["config"] === false) {
      context.logger.debug("'--no-config' option found, skip loading config file.");
      return null;
    }

    context.logger.debug(context.argv["config"] ? "load config file from '".concat(context.argv["config"], "'") : "resolve config from '".concat(filePath, "'"));
    var options = prettier.resolveConfig.sync(filePath, {
      editorconfig: context.argv["editorconfig"],
      config: context.argv["config"]
    });
    context.logger.debug("loaded options `" + JSON.stringify(options) + "`");
    return options;
  } catch (error) {
    context.logger.error("Invalid configuration file: " + error.message);
    process.exit(2);
  }
}

function getOptionsForFile(context, filepath) {
  var options = getOptionsOrDie(context, filepath);
  var hasPlugins = options && options.plugins;

  if (hasPlugins) {
    pushContextPlugins(context, options.plugins);
  }

  var appliedOptions = Object.assign({
    filepath: filepath
  }, applyConfigPrecedence(context, options && optionsNormalizer.normalizeApiOptions(options, context.supportOptions, {
    logger: context.logger
  })));
  context.logger.debug("applied config-precedence (".concat(context.argv["config-precedence"], "): ") + "".concat(JSON.stringify(appliedOptions)));

  if (hasPlugins) {
    popContextPlugins(context);
  }

  return appliedOptions;
}

function parseArgsToOptions(context, overrideDefaults) {
  var minimistOptions = createMinimistOptions(context.detailedOptions);
  var apiDetailedOptionMap = createApiDetailedOptionMap(context.detailedOptions);
  return getOptions(optionsNormalizer.normalizeCliOptions(minimist(context.args, Object.assign({
    string: minimistOptions.string,
    "boolean": minimistOptions["boolean"],
    "default": cliifyOptions(overrideDefaults, apiDetailedOptionMap)
  })), context.detailedOptions, {
    logger: false
  }), context.detailedOptions);
}

function applyConfigPrecedence(context, options) {
  try {
    switch (context.argv["config-precedence"]) {
      case "cli-override":
        return parseArgsToOptions(context, options);

      case "file-override":
        return Object.assign({}, parseArgsToOptions(context), options);

      case "prefer-file":
        return options || parseArgsToOptions(context);
    }
  } catch (error) {
    context.logger.error(error.toString());
    process.exit(2);
  }
}

function formatStdin(context) {
  var filepath = context.argv["stdin-filepath"] ? path.resolve(process.cwd(), context.argv["stdin-filepath"]) : process.cwd();
  var ignorer = createIgnorerFromContextOrDie(context);
  var relativeFilepath = path.relative(process.cwd(), filepath);
  thirdParty.getStream(process.stdin).then(function (input) {
    if (relativeFilepath && ignorer.filter([relativeFilepath]).length === 0) {
      writeOutput(context, {
        formatted: input
      });
      return;
    }

    var options = getOptionsForFile(context, filepath);

    try {
      if (listDifferent(context, input, options, "(stdin)")) {
        return;
      }

      writeOutput(context, format(context, input, options), options);
    } catch (error) {
      handleError(context, relativeFilepath || "stdin", error);
    }
  });
}

function createIgnorerFromContextOrDie(context) {
  try {
    return createIgnorer.sync(context.argv["ignore-path"], context.argv["with-node-modules"]);
  } catch (e) {
    context.logger.error(e.message);
    process.exit(2);
  }
}

function eachFilename(context, patterns, callback) {
  // The '!./' globs are due to https://github.com/prettier/prettier/issues/2110
  var ignoreNodeModules = context.argv["with-node-modules"] !== true;

  if (ignoreNodeModules) {
    patterns = patterns.concat(["!**/node_modules/**", "!./node_modules/**"]);
  }

  patterns = patterns.concat(["!**/.{git,svn,hg}/**", "!./.{git,svn,hg}/**"]);

  try {
    var filePaths = globby.sync(patterns, {
      dot: true,
      nodir: true
    }).map(function (filePath) {
      return path.relative(process.cwd(), filePath);
    });

    if (filePaths.length === 0) {
      context.logger.error("No matching files. Patterns tried: ".concat(patterns.join(" ")));
      process.exitCode = 2;
      return;
    }

    filePaths.forEach(function (filePath) {
      return callback(filePath);
    });
  } catch (error) {
    context.logger.error("Unable to expand glob patterns: ".concat(patterns.join(" "), "\n").concat(error.message)); // Don't exit the process if one pattern failed

    process.exitCode = 2;
  }
}

function formatFiles(context) {
  // The ignorer will be used to filter file paths after the glob is checked,
  // before any files are actually written
  var ignorer = createIgnorerFromContextOrDie(context);
  var numberOfUnformattedFilesFound = 0;

  if (context.argv["check"]) {
    context.logger.log("Checking formatting...");
  }

  var changedCache = null;

  if (context.argv["only-changed"]) {
    var cacheDir = findCacheDir({
      name: "prettier",
      create: true
    }) || os.tmpdir();
    changedCache = new ChangedCache({
      location: path.join(cacheDir, "changed"),
      readFile: fs.readFileSync,
      writeFile: thirdParty.writeFileAtomic,
      context: context,
      supportInfo: prettier.getSupportInfo()
    });
  }

  eachFilename(context, context.filePatterns, function (filename) {
    var fileIgnored = ignorer.filter([filename]).length === 0;

    if (fileIgnored && (context.argv["debug-check"] || context.argv["write"] || context.argv["check"] || context.argv["list-different"])) {
      return;
    }

    var options = Object.assign(getOptionsForFile(context, filename), {
      filepath: filename
    });

    var _removeFilename = function removeFilename() {};

    if (isTTY()) {
      // Don't use `console.log` here since we need to replace this line.
      context.logger.log(filename, {
        newline: false
      });

      _removeFilename = function removeFilename() {
        readline.clearLine(process.stdout, 0);
        readline.cursorTo(process.stdout, 0, null);

        _removeFilename = function removeFilename() {};
      };
    }

    var input;

    try {
      input = fs.readFileSync(filename, "utf8");
    } catch (error) {
      // Add newline to split errors from filename line.
      context.logger.log("");
      context.logger.error("Unable to read file: ".concat(filename, "\n").concat(error.message)); // Don't exit the process if one file failed

      process.exitCode = 2;
      return;
    }

    if (changedCache) {
      if (changedCache.notChanged(filename, options, input)) {
        // Remove previously printed filename to log it with "unchanged".
        _removeFilename();

        if (!context.argv["check"] && !context.argv["list-different"]) {
          context.logger.log(chalk.grey("".concat(filename, " unchanged")));
        }

        return;
      }
    }

    if (fileIgnored) {
      writeOutput(context, {
        formatted: input
      }, options);
      return;
    }

    var start = Date.now();
    var result;
    var output;

    try {
      result = format(context, input, Object.assign({}, options, {
        filepath: filename
      }));
      output = result.formatted;
    } catch (error) {
      handleError(context, filename, error);
      return;
    }

    var isDifferent = output !== input; // Remove previously printed filename to log it with duration.

    _removeFilename();

    if (context.argv["write"]) {
      // Don't write the file if it won't change in order not to invalidate
      // mtime based caches.
      if (isDifferent) {
        if (!context.argv["check"] && !context.argv["list-different"]) {
          context.logger.log("".concat(filename, " ").concat(Date.now() - start, "ms"));
        }

        try {
          fs.writeFileSync(filename, output, "utf8");
        } catch (error) {
          context.logger.error("Unable to write file: ".concat(filename, "\n").concat(error.message)); // Don't exit the process if one file failed

          process.exitCode = 2;
        }
      } else {
        if (!context.argv["check"] && !context.argv["list-different"]) {
          context.logger.log("".concat(chalk.grey(filename), " ").concat(Date.now() - start, "ms"));
        }
      } // Cache is updated to record pretty content.


      if (changedCache) {
        changedCache.update(filename, options, output);
      }
    } else if (context.argv["debug-check"]) {
      if (result.filepath) {
        context.logger.log(result.filepath);
      } else {
        process.exitCode = 2;
      }
    } else if (!context.argv["check"] && !context.argv["list-different"]) {
      writeOutput(context, result, options);
    }

    if ((context.argv["check"] || context.argv["list-different"]) && isDifferent) {
      context.logger.log(filename);
      numberOfUnformattedFilesFound += 1;
    }
  });

  if (changedCache) {
    changedCache.close();
  } // Print check summary based on expected exit code


  if (context.argv["check"]) {
    context.logger.log(numberOfUnformattedFilesFound === 0 ? "All matched files use Prettier code style!" : context.argv["write"] ? "Code style issues fixed in the above file(s)." : "Code style issues found in the above file(s). Forgot to run Prettier?");
  } // Ensure non-zero exitCode when using --check/list-different is not combined with --write


  if ((context.argv["check"] || context.argv["list-different"]) && numberOfUnformattedFilesFound > 0 && !process.exitCode && !context.argv["write"]) {
    process.exitCode = 1;
  }
}

function getOptionsWithOpposites(options) {
  // Add --no-foo after --foo.
  var optionsWithOpposites = options.map(function (option) {
    return [option.description ? option : null, option.oppositeDescription ? Object.assign({}, option, {
      name: "no-".concat(option.name),
      type: "boolean",
      description: option.oppositeDescription
    }) : null];
  });
  return flattenArray(optionsWithOpposites).filter(Boolean);
}

function createUsage(context) {
  var options = getOptionsWithOpposites(context.detailedOptions).filter( // remove unnecessary option (e.g. `semi`, `color`, etc.), which is only used for --help <flag>
  function (option) {
    return !(option.type === "boolean" && option.oppositeDescription && !option.name.startsWith("no-"));
  });
  var groupedOptions = groupBy(options, function (option) {
    return option.category;
  });
  var firstCategories = constant.categoryOrder.slice(0, -1);
  var lastCategories = constant.categoryOrder.slice(-1);
  var restCategories = Object.keys(groupedOptions).filter(function (category) {
    return firstCategories.indexOf(category) === -1 && lastCategories.indexOf(category) === -1;
  });
  var allCategories = firstCategories.concat(restCategories, lastCategories);
  var optionsUsage = allCategories.map(function (category) {
    var categoryOptions = groupedOptions[category].map(function (option) {
      return createOptionUsage(context, option, OPTION_USAGE_THRESHOLD);
    }).join("\n");
    return "".concat(category, " options:\n\n").concat(indent(categoryOptions, 2));
  });
  return [constant.usageSummary].concat(optionsUsage, [""]).join("\n\n");
}

function createOptionUsage(context, option, threshold) {
  var header = createOptionUsageHeader(option);
  var optionDefaultValue = getOptionDefaultValue(context, option.name);
  return createOptionUsageRow(header, "".concat(option.description).concat(optionDefaultValue === undefined ? "" : "\nDefaults to ".concat(createDefaultValueDisplay(optionDefaultValue), ".")), threshold);
}

function createDefaultValueDisplay(value) {
  return Array.isArray(value) ? "[".concat(value.map(createDefaultValueDisplay).join(", "), "]") : value;
}

function createOptionUsageHeader(option) {
  var name = "--".concat(option.name);
  var alias = option.alias ? "-".concat(option.alias, ",") : null;
  var type = createOptionUsageType(option);
  return [alias, name, type].filter(Boolean).join(" ");
}

function createOptionUsageRow(header, content, threshold) {
  var separator = header.length >= threshold ? "\n".concat(" ".repeat(threshold)) : " ".repeat(threshold - header.length);
  var description = content.replace(/\n/g, "\n".concat(" ".repeat(threshold)));
  return "".concat(header).concat(separator).concat(description);
}

function createOptionUsageType(option) {
  switch (option.type) {
    case "boolean":
      return null;

    case "choice":
      return "<".concat(option.choices.filter(function (choice) {
        return choice.since !== null;
      }).filter(function (choice) {
        return !choice.deprecated;
      }).map(function (choice) {
        return choice.value;
      }).join("|"), ">");

    default:
      return "<".concat(option.type, ">");
  }
}

function flattenArray(array) {
  return [].concat.apply([], array);
}

function createChoiceUsages(choices, margin, indentation) {
  var activeChoices = choices.filter(function (choice) {
    return !choice.deprecated && choice.since !== null;
  });
  var threshold = activeChoices.map(function (choice) {
    return choice.value.length;
  }).reduce(function (current, length) {
    return Math.max(current, length);
  }, 0) + margin;
  return activeChoices.map(function (choice) {
    return indent(createOptionUsageRow(choice.value, choice.description, threshold), indentation);
  });
}

function createDetailedUsage(context, flag) {
  var option = getOptionsWithOpposites(context.detailedOptions).find(function (option) {
    return option.name === flag || option.alias === flag;
  });
  var header = createOptionUsageHeader(option);
  var description = "\n\n".concat(indent(option.description, 2));
  var choices = option.type !== "choice" ? "" : "\n\nValid options:\n\n".concat(createChoiceUsages(option.choices, CHOICE_USAGE_MARGIN, CHOICE_USAGE_INDENTATION).join("\n"));
  var optionDefaultValue = getOptionDefaultValue(context, option.name);
  var defaults = optionDefaultValue !== undefined ? "\n\nDefault: ".concat(createDefaultValueDisplay(optionDefaultValue)) : "";
  var pluginDefaults = option.pluginDefaults && Object.keys(option.pluginDefaults).length ? "\nPlugin defaults:".concat(Object.keys(option.pluginDefaults).map(function (key) {
    return "\n* ".concat(key, ": ").concat(createDefaultValueDisplay(option.pluginDefaults[key]));
  })) : "";
  return "".concat(header).concat(description).concat(choices).concat(defaults).concat(pluginDefaults);
}

function getOptionDefaultValue(context, optionName) {
  // --no-option
  if (!(optionName in context.detailedOptionMap)) {
    return undefined;
  }

  var option = context.detailedOptionMap[optionName];

  if (option["default"] !== undefined) {
    return option["default"];
  }

  var optionCamelName = camelCase(optionName);

  if (optionCamelName in context.apiDefaultOptions) {
    return context.apiDefaultOptions[optionCamelName];
  }

  return undefined;
}

function indent(str, spaces) {
  return str.replace(/^/gm, " ".repeat(spaces));
}

function groupBy(array, getKey) {
  return array.reduce(function (obj, item) {
    var key = getKey(item);
    var previousItems = key in obj ? obj[key] : [];
    return Object.assign({}, obj, _defineProperty({}, key, previousItems.concat(item)));
  }, Object.create(null));
}

function pick(object, keys) {
  return !keys ? object : keys.reduce(function (reduced, key) {
    return Object.assign(reduced, _defineProperty({}, key, object[key]));
  }, {});
}

function createLogger(logLevel) {
  return {
    warn: createLogFunc("warn", "yellow"),
    error: createLogFunc("error", "red"),
    debug: createLogFunc("debug", "blue"),
    log: createLogFunc("log")
  };

  function createLogFunc(loggerName, color) {
    if (!shouldLog(loggerName)) {
      return function () {};
    }

    var prefix = color ? "[".concat(chalk[color](loggerName), "] ") : "";
    return function (message, opts) {
      opts = Object.assign({
        newline: true
      }, opts);
      var stream = process[loggerName === "log" ? "stdout" : "stderr"];
      stream.write(message.replace(/^/gm, prefix) + (opts.newline ? "\n" : ""));
    };
  }

  function shouldLog(loggerName) {
    switch (logLevel) {
      case "silent":
        return false;

      default:
        return true;

      case "debug":
        if (loggerName === "debug") {
          return true;
        }

      // fall through

      case "log":
        if (loggerName === "log") {
          return true;
        }

      // fall through

      case "warn":
        if (loggerName === "warn") {
          return true;
        }

      // fall through

      case "error":
        return loggerName === "error";
    }
  }
}

function normalizeDetailedOption(name, option) {
  return Object.assign({
    category: coreOptions.CATEGORY_OTHER
  }, option, {
    choices: option.choices && option.choices.map(function (choice) {
      var newChoice = Object.assign({
        description: "",
        deprecated: false
      }, _typeof(choice) === "object" ? choice : {
        value: choice
      });

      if (newChoice.value === true) {
        newChoice.value = ""; // backward compability for original boolean option
      }

      return newChoice;
    })
  });
}

function normalizeDetailedOptionMap(detailedOptionMap) {
  return Object.keys(detailedOptionMap).sort().reduce(function (normalized, name) {
    var option = detailedOptionMap[name];
    return Object.assign(normalized, _defineProperty({}, name, normalizeDetailedOption(name, option)));
  }, {});
}

function createMinimistOptions(detailedOptions) {
  return {
    // we use vnopts' AliasSchema to handle aliases for better error messages
    alias: {},
    "boolean": detailedOptions.filter(function (option) {
      return option.type === "boolean";
    }).map(function (option) {
      return [option.name].concat(option.alias || []);
    }).reduce(function (a, b) {
      return a.concat(b);
    }),
    string: detailedOptions.filter(function (option) {
      return option.type !== "boolean";
    }).map(function (option) {
      return [option.name].concat(option.alias || []);
    }).reduce(function (a, b) {
      return a.concat(b);
    }),
    "default": detailedOptions.filter(function (option) {
      return !option.deprecated;
    }).filter(function (option) {
      return !option.forwardToApi || option.name === "plugin" || option.name === "plugin-search-dir";
    }).filter(function (option) {
      return option["default"] !== undefined;
    }).reduce(function (current, option) {
      return Object.assign(_defineProperty({}, option.name, option["default"]), current);
    }, {})
  };
}

function createApiDetailedOptionMap(detailedOptions) {
  return detailedOptions.reduce(function (current, option) {
    return option.forwardToApi && option.forwardToApi !== option.name ? Object.assign(current, _defineProperty({}, option.forwardToApi, option)) : current;
  }, {});
}

function createDetailedOptionMap(supportOptions) {
  return supportOptions.reduce(function (reduced, option) {
    var newOption = Object.assign({}, option, {
      name: option.cliName || dashify(option.name),
      description: option.cliDescription || option.description,
      category: option.cliCategory || coreOptions.CATEGORY_FORMAT,
      forwardToApi: option.name
    });

    if (option.deprecated) {
      delete newOption.forwardToApi;
      delete newOption.description;
      delete newOption.oppositeDescription;
      newOption.deprecated = true;
    }

    return Object.assign(reduced, _defineProperty({}, newOption.name, newOption));
  }, {});
} //-----------------------------context-util-start-------------------------------

/**
 * @typedef {Object} Context
 * @property logger
 * @property args
 * @property argv
 * @property filePatterns
 * @property supportOptions
 * @property detailedOptions
 * @property detailedOptionMap
 * @property apiDefaultOptions
 */


function createContext(args) {
  var context = {
    args: args
  };
  updateContextArgv(context);
  normalizeContextArgv(context, ["loglevel", "plugin", "plugin-search-dir"]);
  context.logger = createLogger(context.argv["loglevel"]);
  updateContextArgv(context, context.argv["plugin"], context.argv["plugin-search-dir"]);
  return context;
}

function initContext(context) {
  // split into 2 step so that we could wrap this in a `try..catch` in cli/index.js
  normalizeContextArgv(context);
}

function updateContextOptions(context, plugins, pluginSearchDirs) {
  var supportOptions = prettier.getSupportInfo(null, {
    showDeprecated: true,
    showUnreleased: true,
    showInternal: true,
    plugins: plugins,
    pluginSearchDirs: pluginSearchDirs
  }).options;
  var detailedOptionMap = normalizeDetailedOptionMap(Object.assign({}, createDetailedOptionMap(supportOptions), constant.options));
  var detailedOptions = arrayify(detailedOptionMap, "name");
  var apiDefaultOptions = supportOptions.filter(function (optionInfo) {
    return !optionInfo.deprecated;
  }).reduce(function (reduced, optionInfo) {
    return Object.assign(reduced, _defineProperty({}, optionInfo.name, optionInfo["default"]));
  }, Object.assign({}, optionsModule.hiddenDefaults));
  context.supportOptions = supportOptions;
  context.detailedOptions = detailedOptions;
  context.detailedOptionMap = detailedOptionMap;
  context.apiDefaultOptions = apiDefaultOptions;
}

function pushContextPlugins(context, plugins, pluginSearchDirs) {
  context._supportOptions = context.supportOptions;
  context._detailedOptions = context.detailedOptions;
  context._detailedOptionMap = context.detailedOptionMap;
  context._apiDefaultOptions = context.apiDefaultOptions;
  updateContextOptions(context, plugins, pluginSearchDirs);
}

function popContextPlugins(context) {
  context.supportOptions = context._supportOptions;
  context.detailedOptions = context._detailedOptions;
  context.detailedOptionMap = context._detailedOptionMap;
  context.apiDefaultOptions = context._apiDefaultOptions;
}

function updateContextArgv(context, plugins, pluginSearchDirs) {
  pushContextPlugins(context, plugins, pluginSearchDirs);
  var minimistOptions = createMinimistOptions(context.detailedOptions);
  var argv = minimist(context.args, minimistOptions);
  context.argv = argv;
  context.filePatterns = argv["_"];
}

function normalizeContextArgv(context, keys) {
  var detailedOptions = !keys ? context.detailedOptions : context.detailedOptions.filter(function (option) {
    return keys.indexOf(option.name) !== -1;
  });
  var argv = !keys ? context.argv : pick(context.argv, keys);
  context.argv = optionsNormalizer.normalizeCliOptions(argv, detailedOptions, {
    logger: context.logger
  });
} //------------------------------context-util-end--------------------------------


module.exports = {
  createContext: createContext,
  createDetailedOptionMap: createDetailedOptionMap,
  createDetailedUsage: createDetailedUsage,
  createUsage: createUsage,
  format: format,
  formatFiles: formatFiles,
  formatStdin: formatStdin,
  initContext: initContext,
  logResolvedConfigPathOrDie: logResolvedConfigPathOrDie,
  logFileInfoOrDie: logFileInfoOrDie,
  normalizeDetailedOptionMap: normalizeDetailedOptionMap
};